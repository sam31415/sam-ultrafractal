comment{

Formulas by Samuel Monnier, 1999-2001. 

You can visit my webpage and 
update this file at
http://www.envy.nu/s31415/index/index.htm

If you have questions or comments, you can mail
me at samuel.monnier@urbanet.ch 

}



TwistMand {
;By Samuel Monnier, 1999
init:

  z = @f(#pixel) + @start
  
loop:

  z = @fp(z ^ @power + @fr(real(#pixel)) \
  + (0,1) * @fi(imag(#pixel)))

bailout:

  |z| < @bailout

default:

  title = "Twist the Mandelbrot Set"
  
  center = (-.5, 0)
  
  method = multipass
  
  param bailout
  caption = "Bailout"
  default = 4.0
  endparam
  
  param power
  caption = "Power"
  default = 2.0
  endparam
  
  param start
  caption = "Starting point"
  default = (0,0)
  endparam  
  
  func f
  caption = "First function"
  default = ident()
  endfunc
  
  func fr
  caption = "Real function"
  default = ident()
  endfunc
  
  func fi
  caption = "Imaginary function"
  default = ident()
  endfunc
  
  func fp
  caption = "Post function"
  default = ident()
  endfunc
  
switch:
  
  type = "TwistJulia"
  start = #pixel
  bailout = bailout
  power = power
  f = f
  fr = fr
  fi = fi
  fp = fp

}

TwistJulia {
;By Samuel Monnier, 1999
init:

  z = @fr(real(@f(#pixel))) \
  + (0,1) * @fi(imag(@f(#pixel)))
    
loop:

  z = @fp(z ^ @power + @start)
  
bailout:

  |z| <= @bailout

default:

  title = "Twist the Julia set"
  
  method = multipass
  
  param bailout
  caption = "Bailout"
  default = 4.0
  endparam
  
  param power
  caption = "Power"
  default = 2.0
  endparam
  
  param start
  caption = "Starting point"
  default = (-1.25,0)
  endparam  
  
  func f
  caption = "First function"
  default = ident()
  endfunc
  
  func fr
  caption = "Real function"
  default = ident()
  endfunc
  
  func fi
  caption = "Imaginary function"
  default = ident()
  endfunc
  
  func fp
  caption = "Post function"
  default = ident()
  endfunc

switch:
  
  type = "TwistMand"
  start = #pixel
  bailout = bailout
  power = power
  f = f
  fr = fr
  fi = fi
  fp = fp
}

x/y {
;By Samuel Monnier, 1999
;The Mandelbrot Set with an additional term.
;Taking a big starting point can give interesting results.
init:
  z = #pixel + @start
loop:
  x = real(z)
  y = imag(z)
  zz = y/x + (0,1)*x/y
  z = z^@power - zz^@powerxy + #pixel
bailout:
  |z| <= @bailout
default:
  title = "x/y Mandelbrot"
  center = (0.001, 0.001)
  magn = 1.0000001
    param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param power
    caption = "Power of z"
    default = (2,4)
  endparam
  param powerxy
    caption = "Power of the x/y term"
    default = (0,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e50
  endparam
  
switch:
  
  type = "x/yJul"
  start = #pixel
  bailout = bailout
  power = power
  powerxy = powerxy

}

x/yJul{
;By Samuel Monnier, 1999
;The Julia Set with an additional term.
init:
  z = #pixel + @start
loop:
  x = real(z)
  y = imag(z)
  zz = y/x + (0,1)*x/y
  z = z^@power - zz^@powerxy + @start
bailout:
  |z| <= @bailout
default:
  title = "x/y Julia"
  center = (0.001, 0.001)
  magn = 1.0000001
    param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param power
    caption = "Power of z"
    default = (2,4)
  endparam
  param powerxy
    caption = "Power of the x/y term"
    default = (0,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e50
  endparam
  
switch:
  
  type = "x/y"
  start = #pixel
  bailout = bailout
  power = power
  powerxy = powerxy

}




Pol6Mand {
;By Samuel Monnier, 1999

init:
  z = #pixel + @start
loop:

   z = @a*z^6 + @b*z^5 + @c*z^4 + @d*z^3 + @f*z^2 + @g*z + @h * #pixel
   
bailout:
  |z| <= @bailout
default:
  title = "Polynomial Mandelbrot Set"
  center = (0,0)
  
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param a
    caption = "Factor of z^6"
    default = (0,0)
  endparam
  param b
    caption = "Factor of z^5"
    default = (0,0)
  endparam
  param c
    caption = "Factor of z^4"
    default = (0,0)
  endparam
  param d
    caption = "Factor of z^3"
    default = (0,0)
  endparam
  param f
    caption = "Factor of z^2"
    default = (1,0)
  endparam
  param g
    caption = "Factor of z"
    default = (0,0)
  endparam
  param h
    caption = "Factor of the pixel value"
    default = (1,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e10
  endparam
  
switch:
  
  type = "Pol6Jul"
  start = #pixel
  bailout = bailout
  power = power
  a = a
  b = b
  c = c
  d = d
  f = f
  g = g
  h = h

  
  
}





Pol6Jul {
;By Samuel Monnier, 1999

init:
  z = #pixel
loop:
  
   z = @a*z^6 + @b*z^5 + @c*z^4 + @d*z^3 + @f*z^2 + @g*z + @h * @start
   
bailout:
  |z| <= @bailout
default:
  title = "Polynomial Julia Set"
  center = (0,0)
  
  param start
    caption = "Starting point"
    default = (-1.25,0)
  endparam
  param a
    caption = "Factor of z^6"
    default = (0,0)
  endparam
  param b
    caption = "Factor of z^5"
    default = (0,0)
  endparam
  param c
    caption = "Factor of z^4"
    default = (0,0)
  endparam
  param d
    caption = "Factor of z^3"
    default = (0,0)
  endparam
  param f
    caption = "Factor of z^2"
    default = (1,0)
  endparam
  param g
    caption = "Factor of z"
    default = (0,0)
  endparam
  param h
    caption = "Factor of the start value"
    default = (1,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 4.0
  endparam
  
switch:
  
  type = "Pol6Mand"
  start = #pixel
  bailout = bailout
  power = power
  a = a
  b = b
  c = c
  d = d
  f = f
  g = g
  h = h

}

s1 {
;By Samuel Monnier, 1999
;Once you have found an interesting shape,
;you can use the switch mode to get infinite
;variations on it.
init:
  z = #pixel
loop:
  z = @a * z^@power^#pixel + @b * @seed + @c * z
bailout:
  |z| <= @bailout
default:
  title = "s1"
  periodicity = 0
  method = multipass
  center = (1,0)

  param seed
  caption = "Seed"
  default = (0,0)
  endparam
  
  param bailout
  caption = "bailout"
  default = 1e20
  endparam
  
  param power
  caption = "power"
  default = (2,0)
  endparam

  param a
  caption = "z^power Coeff."
  default = (1,0)
  endparam

  param b
  caption = "Seed Coeff."
  default = (1,0)
  endparam

  param c
  caption = "z Coeff."
  default = (1,0)
  endparam

switch:
  
  type = "s2"
  seed = #pixel
  bailout = bailout
  power = power
  a = a
  b = b
  c = c
}

s2 {
;By Samuel Monnier, 1999
;It's easier to get interesing shapes with s1
init:
  z = #pixel
loop:
  z = @a * z^@power^@seed + @b * #pixel + @c * z
bailout:
  |z| <= @bailout
default:
  title = "s2"
  periodicity = 0
  method = multipass

  param seed
  caption = "Seed"
  default = (0,0)
  endparam
  
  param bailout
  caption = "bailout"
  default = 1e20
  endparam
  
  param power
  caption = "power"
  default = (2,0)
  endparam

  param a
  caption = "z^power Coeff."
  default = (1,0)
  endparam

  param b
  caption = "Seed Coeff."
  default = (1,0)
  endparam

  param c
  caption = "z Coeff."
  default = (1,0)
  endparam

switch:
  
  type = "s1"
  seed = #pixel
  bailout = bailout
  power = power
  a = a
  b = b
  c = c
}

3prevmand {
;By Samuel Monnier, 1999
init:
  z = @start
  z1 = 0
  z2 = 0
  z3 = 0
loop:
  z3 = z
  z = @a * z^@power + @b * @f1((z1 * @f2(z2))) + @f3(#pixel) 
  z1 = z
  z = @a * z^@power + @b * @f1((z2 * @f2(z3))) + @f3(#pixel) 
  z2 = z
  z = @a * z^@power + @b * @f1((z3 * @f2(z1))) + @f3(#pixel)
bailout:
  |z| <= @bailout
default:
  title = "3prevmand"
  center = (-0.5, 0)
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e20
    min = 1.0
  endparam
  param a
    caption = "1st coeff."
    default = (1,0)
  endparam
  param b
    caption = "2nd coeff."
    default = (1,0)
  endparam
  func f1
    caption = "Function 1"
    default = ident()
  endfunc  
  func f2
    caption = "Function 2"
    default = ident()
  endfunc
  func f3
    caption = "Function 3"
    default = ident()
  endfunc 
switch:
  type = "3prevjul"
  start = #pixel
  power = power
  bailout = bailout
  a=a
  b=b
  f1=f1
  f2=f2
  f3=f3
}


3prevjul {
;By Samuel Monnier, 1999
init:
  z = #pixel
  z1 = 0
  z2 = 0
  z3 = 0
loop:
  z3 = z
  z = @a * z^@power + @b * @f1((z1 * @f2(z2))) + @f3(@start) 
  z1 = z
  z = @a * z^@power + @b * @f1((z2 * @f2(z3))) + @f3(@start) 
  z2 = z
  z = @a * z^@power + @b * @f1((z3 * @f2(z1))) + @f3(@start)
bailout:
  |z| <= @bailout
default:
  title = "3prevjul"
  center = (-0.5, 0)
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e20
    min = 1.0
  endparam
  param a
    caption = "1st coeff."
    default = (1,0)
  endparam
  param b
    caption = "2nd coeff."
    default = (1,0)
  endparam
  func f1
    caption = "Function 1"
    default = ident()
  endfunc  
  func f2
    caption = "Function 2"
    default = ident()
  endfunc
  func f3
    caption = "Function 3"
    default = ident()
  endfunc 
}

MartSam1 {
;By Samuel Monnier, 1999
;Inspired from the Martin formula (by
;Mark Townsend).
;Use inside colouring. 
;By decreasing the number of iteration, 
;you will get a smoother image.
init:
  z = #pixel
  x = real(z)
  y = imag(z)
  x1 = @fr1(x)
  y1 = @fi1(y)
  if @ab1
    a1 = @a/sqrt(|@a|) * @c
    b1 = @b/sqrt(|@b|) * @c
  else 
    a1 = @a
    b1 = @b  
  endif
loop:
  if @mode == 0
    x = real(a1) * sin(x+y) + imag(a1) * cos(x-y) +  x1
    y = real(b1) * cos(x-y) + imag(b1) * sin(x+y) +  y1
  elseif @mode == 1
    x = real(a1) * sin(x+y) + imag(a1) * cos(x-y) +  y1
    y = real(b1) * cos(x-y) + imag(b1) * sin(x+y) +  x1
  elseif @mode == 2
    x = real(a1) * sin(x+y) + imag(a1) * cos(x-y) +  x1 + y1
    y = real(b1) * cos(x-y) + imag(b1) * sin(x+y) +  x1 - y1
  else
    x = real(a1) * sin(x+y) + imag(a1) * cos(x-y) +  x1 + y
    y = real(b1) * cos(x-y) + imag(b1) * sin(x+y) +  y1 - x
  endif
  z = x + flip(y)
bailout:
  true
default:
  title = "MartSam 1"
  helpfile = "sam-help\martsam.htm"
  maxiter = 5
  magn = .2
  
  param mode
    caption = "Mode"
    default = 0
    enum = "x1 ; y1" "y1 ; x1" "x1 + y1 ; x1 - y1" \
    "x1 + y ; y1 - x"
  endparam
  param a
    caption = "a" 
    default = (1,-1)
  endparam
  param b
    caption = "b"
    default = (1,1)
  endparam
  param c
    caption = "c"
    default = 1.0
  endparam
  param ab1
    caption = "|a| = |b| = c ?"
    default = false
    hint = "Useful to get images of the same \
     complexity. Choose a nice c value and \
     play with a and b."
  endparam   
  func fr1
    caption = "Real Func 1"
    default = ident()
  endfunc  
  func fi1
    caption = "Imag Func 1"
    default = ident()
  endfunc
}


MartSam2 {
;By Samuel Monnier, 1999
;Inspired from the Martin formula (by
;Mark Townsend).
;Use inside colouring. 
;Modifying the iteration number will change
;the image.
;With this one, you will get better result
;if you set a slow increasing transfer
;function like cubereoot or Atan..
init:
  z = #pixel
  x = real(z)
  y = imag(z)
  x1 = @fr1(x)
  y1 = @fi1(y)
  if @ab1
    a1 = @a/sqrt(|@a|) * @c
    b1 = @b/sqrt(|@b|) * @c
  else 
    a1 = @a
    b1 = @b  
  endif
loop:
  if @mode == 0
    x = real(a1) * sin(x) - imag(a1) * cos(x) * y +  x1
    y = real(b1) * sin(y) - imag(b1) * cos(y) * x +  y1
  elseif @mode == 1
    x = real(a1) * sin(x) - imag(a1) * cos(x) * y +  y1
    y = real(b1) * sin(y) - imag(b1) * cos(y) * x +  x1
  elseif @mode == 2
    x = real(a1) * sin(x) - imag(a1) * cos(x) * y +  x1 + y1
    y = real(b1) * sin(y) - imag(b1) * cos(y) * x +  x1 - y1
  else
    x = real(a1) * sin(x) - imag(a1) * cos(x) * y +  x1 + y
    y = real(b1) * sin(y) - imag(b1) * cos(y) * x +  y1 - x
  endif
  z = x + flip(y)
bailout:
  true
default:
  title = "MartSam 2"
  helpfile = "sam-help\martsam.htm"
  maxiter = 3
  magn = .05
  
  param mode
    caption = "Mode"
    default = 0
    enum = "x1 ; y1" "y1 ; x1" "x1 + y1 ; x1 - y1" \
    "x1 + y ; y1 - x"
  endparam
  param a
    caption = "a" 
    default = (1,.5)
  endparam
  param b
    caption = "b"
    default = (1,.5)
  endparam
  param c
    caption = "c"
    default = 1.0
  endparam
  param ab1
    caption = "|a| = |b| = c ?"
    default = false
    hint = "Useful to get images of the same \
     complexity. Choose a nice c value and \
     play with a and b."
  endparam   
  func fr1
    caption = "Real Func 1"
    default = ident()
  endfunc  
  func fi1
    caption = "Imag Func 1"
    default = ident()
  endfunc
}


MartSam3 {
;By Samuel Monnier, 1999
;Inspired from the Martin formula (by
;Mark Townsend).
;Use inside colouring. 
;A strange formula, as it uses only
;one iteration. But as I found it
;rather nice, I decided to release
;it.

init:
  z = #pixel
  x = real(z)
  y = imag(z)
  x1 = @fr1(x)
  y1 = @fi1(y)
  if @ab1
    a1 = @a/sqrt(|@a|) * @c
    b1 = @b/sqrt(|@b|) * @c
  else 
    a1 = @a
    b1 = @b  
  endif
loop:
  if @mode == 0
    x = real(a1) * tan(y - x) - imag(a1) * cos(y) * x + x1
    y = real(b1) * tan(x - y) + imag(b1) * sin(x) * y + y1
  elseif @mode == 1
    x = real(a1) * tan(y - x) - imag(a1) * cos(y) * x + y1
    y = real(b1) * tan(x - y) + imag(b1) * sin(x) * y +  x1
  elseif @mode == 2
    x = real(a1) * tan(y - x) - imag(a1) * cos(y) * x + x1 + y1
    y = real(b1) * tan(x - y) + imag(b1) * sin(x) * y +  x1 - y1
  else
    x = real(a1) * tan(y - x) - imag(a1) * cos(y) * x + x1 + y
    y = real(b1) * tan(x - y) + imag(b1) * sin(x) * y +  y1 - x
  endif
  z = x + flip(y)
bailout:
  true
default:
  title = "MartSam 3"
  helpfile = "sam-help\martsam.htm"
  maxiter = 1
  magn = .2  
  param mode
    caption = "Mode"
    default = 0
    enum = "x1 ; y1" "y1 ; x1" "x1 + y1 ; x1 - y1" \
    "x1 + y ; y1 - x"
  endparam
  param a
    caption = "a" 
    default = (1,.5)
  endparam
  param b
    caption = "b"
    default = (1,.5)
  endparam
  param c
    caption = "c"
    default = 1.0
  endparam
  param ab1
    caption = "|a| = |b| = c ?"
    default = false
    hint = "Useful to get images of the same \
     complexity. Choose a nice c value and \
     play with a and b."
  endparam   
  func fr1
    caption = "Real Func 1"
    default = ident()
  endfunc  
  func fi1
    caption = "Imag Func 1"
    default = ident()
  endfunc
}

MartSam4 {
;By Samuel Monnier, 1999
;Inspired from the Martin formula (by
;Mark Townsend).
;Use inside colouring. 
;Modifying the iteration number will change
;the image.
;With this one, you will get better result
;if you set a slow increasing transfer
;function like cubereoot or Atan.
init:
  z = #pixel 
  x = real(z) + real(@start)
  y = imag(z) + imag(@start)
  x1 = @fr1(real(z))
  y1 = @fi1(imag(z))
  if @ab1
    a1 = @a/sqrt(|@a|) * @c
    b1 = @b/sqrt(|@b|) * @c
  else 
    a1 = @a
    b1 = @b  
  endif
loop:
  if @mode == 0
    x =  real(a1) * sin(x - x1) + imag(a1) * y1/x
    y =  real(b1) * sin(y - y1) + imag(b1) * y/x1
  elseif @mode == 1
    x =  real(a1) * sin(x - x1) + imag(a1) * y1/x1
    y =  real(b1) * sin(y - y1) + imag(b1) * y/x
  elseif @mode == 2
    x =  real(a1) * sin(x - x1) + imag(a1) * y1/y
    y =  real(b1) * sin(y - y1) + imag(b1) * x1/x
  elseif @mode == 3
    x =  real(a1) * sin(x - x1) + imag(a1) * y1/y
    y =  real(b1) * sin(y - y1) + imag(b1) * x/x1
  elseif @mode == 4
    x =  real(a1) * sin(x - x1) + imag(a1) * x/x1
    y =  real(b1) * sin(y - y1) + imag(b1) * y/y1
  elseif @mode == 5
    x =  real(a1) * sin(x - x1) + imag(a1) * x1/x
    y =  real(b1) * sin(y - y1) + imag(b1) * y1/y
  elseif @mode == 6
    x =  real(a1) * sin(x - x1) + imag(a1) * x1/y
    y =  real(b1) * sin(y - y1) + imag(b1) * y1/x
  elseif @mode == 7
    x =  real(a1) * sin(x - x1) + imag(a1) * y/x1
    y =  real(b1) * sin(y - y1) + imag(b1) * x/y1
  else
    x =  real(a1) * sin(x - x1) + imag(a1) * y/y1
    y =  real(b1) * sin(y - y1) + imag(b1) * x/x1
  endif
  z = x + flip(y)
    
bailout:
  true
default:
  title = "MartSam 4"
  helpfile = "sam-help\martsam.htm"
  maxiter = 3
  magn = .2
  param mode
    caption = "Mode"
    default = 0
    enum = "y1/x ; y/x1" "y1/x1 ; x/y" "y1/y ; x1/x"  \ 
    "y1/y ; x/x1" "x/x1 ; y/y1" "x1/x ; y1/y" \
    "x1/y ; y1/x" "y/x1 ; x/y1" "y/y1 ; x/x1" 
  endparam
  param start
    caption = "Starting Value"
    default = (1,.5)
  endparam
  param a
    caption = "a"
    default = (1,.5)
  endparam
  param b
    caption = "b"
    default = (1,.5)
  endparam
  param c
    caption = "c"
    default = 1.0
  endparam
  param ab1
    caption = "|a| = |b| = c ?"
    default = false
    hint = "Useful to get images of the same \
     complexity. Choose a nice c value and \
     play with a and b."
  endparam 
  func fr1
    caption = "Real Func 1"
    default = ident()
  endfunc  
  func fi1
    caption = "Imag Func 1"
    default = ident()
  endfunc
}


MartSam5 {
;By Samuel Monnier, 1999
;Inspired from the Martin formula (by
;Mark Townsend).
;Use inside colouring. 
;Modifying the iteration number will change
;the image.
init:
  z = #pixel
  x = real(z)
  y = imag(z)
  x1 = @fr1(x)
  y1 = @fi1(y)
  if @ab1
    a1 = @a/sqrt(|@a|) * @c
    b1 = @b/sqrt(|@b|) * @c
  else 
    a1 = @a
    b1 = @b  
  endif
loop:
  if @mode == 0
    x = real(a1) * sin(x) + imag(a1) * y + x1
    y = real(b1) * cos(y) + imag(b1) * x + y1
  elseif @mode == 1
    x = real(a1) * sin(x) + imag(a1) * y + y1
    y = real(b1) * cos(y) + imag(b1) * x + x1
  elseif @mode == 2
    x = real(a1) * sin(x) + imag(a1) * y + x1 + y1
    y = real(b1) * cos(y) + imag(b1) * x + x1 - y1
  else
    x = real(a1) * sin(x) + imag(a1) * y + x1 + y
    y = real(b1) * cos(y) + imag(b1) * x + y1 - x
  endif
  z = x + flip(y)
bailout:
  true
default:
  title = "MartSam 5"
  helpfile = "sam-help\martsam.htm"
  maxiter = 6
  magn = .2  
  param mode
    caption = "Mode"
    default = 0
    enum = "x1 ; y1" "y1 ; x1" "x1 + y1 ; x1 - y1" \
    "x1 + y ; y1 - x"
  endparam
  param a
    caption = "a" 
    default = (1,1)
  endparam
  param b
    caption = "b"
    default = (1,-1)
  endparam
  param c
    caption = "c"
    default = 1.0
  endparam
  param ab1
    caption = "|a| = |b| = c ?"
    default = false
    hint = "Useful to get images of the same \
     complexity. Choose a nice c value and \
     play with a and b."
  endparam   
  func fr1
    caption = "Real Func 1"
    default = ident()
  endfunc  
  func fi1
    caption = "Imag Func 1"
    default = ident()
  endfunc
}


MartSam6 {
;By Samuel Monnier, 1999
;Inspired from the Martin formula (by
;Mark Townsend).
;Use inside colouring. 
;By decreasing the number of iteration, 
;you will get a smoother image.
init:
  z = #pixel
  x = real(z)
  y = imag(z)
  x1 = @fr1(x)
  y1 = @fi1(y)
  if @ab1
    a1 = @a/sqrt(|@a|) * @c
    b1 = @b/sqrt(|@b|) * @c
  else 
    a1 = @a
    b1 = @b  
  endif
loop:
  if @mode == 0
    x = real(a1) * sin(x+y1) + imag(a1) * cos(x-y1) +  x
    y = real(b1) * cos(x1-y) + imag(b1) * sin(x1+y) +  y
  elseif @mode == 1
    x = real(a1) * sin(x+y1) + imag(a1) * cos(x-y1) +  y
    y = real(b1) * cos(x1-y) + imag(b1) * sin(x1+y) +  x
  elseif @mode == 2
    x = real(a1) * sin(x+y1) + imag(a1) * cos(x-y1) +  x + y
    y = real(b1) * cos(x1-y) + imag(b1) * sin(x1+y) +  x - y
  else
    x = real(a1) * sin(x+y1) + imag(a1) * cos(x-y1) +  x1 + y
    y = real(b1) * cos(x1-y) + imag(b1) * sin(x1+y) +  y1 - x
  endif
  z = x + flip(y)
bailout:
  true
default:
  title = "MartSam 6"
  helpfile = "sam-help\martsam.htm"
  maxiter = 5
  magn = .2
  
  param mode
    caption = "Mode"
    default = 0
    enum = "x ; y" "y ; x" "x + y ; x - y" \
    "x1 + y ; y1 - x"
  endparam
  param a
    caption = "a" 
    default = (2,-2)
  endparam
  param b
    caption = "b"
    default = (2,2)
  endparam
  param c
    caption = "c"
    default = 1.0
  endparam
  param ab1
    caption = "|a| = |b| = c ?"
    default = false
    hint = "Useful to get images of the same \
     complexity. Choose a nice c value and \
     play with a and b."
  endparam   
  func fr1
    caption = "Real Func 1"
    default = ident()
  endfunc  
  func fi1
    caption = "Imag Func 1"
    default = ident()
  endfunc
}


MartSam7 {
;By Samuel Monnier, 1999
;Inspired from the Martin formula (by
;Mark Townsend).
;Use inside colouring. 
;By decreasing the number of iteration, 
;you will get a smoother image.
init:
  z = #pixel
  x = real(z)
  y = imag(z)
  x1 = @fr1(x)
  y1 = @fi1(y)
  if @ab1
    a1 = @a/sqrt(|@a|) * @c
    b1 = @b/sqrt(|@b|) * @c
  else 
    a1 = @a
    b1 = @b  
  endif
loop:
  if @mode == 0
    x = sin(real(a1) * x+y) + cos(imag(a1) * y-x) +  x1
    y = cos(real(b1) * y-x) + sin(imag(b1) * x+y) +  y1
  elseif @mode == 1
    x = sin(real(a1) * x+y) + cos(imag(a1) * y-x) +  y1
    y = cos(real(b1) * y-x) + sin(imag(b1) * x+y) +  x1
  elseif @mode == 2
    x = sin(real(a1) * x+y) + cos(imag(a1) * y-x) +  x1 + y1
    y = cos(real(b1) * y-x) + sin(imag(b1) * x+y) +  x1 - y1
  else
    x = sin(real(a1) * x+y) + cos(imag(a1) * y-x) +  x1 + y
    y = cos(real(b1) * y-x) + sin(imag(b1) * x+y) +  y1 - x
  endif
  z = x + flip(y)
bailout:
  true
default:
  title = "MartSam 7"
  helpfile = "sam-help\martsam.htm"
  maxiter = 5
  magn = .2
  
  param mode
    caption = "Mode"
    default = 0
    enum = "x1 ; y1" "y1 ; x1" "x1 + y1 ; x1 - y1" \
    "x1 + y ; y1 - x"
  endparam
  param a
    caption = "a" 
    default = (1,-1)
  endparam
  param b
    caption = "b"
    default = (1,1)
  endparam
  param c
    caption = "c"
    default = 1.0
  endparam
  param ab1
    caption = "|a| = |b| = c ?"
    default = false
    hint = "Useful to get images of the same \
     complexity. Choose a nice c value and \
     play with a and b."
  endparam   
  func fr1
    caption = "Real Func 1"
    default = ident()
  endfunc  
  func fi1
    caption = "Imag Func 1"
    default = ident()
  endfunc
}



MartSam8 {
;By Samuel Monnier, 1999
;Inspired from the Martin formula (by
;Mark Townsend).
;Use inside colouring. 
;By decreasing the number of iteration, 
;you will get a smoother image.
init:
  z = #pixel
  x = real(z)
  y = imag(z)
  x1 = @fr1(x)
  y1 = @fi1(y)
  if @ab1
    a1 = @a/sqrt(|@a|) * @c
    b1 = @b/sqrt(|@b|) * @c
  else 
    a1 = @a
    b1 = @b  
  endif
loop:
  if @mode == 0
    x = real(a1) * sin(imag(a1) * y) +  x1
    y = real(b1) * sin(imag(b1) * x) +  y1
  elseif @mode == 1
    x = real(a1) * sin(imag(a1) * y) +  y1
    y = real(b1) * sin(imag(b1) * x) +  x1
  elseif @mode == 2
    x = real(a1) * sin(imag(a1) * y) +  x1 + y1
    y = real(b1) * sin(imag(b1) * x) +  x1 - y1
  else
    x = real(a1) * sin(imag(a1) * y) +  x1 + y
    y = real(b1) * sin(imag(b1) * x) +  y1 - x
  endif
  z = x + flip(y)
bailout:
  true
default:
  title = "MartSam 8"
  helpfile = "sam-help\martsam.htm"
  maxiter = 5
  magn = .2
  
  param mode
    caption = "Mode"
    default = 0
    enum = "x1 ; y1" "y1 ; x1" "x1 + y1 ; x1 - y1" \
    "x1 + y ; y1 - x"
  endparam
  param a
    caption = "a" 
    default = (2,-1)
  endparam
  param b
    caption = "b"
    default = (2,1)
  endparam
  param c
    caption = "c"
    default = 1.0
  endparam
  param ab1
    caption = "|a| = |b| = c ?"
    default = false
    hint = "Useful to get images of the same \
     complexity. Choose a nice c value and \
     play with a and b."
  endparam   
  func fr1
    caption = "Real Func 1"
    default = ident()
  endfunc  
  func fi1
    caption = "Imag Func 1"
    default = ident()
  endfunc
}

MartSam9 {
;By Samuel Monnier, 1999
;Inspired from the Martin formula (by
;Mark Townsend).
;Use inside colouring. 
;By decreasing the number of iteration, 
;you will get a smoother image.
init:
  z = #pixel
  x = real(z)
  y = imag(z)
  x1 = @fr1(x)
  y1 = @fi1(y)
  if @ab1
    a1 = @a/sqrt(|@a|) * @c
    b1 = @b/sqrt(|@b|) * @c
  else 
    a1 = @a
    b1 = @b  
  endif
loop:
  if @mode == 0
    x = real(a1) * sin(imag(a1) * x) +  x1
    y = real(b1) * sin(imag(b1) * y) +  y1
  elseif @mode == 1
    x = real(a1) * sin(imag(a1) * x) +  y1
    y = real(b1) * sin(imag(b1) * y) +  x1
  elseif @mode == 2
    x = real(a1) * sin(imag(a1) * x) +  x1 + y1
    y = real(b1) * sin(imag(b1) * y) +  x1 - y1
  else
    x = real(a1) * sin(imag(a1) * x) +  x1 + y
    y = real(b1) * sin(imag(b1) * y) +  y1 - x
  endif
  z = x + flip(y)
bailout:
  true
default:
  title = "MartSam 9"
  helpfile = "sam-help\martsam.htm"
  maxiter = 5
  magn = .2
  
  param mode
    caption = "Mode"
    default = 0
    enum = "x1 ; y1" "y1 ; x1" "x1 + y1 ; x1 - y1" \
    "x1 + y ; y1 - x"
  endparam
  param a
    caption = "a" 
    default = (2,-1)
  endparam
  param b
    caption = "b"
    default = (2,1)
  endparam
  param c
    caption = "c"
    default = 1.0
  endparam
  param ab1
    caption = "|a| = |b| = c ?"
    default = false
    hint = "Useful to get images of the same \
     complexity. Choose a nice c value and \
     play with a and b."
  endparam   
  func fr1
    caption = "Real Func 1"
    default = ident()
  endfunc  
  func fi1
    caption = "Imag Func 1"
    default = ident()
  endfunc
}




MartSam10 {
;By Samuel Monnier, 1999
;Inspired from the Martin formula (by
;Mark Townsend).
;Use inside colouring. 
;By decreasing the number of iteration, 
;you will get a smoother image.
init:
  z = #pixel
  x = real(z)
  y = imag(z)
  x1 = @fr1(x)
  y1 = @fi1(y)
  if @ab1
    a1 = @a/sqrt(|@a|) * @c
    b1 = @b/sqrt(|@b|) * @c
  else 
    a1 = @a
    b1 = @b  
  endif
loop:
  if @mode == 0
    x = real(a1) * (sin(x) - cos(y)) + imag(a1) * (cos(x - y)) + x1
    y = real(b1) * (sin(y) - cos(x)) + imag(b1) * (sin(y - x)) + y1
  elseif @mode == 1
    x = real(a1) * (sin(x) - cos(y)) + imag(a1) * (cos(x - y)) +  y1
    y = real(b1) * (sin(y) - cos(x)) + imag(b1) * (sin(y - x)) +  x1
  elseif @mode == 2
    x = real(a1) * (sin(x) - cos(y)) + imag(a1) * (cos(x - y)) +  x1 + y1
    y = real(b1) * (sin(y) - cos(x)) + imag(b1) * (sin(y - x)) +  x1 - y1
  else
    x = real(a1) * (sin(x) - cos(y)) + imag(a1) * (cos(x - y)) +  x1 + y
    y = real(b1) * (sin(y) - cos(x)) + imag(b1) * (sin(y - x)) +  y1 - x
  endif
  z = x + flip(y)
bailout:
  true
default:
  title = "MartSam 10"
  helpfile = "sam-help\martsam.htm"
  maxiter = 5
  magn = .2
  
  param mode
    caption = "Mode"
    default = 0
    enum = "x1 ; y1" "y1 ; x1" "x1 + y1 ; x1 - y1" \
    "x1 + y ; y1 - x"
  endparam
  param a
    caption = "a" 
    default = (2,-1)
  endparam
  param b
    caption = "b"
    default = (2,1)
  endparam
  param c
    caption = "c"
    default = 1.0
  endparam
  param ab1
    caption = "|a| = |b| = c ?"
    default = false
    hint = "Useful to get images of the same \
     complexity. Choose a nice c value and \
     play with a and b."
  endparam   
  func fr1
    caption = "Real Func 1"
    default = ident()
  endfunc  
  func fi1
    caption = "Imag Func 1"
    default = ident()
  endfunc
}


MartSam11 {
;By Samuel Monnier, 1999
;Inspired from the Martin formula (by
;Mark Townsend).
;Use inside colouring. 
;By decreasing the number of iteration, 
;you will get a smoother image.
init:
  z = #pixel
  x = real(z)
  y = imag(z)
  x1 = @fr1(x)
  y1 = @fi1(y)
  if @ab1
    a1 = @a/sqrt(|@a|) * @c
    b1 = @b/sqrt(|@b|) * @c
  else 
    a1 = @a
    b1 = @b  
  endif
loop:
  if @mode == 0
    x = sin(real(a1) * x + imag(a1) * x1) + x1
    y = cos(real(b1) * y + imag(b1) * y1) + y1
  elseif @mode == 1
    x = sin(real(a1) * x + imag(a1) * x1) +  y1
    y = cos(real(b1) * y + imag(b1) * y1) +  x1
  elseif @mode == 2
    x = sin(real(a1) * x + imag(a1) * x1) +  x1 + y1
    y = cos(real(b1) * y + imag(b1) * y1) +  x1 - y1
  else
    x = sin(real(a1) * x + imag(a1) * x1) +  x1 + y
    y = cos(real(b1) * y + imag(b1) * y1) +  y1 - x
  endif
  z = x + flip(y)
bailout:
  true
default:
  title = "MartSam 11"
  helpfile = "sam-help\martsam.htm"
  maxiter = 5
  magn = .2
  
  param mode
    caption = "Mode"
    default = 0
    enum = "x1 ; y1" "y1 ; x1" "x1 + y1 ; x1 - y1" \
    "x1 + y ; y1 - x"
  endparam
  param a
    caption = "a" 
    default = (2,-1)
  endparam
  param b
    caption = "b"
    default = (2,1)
  endparam
  param c
    caption = "c"
    default = 1.0
  endparam
  param ab1
    caption = "|a| = |b| = c ?"
    default = false
    hint = "Useful to get images of the same \
     complexity. Choose a nice c value and \
     play with a and b."
  endparam   
  func fr1
    caption = "Real Func 1"
    default = ident()
  endfunc  
  func fi1
    caption = "Imag Func 1"
    default = ident()
  endfunc
}

CMandelbrot {
; By Samuel Monnier, 1999
init:
  z = @start
loop:
  if @f1 == 0
  z = z^(@power - 1) * (round(@res * z) / @res) + #pixel
  elseif @f1 == 1
  z = z^(@power - 1) * (trunc(@res * z) / @res) + #pixel
  elseif @f1 == 2
  z = z^(@power - 1) * (floor(@res * z) / @res) + #pixel
  elseif @f1 == 3
  z = z^(@power - 1) * (ceil(@res * z) / @res) + #pixel
  elseif @f1 == 4
  z = z^@power + #pixel
  endif
bailout:
  |z| <= @bailout
default:
  title = "Cubist Mandelbrot"
  helpfile = "sam-help/various.htm"
  helptopic = "cubist"
  center = (-0.5, 0)
  param f1
    caption = "Function"
    enum = "round()" "trunc()" "floor()" "ceil()" "none"
    default = 2
  endparam
  param start
    caption = "Starting point"
    default = (0,0)
    hint = "Perturbation. Use (0,0) for the standard Mandelbrot set."
  endparam
  param power
    caption = "Power"
    default = 2.0
  endparam
  param res
    caption = "Resolution"
    default = (10,0)
    hint = "The more you zoom the greater it should be. \
            Adding an imaginary part will rotate the squares"
  endparam
  param bailout
    caption = "Bailout value"
    default = 4.0
    min = 1.0
    hint = "Defines how soon an orbit bails out, i.e. doesn't belong \
            to the Mandelbrot set anymore."
  endparam
  switch:
  type = "CJulia"
  start = #pixel
  f1 = f1
  power = power
  res = res
  bailout = bailout

}

CJulia {
; By Samuel Monnier, 1999
init:
  z = #pixel
loop:
  if @f1 == 0
  z = z^(@power - 1) * (round(@res * z) / @res) + @start
  elseif @f1 == 1
  z = z^(@power - 1) * (trunc(@res * z) / @res) + @start
  elseif @f1 == 2
  z = z^(@power - 1) * (floor(@res * z) / @res) + @start
  elseif @f1 == 3
  z = z^(@power - 1) * (ceil(@res * z) / @res) + @start
  elseif @f1 == 4
  z = z^@power + @start
  endif
bailout:
  |z| <= @bailout
default:
  title = "Cubist Julia"
  helpfile = "sam-help/various.htm"
  helptopic = "cubist"
  param f1
    caption = "Function"
    enum = "round()" "trunc()" "floor()" "ceil()" "none"
    default = 2
  endparam
  param start
    caption = "Starting point"
    default = (-1.25,0)
  endparam
  param power
    caption = "Power"
    default = 2.0
  endparam
  param res
    caption = "Resolution"
    default = (10,0)
    hint = "The more you zoom the greater it should be. \
            Adding an imaginary part will rotate the squares"
  endparam
  param bailout
    caption = "Bailout value"
    default = 4.0
    min = 1.0
    hint = "Defines how soon an orbit bails out, i.e. doesn't belong \
            to the Mandelbrot set anymore."
  endparam
  switch:
  type = "Cmandelbrot"
  start = #pixel
  f1 = f1
  power = power
  res = res
  bailout = bailout

}



MartSam12 {
;By Samuel Monnier, 1999
;Inspired from the Martin formula (by
;Mark Townsend).
;Use inside colouring. 
;By decreasing the number of iteration, 
;you will get a smoother image.
init:
  z = #pixel
  x = real(z)
  y = imag(z)
  px = 0
  py = 0
  x1 = @fr1(x)
  y1 = @fi1(y)
  if @ab1
    a1 = @a/sqrt(|@a|) * @c
    b1 = @b/sqrt(|@b|) * @c
  else 
    a1 = @a
    b1 = @b  
  endif
loop:
  if @mode == 0
    px = x
    x = x - real(a1) * sin(imag(a1) * py + x1)
    py = y
    y = y - real(b1) * sin(imag(b1) * px + y1)
  elseif @mode == 1
    px = x
    x = x - real(a1) * sin(imag(a1) * py + y1)
    py = y
    y = y - real(b1) * sin(imag(b1) * px + x1)
  elseif @mode == 2
    px = x
    x = x - real(a1) * sin(imag(a1) * py + x1 + y1)
    py = y
    y = y - real(b1) * sin(imag(b1) * px + x1 - y1)
  else
    px = x
    x = x - real(a1) * sin(imag(a1) * py + x1 + y)
    py = y
    y = y - real(b1) * sin(imag(b1) * px + y1 - x)
  endif
  z = x + flip(y)
bailout:
  true
default:
  title = "MartSam 12"
  helpfile = "sam-help\martsam.htm"
  maxiter = 5
  magn = .2
  
  param mode
    caption = "Mode"
    default = 0
    enum = "x1 ; y1" "y1 ; x1" "x1 + y1 ; x1 - y1" \
    "x1 + y ; y1 - x"
  endparam
  param a
    caption = "a" 
    default = (2,-1)
  endparam
  param b
    caption = "b"
    default = (2,1)
  endparam
  param c
    caption = "c"
    default = 1.0
  endparam
  param ab1
    caption = "|a| = |b| = c ?"
    default = false
    hint = "Useful to get images of the same \
     complexity. Choose a nice c value and \
     play with a and b."
  endparam   
  func fr1
    caption = "Real Func 1"
    default = ident()
  endfunc  
  func fi1
    caption = "Imag Func 1"
    default = ident()
  endfunc
}

sierpinskimod {
; Written by Luke Plant
; Modified by Frederik Slijkerman
; Modified by Samuel Monnier 
; (Twist functions added)
init:
  complex z = #pixel
loop:
  IF (imag(z)>0.5)
    z = @f1(2*real(z) + flip(2*imag(z)-1)) 
  ELSEIF (real(z)>0.5)
    z = @f2(2*real(z)-1 + flip(2*imag(z)))
  ELSE
    z = @f3(2*real(z) + flip(2*imag(z))) 
  ENDIF

bailout:
  |z| < @bailout

default:
  title = "Twisted Sierpinksi Triangle"
  center = (0.4, 0.4)
  magn = 1.1538
  maxiter = 149
  method = multipass
  periodicity = 0
  param bailout
    caption = "Bailout value"
    default = 127
    min = 1
  endparam
  func f1 
    caption = "Function 1"
    default = ident()
  endfunc
  func f2 
    caption = "Function 2"
    default = ident()
  endfunc
  func f3 
    caption = "Function 3"
    default = ident()
  endfunc
}

Jul^2 {
; By Samuel Monnier, 1999
init:
  z = #pixel
  i = @p1
loop:
  i = i * @p1 + @p2
  z = z ^ @power * i + @start
bailout:
  |z| <= @bailout
default:
  title = "Julia ^ 2"
  helpfile = "sam-help/various.htm"
  helptopic = "jm^2"
  maxiter = 5000
  periodicity = 0
  method = multipass
  param start
    caption = "Starting point"
    default = (-0.132,-0.434)
  endparam
  param p1
    caption = "p1"
    default = (-0.785,.622)
  endparam
  param p2
    caption = "p2"
    default = (0.9,1.2)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 4.0
    min = 1.0
    hint = "Defines how soon an orbit bails out, i.e. doesn't belong \
            to the Mandelbrot set anymore."
  endparam
}

Mand^2 {
; By Samuel Monnier, 1999
init:
  z = @start
  i = @p1
loop:
  i = i * @p1 + @p2
  z = z ^ @power * i + #pixel
bailout:
  |z| <= @bailout
default:
  title = "Mandelbrot ^ 2"
  helpfile = "sam-help/various.htm"
  helptopic = "jm^2"
  maxiter = 5000
  periodicity = 0
  method = multipass
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param p1
    caption = "p1"
    default = (-.45,.925)
  endparam
  param p2
    caption = "p2"
    default = (0.8,1.4)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e20
    min = 1.0
    hint = "Defines how soon an orbit bails out, i.e. doesn't belong \
            to the Mandelbrot set anymore."
  endparam
switch:
  type = "Jul^2"
  start = #pixel
  power = power
  p1 = p1
  p2 = p2
  bailout = bailout
}

Tubem {
; By Samuel Monnier, 1999
init:
  z = @start
loop:
  z = z * @p + #pixel
bailout:
  |z| <= @bailout
default:
  title = "Tube M"
  center = (-0.5, 0)
  param start
    caption = "Starting point"
    default = (0,-.8)
  endparam
  param bailout
    caption = "Bailout value"
    default = 4.0
    min = 1.0
    hint = "Defines how soon an orbit bails out, i.e. doesn't belong \
            to the Mandelbrot set anymore."
  endparam
  param p
    caption = "p"
    default = (1,.5)
  endparam  
switch:
  type = "tubej"
  start = #pixel
  p = p
  bailout = bailout
}

Tubej {
; By Samuel Monnier, 1999
; Use Tube M to switch.
init:
  z = #pixel
loop:
  z = z * @p + @start
bailout:
  |z| <= @bailout
default:
  title = "Tube J"
  center = (-0.5, 0)
  param start
    caption = "Starting point"
    default = (0,-.8)
  endparam
  param bailout
    caption = "Bailout value"
    default = 4.0
    min = 1.0
    hint = "Defines how soon an orbit bails out, i.e. doesn't belong \
            to the Mandelbrot set anymore."
  endparam
  param p
    caption = "p"
    default = (1,.5)
  endparam  
}

lyap {
; By Samuel Monnier, 1999
init:
  z = #pixel
  r = real(z)
  x = .2
  i = 0
loop:
  i = i + 1
  x = r * x * (1 - x)
bailout:
  i < 200 || |x - imag(z)| > @resol
default:
  title = "Logistic"
  center = (2.5, 0.5)
  magn = .8
  maxiter = 250
  periodicity = 0
  method = multipass
  param resol
  caption = "Resolution"
  default = .0001
  endparam
}

DMand {
; By Samuel Monnier, 1999
init:
  z = @start
loop:
  z = @f1(z^@power) + @f2(@power * z ^ (@power - 1)) + #pixel
bailout:
  |z| <= @bailout
default:
  title = "DMandelbrot"
  center = (-0.5, 0)
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 4.0
    min = 1.0
  endparam
  func f1
    caption = "z^n function"
    default = sin()
  endfunc
  func f2
    caption = "z^(n-1) function"
    default = sin()
  endfunc
switch:
  type = "DJul"
  start = #pixel
  power = power
  bailout = bailout
  f1 = f1
  f2 = f2
}


DJul {
; By Samuel Monnier, 1999
init:
  z = #pixel
loop:
  z = @f1(z^@power) + @f2(@power * z ^ (@power - 1)) + @start
bailout:
  |z| <= @bailout
default:
  title = "DJulia"
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 4.0
    min = 1.0
  endparam
  func f1
    caption = "z^n function"
    default = sin()
  endfunc
  func f2
    caption = "z^(n-1) function"
    default = sin()
  endfunc
}

laris1m {
; By Samuel Monnier, 1999
; Inspired by the Barnsley 1 formula
init:
  z = @start
  dpi = @p3 - @p1
  dpo = @p3 - @p2
loop:
  if real(z) < @c
    spi = exp(flip(real(z)*@ispin))
    if @modei == 0
      p = @p1
    elseif @modei == 1
      if @c == 0
        p = - real(z) * dpi + @p3
      else
        p = real(z)/@c*dpi + @p1
      endif
    elseif @modei == 2
      p = dpi * log(abs((real(z)-@c)^2 + 1)) + @p3
    else
      p = dpi * log(abs((real(z)-@c)^2 + 1)) + @p1
    endif
  else
    spi = exp(flip(real(z)*@ospin))
    if @modeo == 0
      p = @p2
    elseif @modeo == 1
      if @c == 0
        p = - real(z) * dpo + @p3
      else
        p = real(z)/@c*dpo + @p2
      endif
    elseif @modeo == 2
      p = dpo * log(abs((real(z)-@c)^2 + 1)) + @p3
    else
      p = dpo * log(abs((real(z)-@c)^2 + 1)) + @p2
    endif
  endif
  p = p*spi
  if @form == 0
    z = (z + p)^@power + #pixel
  elseif @form == 1
    z = z^@power + #pixel + p
  elseif @form == 2
    z = (p*z)^@power + #pixel
  elseif @form == 3
    z = z^@power + p*#pixel
  elseif @form == 4
    z = z^(@power + p) + #pixel
  elseif @form == 5
    z = z^(p*@power) + #pixel
  else
    z = z^p + #pixel
  endif
bailout:
  |z| <= @bailout
default:
  title = "Laris 1 (Mand)"
  helpfile = "sam-help/laris.htm"
  center = (-0.5, 0)
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e20
    min = 1.0
  endparam
  param form
    caption = "Formula type"
    enum = "(z + p)^n + c" "z^n + c + p" "(p*z)^n + c"\
           "z^n + p*c" "z^(n + p) + c" "z^(n*p) + c"\
           "z^p + c"
    default = 0
  endparam
  param modei
    caption = "Inside mode"
    enum = "Raw" "Smooth" "Very Smooth" \
           "Mistake"
    default = 0
  endparam
  param modeo
    caption = "Outside mode"
    enum = "Raw" "Smooth" "Very Smooth" \
           "Mistake"
    default = 0
  endparam
  param ispin
    caption = "Inside Spin"
    default = 0.0
  endparam
  param ospin
    caption = "Outside Spin"
    default = 0.0
  endparam
  param p1
    caption = "Inside parameter"
    default = (1,0)
  endparam
  param p2
    caption = "Outside parameter"
    default = (-1,0)
  endparam
  param p3
    caption = "Middle parameter"
    default = (-1,0)
  endparam
  param c
    caption = "Critical point"
    default = 0.0
  endparam
switch:
  type = "laris1j"
  start= #pixel
  power = power
  bailout = bailout
  form = form
  modei = modei
  modeo = modeo
  ispin = ispin
  ospin = ospin
  c = c
  p1 = p1
  p2 = p2
  p3 = p3
}

laris1j {
; By Samuel Monnier, 1999
; Inspired by the Barnsley 1 formula
init:
  z = #pixel
  dpi = @p3 - @p1
  dpo = @p3 - @p2
loop:
  if real(z) < @c
    spi = exp(flip(real(z)*@ispin))
    if @modei == 0
      p = @p1
    elseif @modei == 1
      if @c == 0
        p = - real(z) * dpi + @p3
      else
        p = real(z)/@c*dpi + @p1
      endif
    elseif @modei == 2
      p = dpi * log(abs((real(z)-@c)^2 + 1)) + @p3
    else
      p = dpi * log(abs((real(z)-@c)^2 + 1)) + @p1
    endif
  else
    spi = exp(flip(real(z)*@ospin))
    if @modeo == 0
      p = @p2
    elseif @modeo == 1
      if @c == 0
        p = - real(z) * dpo + @p3
      else
        p = real(z)/@c*dpo + @p2
      endif
    elseif @modeo == 2
      p = dpo * log(abs((real(z)-@c)^2 + 1)) + @p3
    else
      p = dpo * log(abs((real(z)-@c)^2 + 1)) + @p2
    endif
  endif
  p = p*spi
  if @form == 0
    z = (z + p)^@power + @start
  elseif @form == 1
    z = z^@power + @start + p
  elseif @form == 2
    z = (p*z)^@power + @start
  elseif @form == 3
    z = z^@power + p*@start
  elseif @form == 4
    z = z^(@power + p) + @start
  elseif @form == 5
    z = z^(p*@power) + @start
  else
    z = z^p + @start
  endif
bailout:
  |z| <= @bailout
default:
  title = "Laris 1 (Julia)"
  helpfile = "sam-help/laris.htm"
  param start
    caption = "Starting point"
    default = (-0.61,0.07)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e20
    min = 1.0
  endparam
  param form
    caption = "Formula type"
    enum = "(z + p)^n + c" "z^n + c + p" "(p*z)^n + c"\
           "z^n + p*c" "z^(n + p) + c" "z^(n*p) + c"\
           "z^p + c"
    default = 0
  endparam
  param modei
    caption = "Inside mode"
    enum = "Raw" "Smooth" "Very Smooth" \
           "Mistake"
    default = 0
  endparam
  param modeo
    caption = "Outside mode"
    enum = "Raw" "Smooth" "Very Smooth" \
           "Mistake"
    default = 0
  endparam
  param ispin
    caption = "Inside Spin"
    default = 0.0
  endparam
  param ospin
    caption = "Outside Spin"
    default = 0.0
  endparam
  param p1
    caption = "Inside parameter"
    default = (1,0)
  endparam
  param p2
    caption = "Outside parameter"
    default = (-1,0)
  endparam
  param p3
    caption = "Middle parameter"
    default = (-1,0)
  endparam
  param c
    caption = "Critical point"
    default = 0.0
  endparam
}



cglobesmm {
; By Samuel Monnier, 1999
; Rotation added 23.9.99
; Inspired by the Barnsley 1 formula
; This formula is rather messy, as it's
; my first big formula. If you have any 
; question or bug report, plese mail to
; samuel.monnier@urbanet.ch.
;
; Some advice :
;
; To really appreciate the smooth and
; very smooth modes, use Damiens's
; Smoothed Iterations (Mandelbrot) or
; a similar colouring. If the image
; isn't smooth, try modifying the 
; "exponent" value of the colouring.
; make also the bailout of the formula
; and of the colouring match. 
; Idem with the triangle inequality
; average and the cilia. 
;
; Some explanations :
;
; This formula is based on the formula
; (z + p)^power + #pixel where p is a
; parameter depending on when the
; current z is. It works like an
; orbit trap, but is different
; bacause an orbitg traps can't
; modify a formula parameter.
; Here is an explanation of
; each parameter of the formula :
;
; Starting point : As in the standard
; Mandelbrot set, it's the first value
; of z.
;
; Power : The power of (z + p)
;
; Bailout value : When the fomula decide
; that a point doesn't belong to the set.
; If you see strange black region, decreasing
; the bailout can help.
;
; Inside mode : The transfer function from the
; location of z to the parameter when z is 
; inside the trap (or f(x,y) < 0 for open shapes).
; In the first mode, Raw, when the point falls
; inside the trap, p takes the "Inside Parameter"
; value. In the second mode, Smooth, p vary linearily
; between the "On-the-Trap parameter" and the "Inside
; Parameter. In the third mode, the first derivative of
; the transfer function is 0 at the extremities. 
; This give a smoother transition.
;
; Outside mode : Idem "Inside mode" but this time
; when the point is outside the trap. You have to
; modify the outside parameter so that it's different
; from the On-the-trap parameter. Else it won't vary
; outside.
;
; Inside parameter : The value p takes when it's
; inside the trap.
;
; On-the-trap parameter : The value p takes when it's
; on the trap. (Useless when the inside mode and the
; outside mode are "Raw".
;
; Outside parameter : The value p takes when it's
; outside the trap.
;
; Inside spin : This allow you to multiply p
; by a factor e^(i*Insidespin*d). In the complex
; plane, p will move along a spiral instead of along
; a line. Useless if you use the "Raw mode".
;
; Outside spin : Idem Inside spin, but when p is
; outside the trap
;
; Shape : The shape of the trap. The closed shapes
; are : the circle, the rectangle, the astroïd, 
; Bernoulli's lemniscate and the folium. The other
; shapes are open and sometimes work differently.
;
; Flip shape ? : Allow you to flip the shape.
; (Horizontal lines are mapped into vertical ones
; and vice versa.)
;
; Mirror shape ? : Allow you to mirror the shape.
;
; Shape offset : Only for open shapes. Such shapes
; are usually described by a function like that :
; f(x) + g(y) = 0. This parameter modify the function
; so : f(x) + g(y) = offset. The result is that the 
; shape is moved and deformed.
;
; Center of the Shape : Just an advice, if you see a
; black screen, try changing this parameter.
;
; Shape periodicity : The shape is repeated 
; periodically. 
;
; Smoothy periodic ? : Use a smooth repeat function
; (sin) instead of the usual function.
;
; Concentric Periodicity : Only for open shapes.
; Instead of placing the shapes on a gird, they
; repeat concentrically. For the circle, this 
; gives a kind of ripple. I haven't manage to
; get this option to work with the rectangles.
; So it is (temporarily, I hope) disabled with 
; them.
;
; Size of the shape : No comment...
;
; Ratio width/height : ...
;
; Shape parameter : A parameter for the shape.
; Sometimes it won't change anything. I set the
; default to 1 so that it works well with the 
; astroïd shape, but with the pinch, set it
; to 3 or more to get the standard shape.
;
; Graph function : Only with the Graph shape.
;
; Extra graph function : idem graph function

init:
  z = @start
  dp = @p2 - @p1
  dpo = @p2 - @p3
  mirr = 1
  if @mirror
    mirr = -1
  endif
  smc = - 6 * dp/@size^3
  smd = 1/smc * @p1
  ispi = exp(flip(@ispin))
  ospi = exp(flip(@ospin))
loop:
  trz = exp(flip(-pi/180*@rot))*(z - @center)
  if @period > 0  && !@concper
    if @mode == 0 || @mode == 1 || @mode == 2 ||\
     @mode == 5 || @mode == 10 || @mode == 14 ||\
      @mode == 15
      trz = (trz/@period - round(trz/@period))\
      * @period
    endif
  endif
  
  
  if @mode == 0 ; The circles
    smx = sqrt(1/sqrt(@r) * sqr(real(trz)) \
    + sqrt(@r) * sqr(imag(trz)))
    if @period > 0 && @concper
      if @smper
        smx = sin(2*pi*smx/@period) + 1
      else
        smx = (smx/@period - round(smx/@period))\
        * @period + 1
      endif
    endif
    if smx < @size       ; Inside
       ispi = exp(flip(@ispin*(smx-@size))) ; Spin
       if @mode1 == 0      ; Raw mode
         p = @p1
       elseif @mode1 == 1  ; C0 Mode
         p = smx/@size * dp + @p1
       else                ; C1 Mode
         p = smc*(1/3*smx^3 - 1/2*@size*smx^2 + smd)
       endif
      z = (z + p*ispi)^@power + #pixel
    else                 ; Outside
      ospi = exp(flip(@ospin*(smx-@size)))
      if @mode2 == 0
         po = @p3
       elseif @mode2 == 1
         po = smx/@size * dpo + @p3
       else
         po = - dpo * log(abs((smx-@size)^2 + 1)) + @p2
       endif
      z = (z + po*ospi)^@power + #pixel
    endif
    
        
  elseif @mode == 1 ; The sqares
    smx1 = abs(1/sqrt(@r) * real(trz))
    smx2 = abs(sqrt(@r) * imag(trz))
    if smx1 < @size && smx2 < @size
      if @mode1 == 0
        if abs(real(trz)) > abs(imag(trz))
          ispi = exp(flip(@ispin*(smx1-@size)))
        else
          ispi = exp(flip(@ispin*(smx2-@size)))
        endif
        p = @p1
      elseif @mode1 == 1
        if smx1 > smx2
          ispi = exp(flip(@ispin*(smx1-@size)))
          smx2 = abs(sqrt(@r) * real(trz))
          px = smx1/@size * real(dp) + real(@p1)
          py = smx2/@size * imag(dp) + imag(@p1)
        else
          ispi = exp(flip(@ispin*(smx2-@size)))
          smx1 = abs(sqrt(@r) * imag(trz))
          px = smx1/@size * real(dp) + real(@p1)
          py = smx2/@size * imag(dp) + imag(@p1)
        endif
        p = px + flip(py)
      else
        if smx1 > smx2
          ispi = exp(flip(@ispin*(smx1-@size)))
          smx2 = abs(sqrt(@r) * real(trz))
          px = real(smc)*(1/3*smx1^3 - 1/2*@size*smx1^2 + real(smd))
          py = imag(smc)*(1/3*smx2^3 - 1/2*@size*smx2^2 + imag(smd))
        else
          ispi = exp(flip(@ispin*(smx2-@size)))
          smx1 = abs(sqrt(@r) * imag(trz))
          px = real(smc)*(1/3*smx1^3 - 1/2*@size*smx1^2 + real(smd))
          py = imag(smc)*(1/3*smx2^3 - 1/2*@size*smx2^2 + imag(smd))  
        endif
        p = px + flip(py)
      endif
      z = (z + p*ispi)^@power + #pixel
    else
      if @mode2 == 0
        if abs(real(trz)) > abs(imag(trz))
        ospi = exp(flip(@ospin*(smx1-@size)))
        else
        ospi = exp(flip(@ospin*(smx2-@size)))
        endif       
        po = @p3
      elseif @mode2 == 1
        if abs(real(trz)) > abs(imag(trz))
          ospi = exp(flip(@ospin*(smx1-@size)))
          smx2 = abs(sqrt(@r) * real(trz))
          pxo = smx1/@size * real(dpo) + real(@p3)
          pyo = smx2/@size * imag(dpo) + imag(@p3)
        else
          ospi = exp(flip(@ospin*(smx2-@size)))
          smx1 = abs(1/sqrt(@r) * imag(trz))
          pxo = smx1/@size * real(dpo) + real(@p3)
          pyo = smx2/@size * imag(dpo) + imag(@p3)
        endif
        po = pxo + flip(pyo)
      else
        if abs(real(trz)) > abs(imag(trz))
          ospi = exp(flip(@ospin*(smx1-@size)))
          smx2 = abs(sqrt(@r) * real(trz))
          pxo = - real(dpo) * log(abs((smx1-@size)^2 + 1)) + real(@p2)
          pyo = - imag(dpo) * log(abs((smx2-@size)^2 + 1)) + imag(@p2)
        else
          ospi = exp(flip(@ospin*(smx2-@size)))
          smx1 = abs(1/sqrt(@r) * imag(trz))
          pxo = - real(dpo) * log(abs((smx1-@size)^2 + 1)) + real(@p2)
          pyo = - imag(dpo) * log(abs((smx2-@size)^2 + 1)) + imag(@p2)  
        endif
        po = pxo + flip(pyo)
      endif
      z = (z + po*ospi)^@power + #pixel
    endif
    
    
  elseif @mode == 2  ; The astroids
    smx = @n*(1/sqrt(@r)) * abs(real(trz))^@n \
    + sqrt(@r) * abs(imag(trz))^@n
    if @period > 0 && @concper
      if @smper
        smx = sin(2*pi*smx/@period) + 1
      else
        smx = (smx/@period - round(smx/@period))\
        * @period + 1
      endif
    endif
    if smx < @size
      ispi = exp(flip(@ispin*(smx-@size)))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p = smx/@size * dp + @p1
      else
        p = smc*(1/3*smx^3 - 1/2*@size*smx^2 + smd)
      endif
      z = (z + p*ispi)^@power + #pixel
    else
      ospi = exp(flip(@ospin*(smx-@size)))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po = smx/@size * dpo + @p3
      else
        po = - dpo * log(abs((smx-@size)^2 + 1)) + @p2
      endif
      z = (z + po*ospi)^@power + #pixel
    endif
    
    
  elseif @mode == 3  ; The Folium
    x = mirr * 1/sqrt(@r)* real(trz)/@size
    y = sqrt(@r) * imag(trz)/@size
    smx = (x^3 + y^3 - 3*x*y - @offset)
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p = - smx * dp/500 + @p2
        ;Sometimes I added some factors, so that 
        ;the parameter doesn't increase too quickly.
      else
        p = - dp/20 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + p*ispi)^@power + #pixel
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po = - smx * dpo/500 + @p2
      else
        po = - dpo/40 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + po*ospi)^@power + #pixel
    endif  
    
            
  elseif @mode == 4  ; The Strophoïd
    if @flip
      y = 1/sqrt(@r)* real(trz)/@size
      x = mirr * sqrt(@r) * imag(trz)/@size
    else
      x = mirr * 1/sqrt(@r)* real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = x^2 * (@n + x)/(@n - x) - y^2 - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if  smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p = - smx * dp/100 + @p2
      else
        p = - dp/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + #pixel
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po = - smx * dpo/100 + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + #pixel
    endif
    
    
  elseif @mode == 5  ; The Lemniscate
    if @flip
      y = 1/sqrt(@r)* real(trz)/@size
      x = sqrt(@r) * imag(trz)/@size
    else
      x = 1/sqrt(@r)* real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = (x^2 + y^2)^2 - @n^2*(x^2 - y^2) - @offset
    if @period > 0 && @concper
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p = - smx * dp + @p2
      else
        p = - 100*dp * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + #pixel
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po = - smx / (1e4) * dpo + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + #pixel
    endif
    
  elseif @mode == 6  ; The Cissoïd
    if @flip
      y = 1/sqrt(@r)* real(trz)/@size
      x = mirr * sqrt(@r) * imag(trz)/@size
    else
      x = mirr * 1/sqrt(@r)* real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = y^2 - x^3/(@n - x) - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p = - smx * dp + @p2
      else
        p = - dp * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + #pixel
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po = - smx * dpo/100 + @p2
      else
        po = - dpo/100 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + #pixel
    endif
    
  elseif @mode == 7  ; Agnesi's Curve
    if @flip
      y = mirr * 1/sqrt(@r)* real(trz)/@size
      x = sqrt(@r) * imag(trz)/@size
    else
      x = 1/sqrt(@r)* real(trz)/@size
      y = mirr * sqrt(@r) * imag(trz)/@size
    endif
    smx = y - (1/(1 + x^2)) - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp + @p2
      else
        p = - dp * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + #pixel
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo/20 + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + #pixel
    endif
    
    
  elseif @mode == 8  ; The Parabola
    if @flip
      y = mirr * 1/sqrt(@r)* real(trz)/@size
      x = sqrt(@r) * imag(trz)/@size
    else
      x = 1/sqrt(@r)* real(trz)/@size
      y = mirr * sqrt(@r) * imag(trz)/@size
    endif
    smx = y - x^2 - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp/1000 + @p2
      else
        p = - dp/20 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + #pixel
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo/10 + @p2
      else
        po = - dpo/20 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + #pixel
    endif
    
    
  elseif @mode == 9  ; The Hyperbola
    x = mirr * 1/sqrt(@r)* real(trz)/@size
    y = sqrt(@r) * imag(trz)/@size
    smx = y - 1/x - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx > 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp/10 + @p2
      else
        p = - dp/20 * log(abs(smx^2 + 1)) + @p2
      endif 
      z = (z + ispi*p)^@power + #pixel
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo + @p2
      else
        po = - 100*dpo * log(abs(smx^2 + 1)) + @p2
      endif 
      z = (z + ospi*po)^@power + #pixel
    endif
    
  elseif @mode == 10  ; Pinch
    pin = atan2(trz)
    if pin < 0
      pin = pin + 2*pi
    endif
    smx = sqrt(cabs(trz))/abs(sin(pin*@n/2))
    if @period > 0 && @concper
      if @smper
        smx = sin(2*pi*smx/@period) + 1
      else
        smx = (smx/@period - round(smx/@period))\
        * @period + 1
      endif
    endif
    if smx < @size
      ispi = exp(flip(@ispin*(smx-@size)))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p = smx/@size * dp + @p1
      else
        p = smc*(1/3*smx^3 - 1/2*@size*smx^2 + smd)
      endif
      z = (z + ispi*p)^@power + #pixel
    else
      ospi = exp(flip(@ospin*(smx-@size)))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po = smx/@size * dpo/100 + 99/100*dpo + @p3
      else
        po = - dpo/10 * log(abs((smx-@size)^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + #pixel
    endif
    
  elseif @mode == 11  ; SC Parabola
    if @flip
      y = 1/sqrt(@r) * real(trz)/@size
      x = mirr * sqrt(@r) * imag(trz)/@size
    else
      x = mirr * 1/sqrt(@r) * real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = y^2 - x^3 - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp/5 + @p2
      else
        p = - dp/5 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + #pixel
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo/5 + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + #pixel
    endif

  elseif @mode == 12  ; Line
    if @flip
      y = 1/sqrt(@r) * real(trz)/@size
      x = mirr * sqrt(@r) * imag(trz)/@size
    else
      x = mirr * 1/sqrt(@r) * real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = y - @n*x - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp/5 + @p2
      else
        p = - dp/5 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + #pixel
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo/5 + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + #pixel
    endif
    
  elseif @mode == 13  ; cross
    if @flip
      y = 1/sqrt(@r) * real(trz)/@size
      x = mirr * sqrt(@r) * imag(trz)/@size
    else
      x = mirr * 1/sqrt(@r) * real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = (y - @n*x)*(y + 1/@n*x) - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp/5 + @p2
      else
        p = - dp/5 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + #pixel
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo/5 + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + #pixel
    endif

   
  
  elseif @mode == 14  ; Graph
    if @flip
      y = 1/sqrt(@r) * real(trz)/@size
      x = mirr * sqrt(@r) * imag(trz)/@size
    else
      x = mirr * 1/sqrt(@r) * real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = @f2(y) - @f1(x) - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp/5 + @p2
      else
        p = - dp/5 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + #pixel
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo/5 + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + #pixel
    endif
    

  endif
      
bailout:
  |z| <= @bailout
default:
  title = "Crystal Globe (Mand)"
  helpfile = "sam-help/cristalglobe.htm"
  center = (-0.5, 0)
  method = multipass
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e10
    min = 1.0
  endparam
  param mode1
    caption = "Inside Mode"
    enum = "Raw" "Smooth (C0)" "Very Smooth (C1)"
    default = 2
  endparam
  param mode2
    caption = "Outside Mode"
    enum = "Raw" "Smooth (C0)" "Very Smooth (C1)"
    default = 2
  endparam
  param p1
    caption = "Inside parameter"
    default = (1,0)
  endparam
  param p2
    caption = "On-the-trap parameter"
    default = (-1,0)
  endparam
  param p3
    caption = "Outside parameter"
    default = (-1,0)
  endparam
  param ispin 
    caption = "Inside spin"
    default = 0.0
  endparam
  param ospin
    caption = "Outside spin"
    default = 0.0
  endparam
  param mode
    caption = "Shape"
    enum = "Circle" "Rectangle" "Astroid" "Folium" \
    "Strophoïd" "Bernoulli Lemniscate" "Cissoïd" \
    "Agnesi's Curve" "Parabola" "Hyperbola" "Pinch" \
    "Semi Cubic Parabola" "Line" "Cross" "Graph" 
    default = 0
  endparam
  param flip
    caption = "Flip shape ?"
    default = false
    hint = "Exchange the x and y axis"
  endparam
  param mirror
    caption = "Mirror shape ?"
    default = false
  endparam
  param offset
    caption = "Shape offset"
    default = 0.0
  endparam
  param center
    caption = "Center of the shape"
    default = (0,0)
  endparam
  param rot
    caption = "Shape Rotation"
    default = 0.0
  endparam
  param period
    caption = "Shape periodicity"
    default = 0.0
  endparam
  param smper
    caption = "Smoothy Periodic ?"
    default = true
  endparam
  param concper
    caption = "Concentric Periodicity ?"
    default = false
    hint = "Only with closed shapes. This \
    statment is always true with open shapes"
  endparam
  param size
    caption = "Size of the shape"
    default = 0.2
    min = 0
  endparam
  param r
    caption = "Ratio width/height"
    default = 1.0
  endparam
  param n
    caption = "Shape Parameter"
    default = 1.0
  endparam
  func f1
    caption = "Graph Function"
    default = sin()
  endfunc
  func f2
    caption = "Extra Graph Function"
    default = ident()
  endfunc
switch:
  type = "cglobesmj"
  start= #pixel
  power = power
  bailout = bailout
  mode1 = mode1
  mode2 = mode2
  ispin = ispin
  ospin = ospin
  mode = mode
  center = center
  size = size
  rot = rot
  offset = offset
  period = period
  smper = smper
  concper = concper
  r = r
  n = n
  p1 = p1
  p2 = p2
  p3 = p3
  flip = flip
  mirror = mirror
  f1 = f1
  f2 = f2
}



cglobesmj {
; By Samuel Monnier, 1999
; Inspired by the Barnsley 1 formula
; See the Mandelbrot version for
; further explanations.

init:
  z = #pixel
  dp = @p2 - @p1
  dpo = @p2 - @p3
  mirr = 1
  if @mirror
    mirr = -1
  endif
  smc = - 6 * dp/@size^3
  smd = 1/smc * @p1
  ispi = exp(flip(@ispin))
  ospi = exp(flip(@ospin))
loop:
  trz = exp(flip(-pi/180*@rot))*(z - @center)
  if @period > 0  && !@concper
    if @mode == 0 || @mode == 1 || @mode == 2 ||\
     @mode == 5 || @mode == 10 || @mode == 14 ||\
      @mode == 15
      trz = (trz/@period - round(trz/@period))\
      * @period
    endif
  endif
  
  
  if @mode == 0 ; The circles
    smx = sqrt(1/sqrt(@r) * sqr(real(trz)) \
    + sqrt(@r) * sqr(imag(trz)))
    if @period > 0 && @concper
      if @smper
        smx = sin(2*pi*smx/@period) + 1
      else
        smx = (smx/@period - round(smx/@period))\
        * @period + 1
      endif
    endif
    if smx < @size       ; Inside
       ispi = exp(flip(@ispin*(smx-@size))) ; Spin
       if @mode1 == 0      ; Raw mode
         p = @p1
       elseif @mode1 == 1  ; C0 Mode
         p = smx/@size * dp + @p1
       else                ; C1 Mode
         p = smc*(1/3*smx^3 - 1/2*@size*smx^2 + smd)
       endif
      z = (z + p*ispi)^@power + @start
    else                 ; Outside
      ospi = exp(flip(@ospin*(smx-@size)))
      if @mode2 == 0
         po = @p3
       elseif @mode2 == 1
         po = smx/@size * dpo + @p3
       else
         po = - dpo * log(abs((smx-@size)^2 + 1)) + @p2
       endif
      z = (z + po*ospi)^@power + @start
    endif
    
        
  elseif @mode == 1 ; The sqares
    smx1 = abs(1/sqrt(@r) * real(trz))
    smx2 = abs(sqrt(@r) * imag(trz))
    if smx1 < @size && smx2 < @size
      if @mode1 == 0
        if abs(real(trz)) > abs(imag(trz))
          ispi = exp(flip(@ispin*(smx1-@size)))
        else
          ispi = exp(flip(@ispin*(smx2-@size)))
        endif
        p = @p1
      elseif @mode1 == 1
        if smx1 > smx2
          ispi = exp(flip(@ispin*(smx1-@size)))
          smx2 = abs(sqrt(@r) * real(trz))
          px = smx1/@size * real(dp) + real(@p1)
          py = smx2/@size * imag(dp) + imag(@p1)
        else
          ispi = exp(flip(@ispin*(smx2-@size)))
          smx1 = abs(sqrt(@r) * imag(trz))
          px = smx1/@size * real(dp) + real(@p1)
          py = smx2/@size * imag(dp) + imag(@p1)
        endif
        p = px + flip(py)
      else
        if smx1 > smx2
          ispi = exp(flip(@ispin*(smx1-@size)))
          smx2 = abs(sqrt(@r) * real(trz))
          px = real(smc)*(1/3*smx1^3 - 1/2*@size*smx1^2 + real(smd))
          py = imag(smc)*(1/3*smx2^3 - 1/2*@size*smx2^2 + imag(smd))
        else
          ispi = exp(flip(@ispin*(smx2-@size)))
          smx1 = abs(sqrt(@r) * imag(trz))
          px = real(smc)*(1/3*smx1^3 - 1/2*@size*smx1^2 + real(smd))
          py = imag(smc)*(1/3*smx2^3 - 1/2*@size*smx2^2 + imag(smd))  
        endif
        p = px + flip(py)
      endif
      z = (z + p*ispi)^@power + @start
    else
      if @mode2 == 0
        if abs(real(trz)) > abs(imag(trz))
        ospi = exp(flip(@ospin*(smx1-@size)))
        else
        ospi = exp(flip(@ospin*(smx2-@size)))
        endif       
        po = @p3
      elseif @mode2 == 1
        if abs(real(trz)) > abs(imag(trz))
          ospi = exp(flip(@ospin*(smx1-@size)))
          smx2 = abs(sqrt(@r) * real(trz))
          pxo = smx1/@size * real(dpo) + real(@p3)
          pyo = smx2/@size * imag(dpo) + imag(@p3)
        else
          ospi = exp(flip(@ospin*(smx2-@size)))
          smx1 = abs(1/sqrt(@r) * imag(trz))
          pxo = smx1/@size * real(dpo) + real(@p3)
          pyo = smx2/@size * imag(dpo) + imag(@p3)
        endif
        po = pxo + flip(pyo)
      else
        if abs(real(trz)) > abs(imag(trz))
          ospi = exp(flip(@ospin*(smx1-@size)))
          smx2 = abs(sqrt(@r) * real(trz))
          pxo = - real(dpo) * log(abs((smx1-@size)^2 + 1)) + real(@p2)
          pyo = - imag(dpo) * log(abs((smx2-@size)^2 + 1)) + imag(@p2)
        else
          ospi = exp(flip(@ospin*(smx2-@size)))
          smx1 = abs(1/sqrt(@r) * imag(trz))
          pxo = - real(dpo) * log(abs((smx1-@size)^2 + 1)) + real(@p2)
          pyo = - imag(dpo) * log(abs((smx2-@size)^2 + 1)) + imag(@p2)  
        endif
        po = pxo + flip(pyo)
      endif
      z = (z + po*ospi)^@power + @start
    endif
    
    
  elseif @mode == 2  ; The astroids
    smx = @n*(1/sqrt(@r)) * abs(real(trz))^@n \
    + sqrt(@r) * abs(imag(trz))^@n
    if @period > 0 && @concper
      if @smper
        smx = sin(2*pi*smx/@period) + 1
      else
        smx = (smx/@period - round(smx/@period))\
        * @period + 1
      endif
    endif
    if smx < @size
      ispi = exp(flip(@ispin*(smx-@size)))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p = smx/@size * dp + @p1
      else
        p = smc*(1/3*smx^3 - 1/2*@size*smx^2 + smd)
      endif
      z = (z + p*ispi)^@power + @start
    else
      ospi = exp(flip(@ospin*(smx-@size)))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po = smx/@size * dpo + @p3
      else
        po = - dpo * log(abs((smx-@size)^2 + 1)) + @p2
      endif
      z = (z + po*ospi)^@power + @start
    endif
    
    
  elseif @mode == 3  ; The Folium
    x = mirr * 1/sqrt(@r)* real(trz)/@size
    y = sqrt(@r) * imag(trz)/@size
    smx = (x^3 + y^3 - 3*x*y - @offset)
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p = - smx * dp/500 + @p2
        ;Sometimes I added some factors, so that 
        ;the parameter doesn't increase too quickly.
      else
        p = - dp/20 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + p*ispi)^@power + @start
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po = - smx * dpo/500 + @p2
      else
        po = - dpo/40 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + po*ospi)^@power + @start
    endif  
    
            
  elseif @mode == 4  ; The Strophoïd
    if @flip
      y = 1/sqrt(@r)* real(trz)/@size
      x = mirr * sqrt(@r) * imag(trz)/@size
    else
      x = mirr * 1/sqrt(@r)* real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = x^2 * (@n + x)/(@n - x) - y^2 - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if  smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p = - smx * dp/100 + @p2
      else
        p = - dp/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + @start
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po = - smx * dpo/100 + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + @start
    endif
    
    
  elseif @mode == 5  ; The Lemniscate
    if @flip
      y = 1/sqrt(@r)* real(trz)/@size
      x = sqrt(@r) * imag(trz)/@size
    else
      x = 1/sqrt(@r)* real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = (x^2 + y^2)^2 - @n^2*(x^2 - y^2) - @offset
    if @period > 0 && @concper
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p = - smx * dp + @p2
      else
        p = - 100*dp * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + @start
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po = - smx / (1e4) * dpo + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + @start
    endif
    
  elseif @mode == 6  ; The Cissoïd
    if @flip
      y = 1/sqrt(@r)* real(trz)/@size
      x = mirr * sqrt(@r) * imag(trz)/@size
    else
      x = mirr * 1/sqrt(@r)* real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = y^2 - x^3/(@n - x) - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p = - smx * dp + @p2
      else
        p = - dp * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + @start
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po = - smx * dpo/100 + @p2
      else
        po = - dpo/100 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + @start
    endif
    
  elseif @mode == 7  ; Agnesi's Curve
    if @flip
      y = mirr * 1/sqrt(@r)* real(trz)/@size
      x = sqrt(@r) * imag(trz)/@size
    else
      x = 1/sqrt(@r)* real(trz)/@size
      y = mirr * sqrt(@r) * imag(trz)/@size
    endif
    smx = y - (1/(1 + x^2)) - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp + @p2
      else
        p = - dp * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + @start
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo/20 + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + @start
    endif
    
    
  elseif @mode == 8  ; The Parabola
    if @flip
      y = mirr * 1/sqrt(@r)* real(trz)/@size
      x = sqrt(@r) * imag(trz)/@size
    else
      x = 1/sqrt(@r)* real(trz)/@size
      y = mirr * sqrt(@r) * imag(trz)/@size
    endif
    smx = y - x^2 - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp/1000 + @p2
      else
        p = - dp/20 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + @start
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo/10 + @p2
      else
        po = - dpo/20 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + @start
    endif
    
    
  elseif @mode == 9  ; The Hyperbola
    x = mirr * 1/sqrt(@r)* real(trz)/@size
    y = sqrt(@r) * imag(trz)/@size
    smx = y - 1/x - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx > 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp/10 + @p2
      else
        p = - dp/20 * log(abs(smx^2 + 1)) + @p2
      endif 
      z = (z + ispi*p)^@power + @start
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo + @p2
      else
        po = - 100*dpo * log(abs(smx^2 + 1)) + @p2
      endif 
      z = (z + ospi*po)^@power + @start
    endif
    
  elseif @mode == 10  ; Pinch

    pin = atan2(trz)
    if pin < 0
      pin = pin + 2*pi
    endif
    smx = sqrt(cabs(trz))/abs(sin(pin*@n/2))
    if @period > 0 && @concper
      if @smper
        smx = sin(2*pi*smx/@period) + 1
      else
        smx = (smx/@period - round(smx/@period))\
        * @period + 1
      endif
    endif
    if smx < @size
      ispi = exp(flip(@ispin*(smx-@size)))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p = smx/@size * dp + @p1
      else
        p = smc*(1/3*smx^3 - 1/2*@size*smx^2 + smd)
      endif
      z = (z + ispi*p)^@power + @start
    else
      ospi = exp(flip(@ospin*(smx-@size)))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po = smx/@size * dpo/100 + 99/100*dpo + @p3
      else
        po = - dpo/10 * log(abs((smx-@size)^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + @start
    endif
    
  elseif @mode == 11  ; SC Parabola
    if @flip
      y = 1/sqrt(@r) * real(trz)/@size
      x = mirr * sqrt(@r) * imag(trz)/@size
    else
      x = mirr * 1/sqrt(@r) * real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = y^2 - x^3 - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp/5 + @p2
      else
        p = - dp/5 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + @start
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo/5 + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + @start
    endif

  elseif @mode == 12  ; Line
    if @flip
      y = 1/sqrt(@r) * real(trz)/@size
      x = mirr * sqrt(@r) * imag(trz)/@size
    else
      x = mirr * 1/sqrt(@r) * real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = y - @n*x - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp/5 + @p2
      else
        p = - dp/5 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + @start
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo/5 + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + @start
    endif
    
  elseif @mode == 13  ; cross
    if @flip
      y = 1/sqrt(@r) * real(trz)/@size
      x = mirr * sqrt(@r) * imag(trz)/@size
    else
      x = mirr * 1/sqrt(@r) * real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = (y - @n*x)*(y + 1/@n*x) - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp/5 + @p2
      else
        p = - dp/5 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + @start
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo/5 + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + @start
    endif

   
  
  elseif @mode == 14  ; Graph
    if @flip
      y = 1/sqrt(@r) * real(trz)/@size
      x = mirr * sqrt(@r) * imag(trz)/@size
    else
      x = mirr * 1/sqrt(@r) * real(trz)/@size
      y = sqrt(@r) * imag(trz)/@size
    endif
    smx = @f2(y) - @f1(x) - @offset
    if @period > 0
      if @smper
        smx = sin(2*pi*smx/@period)
      else
        smx = (smx/@period - round(smx/@period))\
        * @period
      endif
    endif
    if smx < 0
      ispi = exp(flip(@ispin*smx))
      if @mode1 == 0
        p = @p1
      elseif @mode1 == 1
        p =  - smx * dp/5 + @p2
      else
        p = - dp/5 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ispi*p)^@power + @start
    else
      ospi = exp(flip(@ospin*smx))
      if @mode2 == 0
        po = @p3
      elseif @mode2 == 1
        po =  - smx * dpo/5 + @p2
      else
        po = - dpo/10 * log(abs(smx^2 + 1)) + @p2
      endif
      z = (z + ospi*po)^@power + @start
    endif
    
    
  endif
      
bailout:
  |z| <= @bailout
default:
  title = "Crystal Globe (Julia)"
  helpfile = "sam-help/cristalglobe.htm"
  center = (1,0)
  method = multipass
  param start
    caption = "Starting point"
    default = (0.2,0.205)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e10
    min = 1.0
  endparam
  param mode1
    caption = "Inside Mode"
    enum = "Raw" "Smooth (C0)" "Very Smooth (C1)"
    default = 2
  endparam
  param mode2
    caption = "Outside Mode"
    enum = "Raw" "Smooth (C0)" "Very Smooth (C1)"
    default = 2
  endparam
  param p1
    caption = "Inside parameter"
    default = (1,0)
  endparam
  param p2
    caption = "On-the-trap parameter"
    default = (-1,0)
  endparam
  param p3
    caption = "Outside parameter"
    default = (-1,0)
  endparam
  param ispin 
    caption = "Inside spin"
    default = 0.0
  endparam
  param ospin
    caption = "Outside spin"
    default = 0.0
  endparam
  param mode
    caption = "Shape"
    enum = "Circle" "Rectangle" "Astroid" "Folium" \
    "Strophoïd" "Bernoulli Lemniscate" "Cissoïd" \
    "Agnesi's Curve" "Parabola" "Hyperbola" "Pinch" \
    "Semi Cubic Parabola" "Line" "Cross" "Graph"
    default = 0
  endparam
  param flip
    caption = "Flip shape ?"
    default = false
    hint = "Exchange the x and y axis"
  endparam
  param mirror
    caption = "Mirror shape ?"
    default = false
  endparam
  param offset
    caption = "Shape offset"
    default = 0.0
  endparam
  param center
    caption = "Center of the shape"
    default = (0,0)
  endparam
  param period
    caption = "Shape periodicity"
    default = 0.0
  endparam
  param smper
    caption = "Smoothy Periodic ?"
    default = true
  endparam
  param concper
    caption = "Concentric Periodicity ?"
    default = false
    hint = "Only with closed shapes. This \
    statment is always true with open shapes"
  endparam
  param size
    caption = "Size of the shape"
    default = 0.2
    min = 0
  endparam
  param rot
    caption = "Shape Rotation"
    default = 0.0
  endparam
  param r
    caption = "Ratio width/height"
    default = 1.0
  endparam
  param n
    caption = "Shape Parameter"
    default = 1.0
  endparam
  func f1
    caption = "Graph Function"
    default = sin()
  endfunc
  func f2
    caption = "Extra Graph Function"
    default = ident()
  endfunc
}


laris2m {
; By Samuel Monnier, 23.9.1999
; Inspired by the Barnsley 1 formula
; and the Triangle Inequality Average 
; colouring.
;
; 
init:
  z = @start
  smx = 0.0
  i = 0
loop:

  oc = cabs(#pixel)
  oz = cabs(z)
  cz = cabs(z - #pixel)
  lb = abs(oc - cz)
  if @mode == 0
    smx = abs(oz -lb)/abs(oc + cz - lb)
  elseif @mode == 1
    i = i + 1
    smx = (i-1)*smx/i + abs(oz -lb)/(i*abs(oc + cz - lb))
  else
    i = i + 1
    smx = smx + i*abs(oz -lb)/abs(oc + cz - lb)
    p = (smx- .5)*@magn + @p1
  endif 
  if @tmode == 0
    p = (smx - .5)*@magn + @p1
  else
    p = (smx - .5)*@magn*@p1
  endif
  if @form == 0
    z = (z + p)^@power + #pixel
  elseif @form == 1
    z = z^@power + #pixel + p
  elseif @form == 2
    z = z^@power + p*#pixel
  endif
bailout:
  |z| <= @bailout
default:
  title = "Laris 2 (Mand)"
  helpfile = "sam-help/laris.htm"
  helptopic = "laris2"
  center = (-0.5, 0)
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e20
    min = 1.0
  endparam
  param form
    caption = "Formula type"
    enum = "(z + p)^n + c" "z^n + c + p" "z^n + p*c"
    default = 0
  endparam
  param mode
    caption = "Mode"
    enum = "Current z" "Average" "Average 2"
    default = 0
  endparam
  param tmode
    caption = "Transfer Mode"
    enum = "Addition" "Product"
    default = 0
  endparam
  param p1
    caption = "Default parameter"
    default = (0,0)
  endparam
  param magn
    caption = "Magnitude"
    default = (1,0)
  endparam
switch:
  type = "laris2j"
  start= #pixel
  power = power
  bailout = bailout
  form = form
  mode = mode
  tmode = tmode
  p1 = p1
  magn = magn
}

laris2j {
; By Samuel Monnier, 23.9.1999
; Inspired by the Barnsley 1 formula
; and the Triangle Inequality Average 
; colouring.
init:
  z = #pixel
  smx = 0.0
  i = 0
  z = z^@power + @start
loop:

  oc = cabs(#pixel)
  oz = cabs(z)
  cz = cabs(z - #pixel)
  lb = abs(oc - cz)
  if @mode == 0
    smx = abs(oz -lb)/abs(oc + cz - lb)
  elseif @mode == 1
    i = i + 1
    smx = (i-1)*smx/i + abs(oz -lb)/(i*abs(oc + cz - lb))
  else
    i = i + 1
    smx = smx + i*abs(oz -lb)/abs(oc + cz - lb)
    p = (smx- .5)*@magn + @p1
  endif 
  if @tmode == 0
    p = (smx - .5)*@magn + @p1
  else
    p = (smx - .5)*@magn*@p1
  endif
  if @form == 0
    z = (z + p)^@power + @start
  elseif @form == 1
    z = z^@power + @start + p
  elseif @form == 2
    z = z^@power + p*@start
  endif
bailout:
  |z| <= @bailout
default:
  title = "Laris 2 (Julia)"
  helpfile = "sam-help/laris.htm"
  helptopic = "laris2"
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e20
    min = 1.0
  endparam
  param form
    caption = "Formula type"
    enum = "(z + p)^n + c" "z^n + c + p" "z^n + p*c"
    default = 0
  endparam
  param mode
    caption = "Mode"
    enum = "Current z" "Average" "Average 2"
    default = 0
  endparam
  param tmode
    caption = "Transfer Mode"
    enum = "Addition" "Product"
    default = 0
  endparam
  param p1
    caption = "Default parameter"
    default = (0,0)
  endparam
  param magn
    caption = "Magnitude"
    default = (1,0)
  endparam
}

pc{
; By Samuel Monnier, 31.10.99
init:
  z = @start
  if @flavour == 1
    z = z + #pixel
  endif
  c = #pixel
loop:
  c = c^@power2
  z = z^@power + c
bailout:
  |z| <= @bailout
default:
  title = "Powered C"
  helpfile = "sam-help/various.htm"
  helptopic = "pc"
  param flavour
    caption = "Flavour"
    default = 0
    enum = "Standard" "Broken Symetry"
  endparam
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param power
    caption = "Power of z"
    default = (-1.5,1)
  endparam
  param power2
    caption = "Power of c"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e20
  endparam
}

trapinski {
; By Samuel Monnier, 23.12.99 
; This formula divide the
; complex plane into squares
; of length 2^n at the nth
; iteration. The point bails
; out if it is inside (or outside)
; a shape centered in this square.
; It can gives some Sierpinski-like
; patterns.
;
; Here is a quick explanation about
; what each parameter do :
;
; Shape : Define the shape of the trap
;
; Shape parameter : A parameter of the
; equation of the trap. The default 
; value is set so that it works well
; with the Astroïd. So you might have
; to change it if you are using another
; shape. If you use the Pinch, change
; this value to 5 or 6 (or the number
; of "petals" you want the pinch to
; have. On some shape like the Circle
; or the square, this parameter has no
; effect.
;
; Threshold : Define how far from the
; curve a point is considered as inside.
; No effect on some shapes.
; If the points aren't bailed out fast
; enough (ie the image is messy and long
; to calculate) or are bailed out too 
; fast, changing this value can help.
; In this case, you can also try
; changing the size of the shape.
;
; Rotation Step : Allow you to rotate
; the trap at each iteration.
; 
; Invert z : Apply z -> 1/z before 
; trapping. This can change the 
; shape of the trap.
;
; Graph functions : Only with the 
; Graph shape. The graph shape
; is defined by f(x) = g(y). Set
; the y function to ident to get
; a "standard" graph.
; 
; Anyway, if you have question, you
; can mail me at : 
; samuel.monnier@urbanet.ch
;
init:

  i = 0
  z = #pixel
  x = @f1(real(z))
  y = @f2(imag(z))
  zz = x + flip(y)
  
loop:
  
  ; Apply Function 3 and Rotation Step
  z = @f3(zz)*exp(1i*i*@rotst/180*pi)
  
  ; Compute the new z
  n = 2^i
  zi = round(z*n)/n
  z = n*(z - zi)
  
  i = i + 1
  
  ; Aspect Ratio and Size
  z = (1/@r^.5*real(z) + @r^.5*imag(z)*1i)/@size
  
  ; Rotation of the Shape
  z = z*exp(-1i*@rot/180*pi)
  
  ; Invert z
  if @invert
    z = 1/z
  endif
  
  x = real(z)
  y = imag(z)
  
  bool nobail = true
  
  ; Circle
  if @shape == 0 
    if @inside == 0
      if !(|z| > 1)
        nobail = false
      endif
    elseif @inside == 1
      if !(|z| < 1)
        nobail = false
      endif
    endif
  endif
  
  ; Square
  if @shape == 1 
    if @inside == 1
      if !(abs(real(z)) > 1 || abs(imag(z)) > 1)
        nobail = false
      endif
    elseif @inside == 0
      if !(abs(real(z)) < 1 || abs(imag(z)) < 1)
        nobail = false
      endif
    endif
  endif
  
  ; Astroïd
  if @shape == 2 
    if @inside == 1
      if !(abs(real(z))^@n + abs(imag(z))^@n > 1)
        nobail = false
      endif
    elseif @inside == 0
      if !(abs(real(z))^@n + abs(imag(z))^@n < 1)
        nobail = false
      endif
    endif
  endif

  ; Folium
  if @shape == 3 
    if @inside == 1
      if !(|x^3 + y^3 - 3*x*y| > @thresh)
        nobail = false
      endif
    elseif @inside == 0
      if !(|x^3 + y^3 - 3*x*y| < @thresh)
        nobail = false
      endif
    endif
  endif

  ; Cissoïd
  if @shape == 4 
    if @inside == 1
      if !(|y^2 - x^3/(@n - x)| > @thresh)
        nobail = false
      endif
    elseif @inside == 0
      if !(|y^2 - x^3/(@n - x)| < @thresh)
        nobail = false
      endif
    endif
  endif

  ; Parabola
  if @shape == 5 
    if @inside == 1
      if !(|y - x^2| > @thresh)
        nobail = false
      endif
    elseif @inside == 0
      if !(|y - x^2| < @thresh)
        nobail = false
      endif
    endif
  endif

  ; Hyperbola
  if @shape == 6 
    if @inside == 1
      if !(|y - 1/x| > @thresh)
        nobail = false
      endif
    elseif @inside == 0
      if !(|y - 1/x| < @thresh)
        nobail = false
      endif
    endif
  endif
  
  ; Pinch
  if @shape == 7
  pin = atan2(z)
  if pin < 0
    pin = pin + 2*pi
  endif 
    if @inside == 1
      if !(|sqrt(cabs(z))/abs(sin(pin*@n/2))| > @thresh)
        nobail = false
      endif
    elseif @inside == 0
      if !(|sqrt(cabs(z))/abs(sin(pin*@n/2))| < @thresh)
        nobail = false
      endif
    endif
  endif

  ; SC Parabola
  if @shape == 8 
    if @inside == 1
      if !(|y^2 - x^3| > @thresh)
        nobail = false
      endif
    elseif @inside == 0
      if !(|y^2 - x^3| < @thresh)
        nobail = false
      endif
    endif
  endif
  
  ; Line
  if @shape == 9 
    if @inside == 1
      if !(|y - @n*x| > @thresh)
        nobail = false
      endif
    elseif @inside == 0
      if !(|y - @n*x| < @thresh)
        nobail = false
      endif
    endif
  endif
  
  ; Cross
  if @shape == 10 
    if @inside == 1
      if !(|(y + @n*x)*(y + 1/@n*x)| > @thresh)
        nobail = false
      endif
    elseif @inside == 0
      if !(|(y + @n*x)*(y + 1/@n*x)| < @thresh)
        nobail = false
      endif
    endif
  endif
  
  ; Strophoïd
  if @shape == 11 
    if @inside == 1
      if !(x^2 * (@n + x)/(@n - x) - y^2 > @thresh)
        nobail = false
      endif
    elseif @inside == 0
      if !(x^2 * (@n + x)/(@n - x) - y^2 < @thresh)
        nobail = false
      endif
    endif
  endif
  
  ; Lemniscate
  if @shape == 12 
    if @inside == 1
      if !(|(x^2 + y^2)^2 - @n^2*(x^2 - y^2)| > @thresh)
        nobail = false
      endif
    elseif @inside == 0
      if !(|(x^2 + y^2)^2 - @n^2*(x^2 - y^2)| < @thresh)
        nobail = false
      endif
    endif
  endif

  ; Agnesi's Curve
  if @shape == 13 
    if @inside == 1
      if !(|y - (1/(1 + x^2))| > @thresh)
        nobail = false
      endif
    elseif @inside == 0
      if !(|y - (1/(1 + x^2))| < @thresh)
        nobail = false
      endif
    endif
  endif   
  
  ; Graph
  if @shape == 14 
    if @inside == 1
      if !(|@g2(y) - @g1(x)| > @thresh)
        nobail = false
      endif
    elseif @inside == 0
      if !(|@g2(y) - @g1(x)| < @thresh)
        nobail = false
      endif
    endif
  endif
  
  ; Cross 2
  if @shape == 15 
    if @inside == 1
      if !(abs(real(z)) > 1 && abs(imag(z)) > 1)
        nobail = false
      endif
    elseif @inside == 0
      if !(abs(real(z)) < 1 && abs(imag(z)) < 1)
        nobail = false
      endif
    endif
  endif
  
  z = (z-@zcenter)*exp(1i*pi/180*@zrot)/@zmagn
  
bailout:
  nobail == true
default:
  title = "Trapinski"
  helpfile = "sam-help/trapinsky.htm"
  method = multipass
  periodicity = 0
  param shape
    caption = "Shape"
    default = 1
    enum = "Circles" "Squares"  \
    "Astroïd" "Folium" "Cissoïd" "Parabola" \
    "Hyperbola" "Pinch" "SC Parabola" "Line" \
    "Cross" "Strophoïd" "Lemniscate" \
    "Agnesi's Curve" "Graph" "Cross 2"
  endparam
  param size
    caption = "Size of the Shape"
    default = .25
  endparam
  param rot
    caption = "Rotation of the Shape"
    default = 0.0
  endparam
  param r
    caption = "Ratio Width/Height"
    default = 1.0
  endparam
  param n
    caption = "Shape parameter"
    default = .5
  endparam
  param thresh
    caption = "Threshold"
    default = .2
  endparam
  param rotst
    caption = "Rotation step"
    default = 0.0
  endparam
  param inside
    caption = "Trapping region"
    default = 1
    enum = "Outside" "Inside"
  endparam
  param invert
    caption = "Invert z?"
    default = false
  endparam
  param zcenter
    caption = "Mapping center"
    default = (0,0)
  endparam
  param zrot
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  param zmagn
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  func g1
    caption = "Graph x Function"
    default = sin()
  endfunc
  func g2
    caption = "Graph y Function"
    default = ident()
  endfunc
  func f1 
    caption = "Real twist function"
    default = ident()
  endfunc
  func f2 
    caption = "Imaginary twist function"
    default = ident()
  endfunc
  func f3 
    caption = "Another twist function"
    default = ident()
  endfunc
}

KochCurve {
; By Samuel Monnier, 2.1.00
init:
  z = #pixel
  zz = 0
  ; Twist
  z = 1/sqrt(@r)*real(z) + 1i*sqrt(@r)*imag(z)
  x = real(z)
  y = imag(z)
  sq3 = sqrt(3)
  bool bail2 = false
  bool bail = false
  i = 0
loop:
  i = i + 1
  ;----------------
  ; First Iteration
  ;----------------
  if i == 2
    
    
    
    ; Calculate the argument of z
    arg = atan2(z)
  
    ; Inside approximation
    if @region == 0 || @region == 2
  
      ; Draw the Star of David
      if (y + 1/sq3 > 0) && (sq3*x - y + 2/sq3 > 0) \
         && (sq3*x + y - 2/sq3 < 0)
        bail = true
      endif
      if (-y + 1/sq3 > 0) && (sq3*x + y + 2/sq3 > 0) \
         && (sq3*x - y - 2/sq3 < 0)
        bail = true
      endif
    
      ; Deal the case where z needs a rotation
      if (arg > 5/6*pi) || (arg < -pi/2)
        z = z*exp(1i*4/3*pi)
      endif
      if (arg < pi/6) && (arg > -pi/2)
        z = z*exp(1i*2/3*pi)
      endif
      z = z - 1i*1/sq3
      if @region == 2
        zz = z
        z = #pixel
      endif 
    endif
  
    ; Outside approximation
    if @region == 1 || @region == 2
  
      ; Draw the hexagon
      if |x| > 1 || x/sq3 + y - 2*sq3/3 > 0 \
         || x/sq3 + y + 2*sq3/3 < 0 || x/sq3 \
         - y + 2*sq3/3 < 0 || x/sq3 - y - \
         2*sq3/3 > 0
        bail = true
      endif
   
      ; Deal the case where z needs a rotation
      if (abs(arg) < pi/6)
        z = z*exp(-1i*pi/2)
      elseif (arg > pi/6) && (arg < pi/2)
        z = z*exp(-1i*5*pi/6)
      elseif (arg > pi/2) && (arg < 5*pi/6)
        z = z*exp(1i*5*pi/6)
      elseif (abs(arg) > 5*pi/6) 
        z = z*exp(1i*pi/2)
      elseif (arg < -pi/6) && (arg > -pi/2)
        z = z*exp(-1i*pi/6)
      elseif (arg < -pi/2) && (arg > -5*pi/6)
        z = z*exp(1i*pi/6)
      endif
      z = z + 1i
      z = sq3*z
      
    endif
  
  ;----------------
  ;Other Iterations
  ;----------------
  elseif i > 2
    ; "Undo" the offset parameter's
    ; action
    z = z + @offset
    z = 1/sqrt(@r)*real(z) + 1i*sqrt(@r)*imag(z)
    if @region == 2
      oldz = z
      z = zz
      zz = oldz
    endif
    ; Magnify z so that a simple formula
    ; allows to compute...
    z = 3*z
    x = real(z)
    y = imag(z)
    ; ...the new triangle on the segment   
    if (y > 0) && (sq3*x - y + sq3 > 0) \
       && (sq3*x + y - sq3 < 0)
      bail2 = true
    endif
    ; Restore the original value of z
    z = z/3
  
    x = real(z)
    y = imag(z)
    ; Transforms the left segment
    if x < -1/3
      z = 3*z + 2
    ; Transforms the right segment
    elseif x > 1/3
      z = 3*z - 2
    else
      ; Transforms the middle-left segment
      if x < 0
        z = z + 1/3
        z = z*exp(-1i*pi/3)
        z = 3*z - 1
      ; Transforms the middle-right segment
      else
        z = z - 1/3
        z = z*exp(1i*pi/3)
        z = 3*z + 1
      endif
    endif
  
  endif
  
  ; A parameter to fool some coloring
  ; algorythms like final decomposition... 
  if i >= 2
    z = z - @offset
  endif
  
bailout:
  bail == false && bail2 == false
  
default:
  title = "Koch Curve"
  helpfile = "sam-help/kochcurves.htm"
  helptopic = "kcurve"
  magn = 1.5
  center = (0.0002,0)
  maxiter = 50
  param region
    caption = "Trapped Region"
    default = 0
    enum = "Inside" "Outside" "Both"
  endparam
  param offset
    caption = "Offset"
    default = (0,0)
  endparam
  param r
    caption = "Twist Parameter"
    default = (1,0)
  endparam  
}

KochCurvesq {
; By Samuel Monnier, 3.1.99
init:
  z = #pixel
  x = real(z)
  y = imag(z)
  arg = atan2(z)
  bool bail2 = false
  i = 0
loop:
  i = i + 1
  
  bool bail = false
  
  ;----------------
  ; First Iteration
  ;----------------
  if i == 2
    
    ; Twist
    z = 1/sqrt(@r)*real(z) + 1i*sqrt(@r)*imag(z)
    
    ; Outside Mode
    if @mode == 0
      ; Draw a square
      if |x| < 1 && |y| < 1
        bail = true
      endif
  
  
      ; Deal the case where z needs a rotation
      if abs(arg) < pi/4
        z = z*exp(1i*pi/2)
      elseif (arg < -pi/4) && (arg > -3*pi/4)
        z = z*exp(1i*pi)
      elseif abs(arg) > 3*pi/4
        z = z*exp(1i*3*pi/2)
      endif
      z = z - 1i

    ; Inside Mode
    elseif @mode == 1
      ; Draws a (rotated) square
      z = 1/sqrt(2)*z*exp(1i*pi/4)
      x = real(z)
      y = imag(z)
      if |x| > 1 || |y| > 1
        bail = true
      endif
      
      arg = atan2(z)
      
      ; Deal the case where z needs a rotation
      if abs(arg) < pi/4
        z = z*exp(1i*pi/2)
      elseif (arg < -pi/4) && (arg > -3*pi/4)
        z = z*exp(1i*pi)
      elseif abs(arg) > 3*pi/4
        z = z*exp(1i*3*pi/2)
      endif
      z = -z + 1i
      
    endif
 
    ;----------------
    ;Other Iterations
    ;----------------
  elseif i > 2
    ; "Undo" the offset parameter's
    ; action
    z = z + @offset
    
    z = 1/sqrt(@r)*real(z) + 1i*sqrt(@r)*imag(z)
    
    bool bail2 = false
    x = real(z)
    y = imag(z)   
    if abs(x) < 1/@s && abs(y - 1/@s) < 1/@s
      bail2 = true
    endif
    
    ; Transforms the left segment
    if x < -1/@s && y < -x - 1/@s
      z = 2*@s/(@s-1)*z + (@s+1)/(@s-1)
    ; Transforms the right segment
    elseif x > 1/@s && y < x - 1/@s
      z = 2*@s/(@s-1)*z - (@s+1)/(@s-1)
    ; Transforms the vertical left segment
      elseif x <= -1/@s && y > -x - 1/@s
      z = z + 1/@s
      z = z*exp(-1i*pi/2)
      z = @s*z - 1
    ; Transforms the vertical right segment
    elseif x >= 1/@s && y > x - 1/@s
      z = z - 1/@s
      z = z*exp(1i*pi/2)
      z = @s*z + 1
    ; Transforms the top segment
    elseif abs(x) < 1/@s
      z = @s*z - 2*1i
    endif
    
  endif
  
  ; A parameter to fool some coloring
  ; algorythms like final decomposition... 
  if i >= 2
    z = z - @offset
  endif
  
bailout:
  bail == false && bail2 == false
  
default:
  title = "Squarry Koch Curve"
  helpfile = "sam-help/kochcurves.htm"
  helptopic = "skcurve"
  magn = 1
  center = (0.00021,0.0002)
  maxiter = 50
  periodicity = 0
  param mode
    caption = "Mode"
    default = 0
    enum = "Outside" "Inside"
  endparam
  param s
    caption = "Magnification step"
    default = 4.0
  endparam
  param offset
    caption = "Offset"
    default = (0,-1)
  endparam
  param r
    caption = "Twist Parameter"
    default = (1,0)
  endparam 
}


KochCurvecir {
; By Samuel Monnier, 5.1.99
init:
  z = #pixel
  float arg = atan2(z)
  bool bail = false
  int i = 0
loop:
  i = i + 1
  
  if i > 1
  z = 1/sqrt(@r)*real(z) + 1i*sqrt(@r)*imag(z)  
  ; Outside Mode
  if @mode == 0 || (@mode == 2 && i > 2)
    ; Draw a circle
    if |z| < 1
      bail = true
    endif
  ; Inside mode
  elseif @mode == 1 || (@mode == 2 && i == 2)
    if |z| > 1 
      bail = true
    endif
  endif
  
  arg = atan2(z)
  
  ; Deal the case where z needs a rotation
  float arg2 = round(@n/(2*pi)*arg)*2*pi/@n
  
  ; Prevent the "son-circle" drawed under the
  ; "mother" one from having babies...
  if round(@n/(2*pi)*arg) == 0 && i > 2
    if arg > 0
      arg2 = 2*pi/@n
    else
      arg2 = -2*pi/@n
    endif
  endif
  ; Rotate the z that need it.
  z = z*exp(-1i*arg2)
  ; Set the future circle center
  ; at the origin
  if @mode == 0 
    z = - z + (1 + 1/@s)
  elseif @mode == 1
    z = - z + (1 - 1/@s)
  elseif (@mode == 2 && i == 2)
    z =  + z - (1 - 1/@s)
  elseif (@mode == 2 && i > 2)
    z = - z + (1 + 1/@s)
  endif
  ; Magnifiy z by s.
  z = @s*z
  endif

bailout:
  bail == false
default:
  title = "Circly Koch Curve"
  helpfile = "sam-help/kochcurves.htm"
  magn = .5
  center = (0.00021,0.0002)
  maxiter = 50
  periodicity = 0
  param mode
    caption = "Mode"
    default = 0
    enum = "Outside" "Inside" "Mix"
  endparam
  param s
    caption = "Magnification step"
    default = 1.7
  endparam
  param n
    caption = "Curve Order"
    default = 3
  endparam
  param r
    caption = "Twist Parameter"
    default = (1,0)
  endparam
}

SierpinskiTriangleII {
; By Samuel Monnier, 12.01.00
; This formula draws the Sierpinski
; with a different algorythm, so the
; result when combined with colorings
; is different.
; It only draws isocel triangles 
; (specify the bottom angles with the 
; Alpha parameter), but I added a 
; parameter which allow you to stretch 
; it horizontally. You should be able 
; to draw any triangle so.
; The offset parameter allow you to
; translate the z the coloring is
; seeing. Try it with Final 
; Decomposition...

init:
  z = #pixel
  float x = real(z)
  float y = imag(z)
  float a = @alpha*pi/180
  float m1 = tan(a)
  bool bail = false
  int i = 0
  ; Transversal twist
  z = x - @trt*y + flip(y)
  x = real(z)
loop:
  i = i + 1
  ; First Iteration
  if i == 1
    if m1*x + m1 < y || -m1*x + m1 < y \
       || y < 0
    endif
    z = -2*z
    z = z + 1i*m1
    z = z - @offset
  ; Other iterations
  else
    z = z + @offset
    x = real(z)
    y = imag(z)
    if -m1*x + m1 >= y  && m1*x + m1 >= y \
       && y >= 0
      bail = true
    elseif m1*x + m1 < y
      z = 2*z + 2 - 1i*m1
    elseif -m1*x + m1 < y
      z = 2*z - 2 - 1i*m1
    elseif y < 0
      z = 2*z + 1i*m1
    endif
  
    z = z - @offset
  endif
bailout:
  bail == false  
default:
  title = "Sierpinski Triangle II"
  helpfile = "sam-help/various.htm"
  helptopic = "sierp2"
  center = (0,.5)
  param alpha
    caption = "Alpha"
    default = 60.0
  endparam
  param trt
    caption = "Transversal twist"
    default = 0.0
  endparam
  param offset
    caption = "Offset"
    default = (0,0)
  endparam
}

sierpinskiplane {
; Written by Luke Plant
; Modified by Frederik Slijkerman
; Modified by Samuel Monnier 
init:
  z = #pixel
  i = 0
  count = 0
loop:
  z = #pixel
  n = @magn^i
  zi = round(z*n)/n
  z = n*(z - zi)
  while |z| < 127 && |z| > .001 && count < 100
    count = count + 1
    if imag(z) > .5
      z = 2*z - 1i
    elseif real(z) > .5
      z = 2*z - 1
    else
      z = 2*z
    endif
  endwhile
  i = i + 1
bailout:
  count < 100
default:
  title = "Sierpinski Plane"
  helpfile = "sam-help/various.htm"
  helptopic = "sierpplane"
  center = (0.4, 0.4)
  magn = 1.1538
  maxiter = 149
  method = multipass
  periodicity = 0
  param bailout
    caption = "Bailout value"
    default = 127
    min = 1
  endparam
  param magn
    caption = "Scale Factor"
    default = 2.0
  endparam
}

laris3m {
; By Samuel Monnier, 1999
; Inspired by the Barnsley 1 formula
init:
  z = @start
  if @jul == 0
    start = (.315,0)
  elseif @jul == 1
    start = (.45,-.095)
  elseif @jul == 2
    start = (.365,-.595)
  elseif @jul == 3
    start = (-.315, -.715)
  elseif @jul == 4
    start = (-.765,-.3)
  elseif @jul == 5
    start = (-.8,-.22)
  elseif @jul == 6
    start = (-.94,.305)
  elseif @jul == 7
    start = (-1.44,-.045)
  elseif @jul == 8
    start = (-1.745,.01)
  else 
    start = @seed
  endif
loop:
  int i = 0
  trz = exp(flip(-pi/180*@rot))*(z - @center)/@size
  zz = trz
  store = 0
  while i < @niter
    i = i + 1
    zz = zz^2 + start
    if |zz| > 1e20
      store = i
      i = @niter
    endif   
  endwhile
  if store == 0
    store = @niter
  endif
  logp = 1/log(2)
  logb = log(log(1e20))
  logz = log(log(cabs(zz)))
  smx = 0.01 * real(store + logp*logb - logp*logz)
  p = smx*@p1*exp(1i*@spin*smx)
  if @form == 0
    z = (z + p)^@power + #pixel
  elseif @form == 1
    z = z^@power + #pixel + p
  else
    z = z^@power + p*#pixel
  endif
bailout:
  |z| <= @bailout
default:
  title = "Laris 3 (Mand)"
  helpfile = "sam-help/laris.htm"
  helptopic = "laris3"
  center = (-0.5, 0)
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e20
    min = 1.0
  endparam
  param form
    caption = "Formula type"
    enum = "(z + p)^n + c" "z^n + c + p"\
           "z^n + p*c"
    default = 0
  endparam
  param p1
    caption = "Parameter"
    default = (1,0)
  endparam
  param spin
    caption = "Spin"
    default = 0.0
  endparam
  param jul
    caption = "Julia Set"
    enum = "1" "2" "3" "4" "5" "6" "7" "8" "9" \
    "Custom Julia"
    default = 1
  endparam
  param seed
    caption = "Custom Julia Seed"
    default = (0,0)
  endparam
  param niter
    caption = "Number of iterations"
    default = 50
  endparam
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param size
    caption = "Size"
    default = 1.0
  endparam
switch:
  type = "laris3j"
  start = #pixel
  power = power
  bailout = bailout
  form = form
  p1 = p1
  spin = spin
  jul = jul
  seed = seed
  niter = niter
  center = center
  rot = rot
  size = size
}

laris3j {
; By Samuel Monnier, 1999
; Inspired by the Barnsley 1 formula
init:
  z = #pixel
  if @jul == 0
    start = (.315,0)
  elseif @jul == 1
    start = (.45,-.095)
  elseif @jul == 2
    start = (.365,-.595)
  elseif @jul == 3
    start = (-.315, -.715)
  elseif @jul == 4
    start = (-.765,-.3)
  elseif @jul == 5
    start = (-.8,-.22)
  elseif @jul == 6
    start = (-.94,.305)
  elseif @jul == 7
    start = (-1.44,-.045)
  elseif @jul == 8
    start = (-1.745,.01)
  else 
    start = @seed
  endif
loop:
  int i = 0
  trz = exp(flip(-pi/180*@rot))*(z - @center)/@size
  zz = trz
  store = 0
  while i < @niter
    i = i + 1
    zz = zz^2 + start
    if |zz| > 1e20
      store = i
      i = @niter
    endif   
  endwhile
  if store == 0
    store = @niter
  endif
  logp = 1/log(2)
  logb = log(log(1e20))
  logz = log(log(cabs(zz)))
  smx = 0.01 * real(store + logp*logb - logp*logz)
  p = smx*@p1*exp(1i*@spin*smx)
  if @form == 0
    z = (z + p)^@power + @start
  elseif @form == 1
    z = z^@power + @start + p
  else
    z = z^@power + p*@start
  endif
bailout:
  |z| <= @bailout
default:
  title = "Laris 3 (Julia)"
  helpfile = "sam-help/laris.htm"
  helptopic = "laris3"
  param start
    caption = "Starting Point"
    default = (.213,-.046)
  endparam
  param power
    caption = "Power"
    default = (2,0)
  endparam
  param bailout
    caption = "Bailout value"
    default = 1e20
    min = 1.0
  endparam
  param form
    caption = "Formula type"
    enum = "(z + p)^n + c" "z^n + c + p"\
           "z^n + p*c"
    default = 0
  endparam
  param p1
    caption = "Parameter"
    default = (1,0)
  endparam
  param spin
    caption = "Spin"
    default = 0.0
  endparam
  param jul
    caption = "Julia Set"
    enum = "1" "2" "3" "4" "5" "6" "7" "8" "9" \
    "Custom Julia"
    default = 1
  endparam
  param seed
    caption = "Custom Julia Seed"
    default = (0,0)
  endparam
  param niter
    caption = "Number of iterations"
    default = 50
  endparam
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param size
    caption = "Size"
    default = 1.0
  endparam
}

pcfamily{
; By Samuel Monnier, 7.3.00
init:
  pix = #pixel
  pix = pix - @tilem
  pix = pix*exp(1i*pi/180*@rottile)
  pixc = round(pix/@sizesq)*@sizesq
  pix = pix*exp(-1i*pi/180*@rottile)
  pixc = pixc*exp(-1i*pi/180*@rottile)
  pix = pix + @tilem
  pixc = pixc + @tilem
  pix = 2*(pix - pixc)/@sizesq + @center
  pix = pix/@magn
  pix = pix*exp(1i*pi/180*@rot)
  z = pixc
  if @flavour == 1
    z = z + pix
  endif
  c = pix
loop:
  c = c^@power2
  z = z^@power + c
bailout:
  |z| <= @bailout
default:
  title = "Powered C Familly"
  helpfile = "sam-help/julifamily.htm"
  helptopic = "pc"
  param flavour
    caption = "Flavour"
    default = 0
    enum = "Standard" "Broken Symetry"
  endparam
 
  param power
    caption = "Power of z"
    default = (-1.5,1)
  endparam
  
  param power2
    caption = "Power of c"
    default = (2,0)
  endparam
  
  param center
    caption = "Center"
    default = (0,0)
  endparam

  param magn
    caption = "Magnification"
    default = 0.8
  endparam

  param rot
    caption = "Rotation"
    default = 0.0
  endparam

  param tilem
    caption = "Tiling displacement"
    default = (0,0)
  endparam

  param sizesq
    caption = "Size of the tiles"
    default = 0.5
  endparam

  param rottile
    caption = "Tiling rotation"
    default = 0.0
  endparam

  param bailout
    caption = "Bailout value"
    default = 1e20
  endparam
}

Mandfam {
; By Samuel Monnier, 1999
init:
  z = #pixel
  z = z - @tilem
  z = z*exp(1i*pi/180*@rottile)
  zc = round(z/@sizesq)*@sizesq
  z = z*exp(-1i*pi/180*@rottile)
  zc = zc*exp(-1i*pi/180*@rottile)
  z = z + @tilem
  zc = zc + @tilem
  z = 2*(z - zc)/@sizesq + @center
  z = z/@magn
  z = z*exp(1i*pi/180*@rot)
  c = z
  if @mode == 0
    z = zc
  elseif @mode == 1
    z = @start
  endif
loop:
  if @mode == 0
    z = z^@power + c
  elseif @mode == 1
    z = z^zc + c
  endif
bailout:
  |z| < @bailout
default:
  title = "Mandyfamily"
  helpfile = "sam-help/julifamily.htm"
  helptopic = "mandy"
  magn = 1.5
  param mode 
    caption = "What is varying ?"
    default = 0
    enum = "Starting Point" "Power"
  endparam
  
  param start
    caption = "Starting Point"
    default = (0,0)
  endparam
   
  param power
    caption = "Power"
    default = (2,0)
  endparam
  
  param center
    caption = "Center"
    default = (-.3,0)
  endparam

  param magn
    caption = "Magnification"
    default = .5
  endparam

  param rot
    caption = "Rotation"
    default = 0.0
  endparam

  param tilem
    caption = "Tiling displacement"
    default = (0,0)
  endparam

  param sizesq
    caption = "Size of the tiles"
    default = 0.3
  endparam

  param rottile
    caption = "Tiling rotation"
    default = 0.0
  endparam
  
  param bailout
    caption = "Bailout"
    default = 1e20
  endparam
}

glyph { 
; By Samuel Monnier, 19.3.00
; Modified Vine formula (from Mark Townsend)

init:
  z = #pixel    
  x = 0 
  y = 0 
  newx = 0
  newy = 0
  int iter = 0
  int i = 0
loop:
  iter = iter + 1
  x = real(z) + flip(real(@start/100))
  y = imag(z) + flip(imag(@start/100))
  newx = y
  newy = x
  i = 0
  while i < @flavor
    i = i + 1
    newx = y + real(@h2)*sin(@a * newx) + imag(@h2)*cos(@a * newx)
    newy = x + real(@h2)*sin(@a * newy) + imag(@h2)*cos(@a * newy)
  endwhile
  x = x - real(@h1)*sin(newx) - imag(@h1)*cos(newx)
  y = y + real(@h1)*sin(newy) + imag(@h1)*cos(newy)
  z = x + flip(y)
bailout:
  iter < #maxiter
default:
  title = "Glyph"
  helpfile = "sam-help/glyph.htm"
  maxiter = 20 
  magn = 0.15
  param flavor
    caption = "Flavor"
    default = 2
    min = 0
  endparam  
  param a
    caption = "Alpha"
    default = 2.7
  endparam  
  param h1
    caption = "Step size I"
    default = (.05,.05)
  endparam  
  param h2
    caption = "Step size II"
    default = (.8,.8)
  endparam
}

Multijul {
; By Samuel Monnier, 1999
init:
  z = #pixel
  z = z - @tilem
  z = z*exp(1i*pi/180*@rottile)
  zc = round(z/@sizesq)*@sizesq
  z = z*exp(-1i*pi/180*@rottile)
  zc = zc*exp(-1i*pi/180*@rottile)
  z = z + @tilem
  zc = zc + @tilem
  z = 2*(z - zc)/@sizesq + @center
  z = z/@magn
  z = z*exp(1i*pi/180*@rot)
  
loop:
  z = z^@power + zc
bailout:
  |z| < @bailout
default:
  title = "Julifamily"
  helpfile = "sam-help/julifamily.htm"
  param power
    caption = "Power"
    default = (2,0)
  endparam
  
  param center
    caption = "Center"
    default = (0,0)
  endparam

  param magn
    caption = "Magnification"
    default = .5
  endparam

  param rot
    caption = "Rotation"
    default = 0.0
  endparam

  param tilem
    caption = "Tiling displacement"
    default = (0,0)
  endparam

  param sizesq
    caption = "Size of the tiles"
    default = 0.6
  endparam

  param rottile
    caption = "Tiling rotation"
    default = 0.0
  endparam
  
  param bailout
    caption = "Bailout"
    default = 1e20
  endparam
}

pixeldis {
init:
  z = #pixel
loop:

bailout:
  false
default:
  title = "Pixel (slight move)"
  method = multipass
  center = (0.00037463919,-0.000384736491)
}

Mandelbrotfocorr {
; By Samuel Monnier, 14.10.00
init:
  z1 = @start
  z2 = @start  
  z3 = @start
  c1 = #pixel
  c2 = #pixel + @eps
  c3 = #pixel + 1i*@eps
  float a = 0
  float b = 0
  float c = 0
  float d = 0
  float ztestr = 0
  float ztesti = 0
  float det = 0
loop:
  z1 = z1^@power + c1
  z2 = z2^@power + c2
  z3 = z3^@power + c3
  
  a = real(z2-z1)/cabs(z2-z1)
  b = imag(z2-z1)/cabs(z2-z1)
  c = real(z3-z1)/cabs(z3-z1)
  d = imag(z3-z1)/cabs(z3-z1)

  ztestr = a*real(z1) + b*imag(z1)
  ztesti = c*real(z1) + d*imag(z1)
  
  
  z = ztestr + 1i*ztesti
    
bailout:
  |z1| <= @bailout
default:
  title = "Mandelbrot 1st Correction"
  
  center = (-0.5, 0)
  
  param start
    caption = "Starting point"
    default = (0,0)
  endparam
  
  param power
    caption = "Power"
    default = (2,0)
  endparam
  
  param eps
    caption = "Epsilon"
    default = 1e-10
  endparam
  
  param bailout
    caption = "Bailout value"
    default = 1e20
  endparam
switch:
  type = "Juliafocorr"
  start = #pixel
  power = power
  bailout = bailout
  eps = eps
}

Juliafocorr {
; By Samuel Monnier, 14.10.00
init:
  z1 = #pixel
  z2 = #pixel  
  z3 = #pixel
  c1 = @start
  c2 = @start + @eps
  c3 = @start + 1i*@eps
  float a = 0
  float b = 0
  float c = 0
  float d = 0
  float ztestr = 0
  float ztesti = 0
loop:
  z1 = z1^@power + c1
  z2 = z2^@power + c2
  z3 = z3^@power + c3
  
  a = real(z2-z1)/cabs(z2-z1)
  b = imag(z2-z1)/cabs(z2-z1)
  c = real(z3-z1)/cabs(z3-z1)
  d = imag(z3-z1)/cabs(z3-z1)
  
  ztestr = a*real(z1) + b*imag(z1)
  ztesti = c*real(z1) + d*imag(z1)
  
  z = ztestr + 1i*ztesti
    
bailout:
  |z1| <= @bailout
default:
  title = "Julia 1st Correction"
  
  center = (0, 0)
  
  param start
    caption = "Starting point"
    default = (0.27,0)
  endparam
  
  param power
    caption = "Power"
    default = (2,0)
  endparam
  
  param eps
    caption = "Epsilon"
    default = 1e-10
  endparam
  
  param bailout
    caption = "Bailout value"
    default = 1e20
  endparam
switch:
  type = "Mandelbrotfocorr"
  start = #pixel
  power = power
  bailout = bailout
  eps = eps
}

pixeldis1 {
init:
  z = #pixel
  int i = 0
loop:
  i = i + 1
bailout:
  i<2
default:
  title = "Pixel (2 Iterations)"
  method = multipass
  center = (0.00037463919,-0.000384736491)
}

IFS-Barnsley {
; By Samuel Monnier, 5.01
init:
  z = #pixel
  c1 = fn1(@bseed)
  c2 = fn2(@bseed)
loop:

  if @mode == 0 || @mode == 2
    if real(z) > @c
      z = (z+@p1)*c1
    else
      z = (z+@p2)*c2
    endif
  endif
  
  if @mode == 1 || @mode == 2
    if imag(z) > @c
      z = (z+@p1)*c1
    else
      z = (z+@p2)*c2
    endif
  endif
  
  if @mode == 3
    if cabs(z) > exp(@c)
      z = (z+@p1)*c1
    else
      z = (z+@p2)*c2
    endif
  endif
  
  if @mode == 4
    if real(z)*imag(z) > @c
      z = (z+@p1)*c1
    else
      z = (z+@p2)*c2
    endif
  endif
  

bailout:
  
  |z| < 1e3
default:
  title = "IFS-Barnsley"
  helpfile = "sam-help/barnsleys.htm"
  
  param mode
    caption = "Mode"
    default = 0
    enum = "Real" "Imaginary" "Alternate" "Cabs" "Cross"
  endparam
  
  param bseed
    caption = "Barnsley Seed"
    default = (0,0)
  endparam
  
  param c
    caption = "Critical Value"
    default = 0.0
  endparam
  
  param p1
    caption = "Parameter 1"
    default = (-1,0)
  endparam
  
  param p2
    caption = "Parameter 2"
    default = (1,0)
  endparam
  
  func fn1
    caption = "Case 1 Seed Function"
    default = ident()
  endfunc 
  
  func fn2
    caption = "Case 2 Seed Function"
    default = ident()
  endfunc
}

IFS-Barnsleym {
; By Samuel Monnier, 5.01
init:
    z = 1
    c1 = fn1(#pixel)
    c2 = fn2(#pixel)
loop:

  if @mode == 0 || @mode == 2
    if real(z) > @c
      z = (z+@p1)*c1
    else
      z = (z+@p2)*c2
    endif
  endif
  
  if @mode == 1 || @mode == 2
    if imag(z) > @c
      z = (z+@p1)*c1
    else
      z = (z+@p2)*c2
    endif
  endif
  
  if @mode == 3
    if cabs(z) > exp(@c)
      z = (z+@p1)*c1
    else
      z = (z+@p2)*c2
    endif
  endif
  
  if @mode == 4
    if real(z)*imag(z) > @c
      z = (z+@p1)*c1
    else
      z = (z+@p2)*c2
    endif
  endif
  
bailout:
  |z| < 1e3
default:
  title = "IFS-Barnsley (M-set)"
  helpfile = "sam-help/barnsleys.htm"
  
  param mode
    caption = "Mode"
    default = 0
    enum = "Real" "Imaginary" "Alternate" "Cabs" "Cross"
  endparam
  
  param c
    caption = "Critical Value"
    default = 0.0
  endparam
  
  param p1
    caption = "Parameter 1"
    default = (-1,0)
  endparam
  
  param p2
    caption = "Parameter 2"
    default = (1,0)
  endparam
  
  func fn1
    caption = "Case 1 Pixel Function"
    default = ident()
  endfunc 
  
  func fn2
    caption = "Case 2 Pixel Function2"
    default = ident()
  endfunc
  
switch:
 type = "IFS-Barnsley"
 bseed = #pixel
 fn1 = fn1
 fn2 = fn2
 mode = mode
 c = c
 p1 = p1
 p2 = p2
}

PolygonalBarnsleyj {
; By Samuel Monnier, 5.01
init:
  z = #pixel
  c1 = @bseed
  c2 = @bseed
  float arg = 0
loop:
  arg = atan2(z)
  arg = -round(arg/(2*pi)*@order)/@order*(2*pi)
  z = z*exp(1i*(arg+pi*@as/180))
  
  if @mode == 0
    if real(z) > @c
      z = (z+@p1)*c1
    else
      z = (z+@p2)*c2
    endif
  endif
  
  if @mode == 1
    if imag(z) > @c
      z = (z+@p1)*c1
    else
      z = (z+@p2)*c2
    endif
  endif
  
  
bailout:
  |z| < 1e3
default:
  title = "Polygonal Barnsley (Julia)"
  helpfile = "sam-help/barnsleys.htm"
  helptopic = "polybarn"
  
  param mode
    caption = "Mode"
    default = 0
    enum = "Real" "Imaginary"
  endparam
  
  param bseed
    caption = "Barnsley Seed"
    default = (0,0)
  endparam
  
  param order
    caption = "Polygon Order"
    default = 5
  endparam
  
  param as
    caption = "Angle Shift"
    default = 0.0
  endparam
  
  param c
    caption = "Critical Value"
    default = 0.0
  endparam
  
  param p1
    caption = "Parameter 1"
    default = (-1,0)
  endparam
  
  param p2
    caption = "Parameter 2"
    default = (1,0)
  endparam
}

PolygonalBarnsleym {
; By Samuel Monnier, 5.01
init:
  z = 1
  c1 = #pixel
  c2 = #pixel
  float arg = 0
 
loop:    
  
  arg = atan2(z)
  arg = -round(arg/(2*pi)*@order)/@order*(2*pi)
  z = z*exp(1i*(arg+pi*@as/180))
  
  if @mode == 0
    if real(z) > @c
      z = (z+@p1)*c1
    else
      z = (z+@p2)*c2
    endif
  endif
  
  if @mode == 1
    if imag(z) > @c
      z = (z+@p1)*c1
    else
      z = (z+@p2)*c2
    endif
  endif
  
bailout:
  |z| < 1e3
default:
  title = "Polygonal Barnsley (Mandelbrot)"
  helpfile = "sam-help/barnsleys.htm"
  helptopic = "polybarn"
  
  param mode
    caption = "Mode"
    default = 0
    enum = "Real" "Imaginary"
  endparam
  
  param order
    caption = "Polygon Order"
    default = 5
  endparam
  
  param as
    caption = "Angle Shift"
    default = 0.0
  endparam
  
  param c
    caption = "Critical Value"
    default = 0.0
  endparam
  
  param p1
    caption = "Parameter 1"
    default = (-1,0)
  endparam
  
  param p2
    caption = "Parameter 2"
    default = (1,0)
  endparam
  
switch:
 type = "PolygonalBarnsleyj"
 bseed = #pixel
 mode = mode
 order = order
 c = c
 as = as
 p1 = p1
 p2 = p2
}

Talis {
init:
  z = 0
  c = #pixel
loop:
  z = z^2 + c
  c = c^2/(c+p1) + z
bailout:
  |z| < 1000
default:
  title = "Talis"
switch:
}




DuckS-Jul {
; Ducks fractal (Julia version)
; By Samuel Monnier, 2011.
; http://www.algorithmic-worlds.net
;
; To be used with an "inside" coloring, for instance Statistics in lkm.ucl.
; Use rather the Mandelbrot-type formula with the switch feature to find a good
; seed.
;
; See this blog post for more information:
; http://www.algorithmic-worlds.net/blog/blog.php?Post=20110227
; Pictures using this algorithm can be found here:
; http://www.algorithmic-worlds.net/expo/expo.php?CollSearch=0&Collection=Ducks

init:
  z = #pixel

loop:
  if @v_DucksJ == 100
    z = exp(1i*@p2/pi*180)*z + @p3
  else
    z = exp(1i*@p2*pi/180)*z + @p3
  endif
  arg = round(atan2(z)/(2*pi)*@order)/@order*2*pi
  z = z*exp(-1i*arg)
  z = real(z) + 1i*abs(imag(z))
  z = (log(z^@pow)+@p1)^@pow2

bailout:
  true

default:
  title = "Ducks (Julia version)"

  int param v_DucksJ,
    caption = "Version (Ducks Julia)"
	  default = 101
 		hint = "This version parameter is used to detect when a change has been made to the formula that is incompatible with the previous version. When that happens, this field will reflect the old version number to alert you to the fact that an alternate rendering is being used."
		visible = @v_DucksJ < 100
  endparam
  param p2, caption = "Angle", default = 0.0, endparam
  param p3, caption = "Twist", default = (0,0), endparam
  param order, caption = "Order", default = 1, endparam
  param pow, caption = "First power", default = 1.0, endparam
  param pow2, caption = "Second power", default = 1.0, endparam
  param p1, caption = "Seed", default = (0,0), endparam
}


DuckS-Mand {
; Ducks fractal (Mandelbrot version)
; By Samuel Monnier, 2011.
; http://www.algorithmic-worlds.net
;
; To be used with an "inside" coloring, for instance Statistics in lkm.ucl.
; Use the switch feature inside the messy region to get nice patterns.
;
; See this blog post for more information:
; http://www.algorithmic-worlds.net/blog/blog.php?Post=20110227
; Pictures using this algorithm can be found here:
; http://www.algorithmic-worlds.net/expo/expo.php?CollSearch=0&Collection=Ducks

init:
  z = #pixel

loop:
  if @v_DucksM == 100
    z = exp(1i*@p2/pi*180)*z + @p3
  else
    z = exp(1i*@p2*pi/180)*z + @p3
  endif
  arg = round(atan2(z)/(2*pi)*@order)/@order*2*pi
  z = z*exp(-1i*arg)
  z = real(z) + 1i*abs(imag(z))
  z = (log(z^@pow)+#pixel)^@pow2

bailout:
  true
switch:
  type = "DuckS-Jul"
  p1 = #pixel
  p2 = p2
  p3 = p3
  pow = pow
  pow2 = pow2
  order = order

default:
  title = "Ducks (Mandelbrot version)"

  int param v_DucksM
    caption = "Version (Ducks Mandelbrot)"
	  default = 101
 		hint = "This version parameter is used to detect when a change has been made to the formula that is incompatible with the previous version. When that happens, this field will reflect the old version number to alert you to the fact that an alternate rendering is being used."
		visible = @v_DucksM < 100
  endparam
  param p2, caption = "Angle", default = 0.0, endparam
  param p3, caption = "Twist", default = (0,0), endparam
  param order, caption = "Order", default = 1, endparam
  param pow, caption = "First power", default = 1.0, endparam
  param pow2, caption = "Second power", default = 1.0, endparam
}




