comment{

Transformations by Samuel Monnier, 2000-2001. 

You can visit my webpage and 
update this file at
http://www.envy.nu/s31415/index/index.htm

If you have questions or comments, you can mail
me at samuel.monnier@urbanet.ch 

}


KochCurveScissor {
; By Samuel Monnier 5.1.00
transform:
  ; Perform translation, rotation and 
  ; magnification.
  z = #pixel
  z = z - @center
  z = z*exp(1i*pi/180*@rot)
  z = z/@magn
  ; Compute the Koch Curve
  float x = real(z)
  float y = imag(z)
  float sq3 = sqrt(3)
  bool first = true
  bool bail2 = false
  bool bail = false
  int ainout = @inout
  int i = 0
  while i < @niter
    i = i + 1
    ;----------------
    ; First Iteration
    ;----------------
    if first
    
    ; Draw the Star of David
    if (y + 1/sq3 > 0) && (sq3*x - y + 2/sq3 > 0) \
       && (sq3*x + y - 2/sq3 < 0)
      bail = true
    endif
    if (-y + 1/sq3 > 0) && (sq3*x + y + 2/sq3 > 0) \
       && (sq3*x - y - 2/sq3 < 0)
      bail = true
    endif
    
    ; Deal the case where z needs a rotation
    if (atan2(z) > 5/6*pi) || (atan2(z) < -pi/2)
      z = z*exp(1i*4/3*pi)
    endif
    if (atan2(z) < pi/6) && (atan2(z) > -pi/2)
      z = z*exp(1i*2/3*pi)
    endif
    z = z - 1i*1/sq3
  
    ;----------------
    ;Other Iterations
    ;----------------
    else
    x = real(z)
    y = imag(z)
    ; Transforms the left segment
    if x < -1/3
      z = 3*z + 2
    ; Transforms the right segment
    elseif x > 1/3
      z = 3*z - 2
    else
      ; Transforms the middle-left segment
      if x < 0
        z = z + 1/3
        z = z*exp(-1*1i*1/3*pi)
        z = 3*z - 1
      ; Transforms the middle-right segment
      else
        z = z - 1/3
        z = z*exp(1*1i*1/3*pi)
        z = 3*z + 1
      endif
    endif
    ; Magnify z so that a simple formula
    ; allows to compute... 
    z = 3*z
    x = real(z)
    y = imag(z)
    ; ...the new triangle on the segment   
    if (y > 0) && (sq3*x - y + sq3 > 0) \
       && (sq3*x + y - sq3 < 0)
      bail2 = true
    endif
    ; Restore the original value of z
    z = z/3
  
    endif
  
    first = false
    
  endwhile
  ; Look for inside points
  bool inside = true
  if bail == false && bail2 == false
    inside = false
  endif
  if ainout == 0 && inside
    #solid = true
  elseif ainout == 1 && !inside
    #solid = true
  endif
  
default:
  title = "Koch Curve Scissor"
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param magn
    caption = "Size"
    default = 1.0
  endparam
  param niter
    caption = "Number of Iterations"
    default = 10
  endparam
  param inout
    caption = "Solid Region"
    default = 0
    enum = "Inside" "Outside"
  endparam
}



KochCurvesqScissor {
; By Samuel Monnier 5.1.00
transform:
  ; Perform translation, rotation and 
  ; magnification.
  z = #pixel
  z = z - @center
  z = z*exp(1i*pi/180*@rot)
  z = z/@magn
  ; Compute the Squarry Koch Curve
  float x = real(z)
  float y = imag(z)
  arg = atan2(z)
  bool bail2 = false
  bool bail2 = false
  bool bail = false
  int ainout = @inout
  int i = 0
  while i < @niter
    i = i + 1
    ;----------------
    ; First Iteration
    ;----------------
    if i == 2
   
      ; Outside Mode
      if @mode == 0
        ; Draw a square
        if |x| < 1 && |y| < 1
          bail = true
        endif
  
  
        ; Deal the case where z needs a rotation
        if abs(arg) < pi/4
          z = z*exp(1i*pi/2)
        elseif (arg < -pi/4) && (arg > -3*pi/4)
          z = z*exp(1i*pi)
        elseif abs(arg) > 3*pi/4
          z = z*exp(1i*3*pi/2)
        endif
        z = z - 1i

      ; Inside Mode  
      elseif @mode == 1
        ; Draws a (rotated) square
        z = 1/sqrt(2)*z*exp(1i*pi/4)
        x = real(z)
        y = imag(z)
        if |x| > 1 || |y| > 1
          bail = true
        endif
        
        arg = atan2(z)
        
        ; Deal the case where z needs a rotation
        if abs(arg) < pi/4
          z = z*exp(1i*pi/2)
        elseif (arg < -pi/4) && (arg > -3*pi/4)
          z = z*exp(1i*pi)
        elseif abs(arg) > 3*pi/4
          z = z*exp(1i*3*pi/2)
        endif
        z = -z + 1i
      
      endif
 
    ;----------------
    ;Other Iterations
    ;----------------
    elseif i > 2
      x = real(z)
      y = imag(z)   
      if abs(x) < 1/@s && abs(y - 1/@s) < 1/@s
        bail2 = true
      endif
    
      ; Transforms the left segment
      if x < -1/@s && y < -x - 1/@s
        z = 2*@s/(@s-1)*z + (@s+1)/(@s-1)
      ; Transforms the right segment
      elseif x > 1/@s && y < x - 1/@s
        z = 2*@s/(@s-1)*z - (@s+1)/(@s-1)
      ; Transforms the vertical left segment
      elseif x <= -1/@s && y > -x - 1/@s
        z = z + 1/@s
        z = z*exp(-1i*pi/2)
        z = @s*z - 1
      ; Transforms the vertical right segment
      elseif x >= 1/@s && y > x - 1/@s
        z = z - 1/@s
        z = z*exp(1i*pi/2)
        z = @s*z + 1
      ; Transforms the top segment
      elseif abs(x) < 1/@s
        z = @s*z - 2*1i
      endif
    
    endif
    
  endwhile
  
  ; Look for inside points
  bool inside = true
  if bail == false && bail2 == false
    inside = false
  endif
  if @mode == 1
    inside = !inside
  endif
  if ainout == 0 && inside
    #solid = true
  elseif ainout == 1 && !inside
    #solid = true
  endif
  
default:
  title = "Squarry Koch Curve Scissor"
  param mode
    caption = "Mode"
    default = 0
    enum = "Outside" "Inside"
  endparam
  param s
    caption = "Magnification step"
    default = 4.0
  endparam
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param magn
    caption = "Size"
    default = 1.0
  endparam
  param niter
    caption = "Number of Iterations"
    default = 10
  endparam
  param inout
    caption = "Solid Region"
    default = 0
    enum = "Inside" "Outside"
  endparam
}

CirclyKochCurveScissor {
; By Samuel Monnier, 6.1.00
transform:
  ; Perform translation, rotation and 
  ; magnification.
  z = #pixel
  z = z - @center
  z = z*exp(1i*pi/180*@rot)
  z = z/@magn
  float arg = atan2(z)
  bool bail = false
  int i = 0
  
  while i < @niter
    
    i = i + 1
  
    if i > 1
    z = 1/sqrt(@r)*real(z) + 1i*sqrt(@r)*imag(z)  
    ; Outside Mode
    if @mode == 0 || (@mode == 1 && i > 2)
      ; Draw a circle
      if |z| < 1
        bail = true
      endif
    ; Inside mode
    elseif (@mode == 1 && i == 2)
      if |z| > 1 
        bail = true
      endif
    endif
  
    arg = atan2(z)
  
    ; Deal the case where z needs a rotation
    float arg2 = round(@n/(2*pi)*arg)*2*pi/@n
  
    ; Prevent the "son-circle" drawed under the
    ; "mother" one from having babies...
    if round(@n/(2*pi)*arg) == 0 && i > 2
      if arg > 0
        arg2 = 2*pi/@n
      else
        arg2 = -2*pi/@n
      endif
    endif
    ; Rotate the z that need it.
    z = z*exp(-1i*arg2)
    ; Set the future circle center
    ; at the origin
    if @mode == 0 
      z = - z + (1 + 1/@s)
    elseif (@mode == 1 && i == 2)
      z =  + z - (1 - 1/@s)
    elseif (@mode == 1 && i > 2)
      z = - z + (1 + 1/@s)
    endif
    ; Magnifiy z by s.
    z = @s*z
    endif
    
  endwhile
  
  if @reg == 1
    bail = !bail
  endif
  if @mode == 1
    bail = !bail
  endif
  
  if bail
    #solid = true
  endif
      
default:
  title = "Circly Koch Curve Scissor"
  helpfile = "sam-help/kctrans.htm"
  helptopic = "ckcsciss"
  param reg
    caption = "Solid Region"
    default = 0
    enum = "Inside" "Outside"
  endparam
  param mode
    caption = "Mode"
    default = 0
    enum = "Outside" "Mix"
  endparam
  param s
    caption = "Magnification step"
    default = 1.7
  endparam
  param n
    caption = "Curve Order"
    default = 3
  endparam
  param niter
    caption = "Number of Iterations"
    default = 20
  endparam
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param magn
    caption = "Size"
    default = .5
  endparam
  param r
    caption = "Twist Parameter"
    default = (1,0)
  endparam
}


CirclyKochCurvemap {
; By Samuel Monnier, 6.1.00
transform:
  z = #pixel
  zz = #pixel
  float sumarg = 0.0
  float arg = atan2(z)
  float arg2 = 0
  bool bail = false
  int i = 0
  int ii = 0
  
  while i < @niter
    
    i = i + 1
    if i > 1
    z = 1/sqrt(@r)*real(z) + 1i*sqrt(@r)*imag(z)  
    ; Outside Mode
    if @mode == 0 || (@mode == 1 && i > 2)
      ; Draw a circle
      if |z| < 1
        bail = true
      endif
    ; Inside mode
    elseif (@mode == 1 && i == 2)
      if |z| > 1 
        bail = true
      endif
    endif
    
    sumarg = sumarg + arg2
    if bail
      ii = i
      i = @niter
      zz = z
    endif
  
    arg = atan2(z)
  
    ; Deal the case where z needs a rotation
    arg2 = round(@n/(2*pi)*arg)*2*pi/@n
  
    ; Prevent the "son-circle" drawed under the
    ; "mother" one from having babies...
    if round(@n/(2*pi)*arg) == 0 && i > 2
      if arg > 0
        arg2 = 2*pi/@n
      else
        arg2 = -2*pi/@n
      endif
    endif
    ; Rotate the z that need it.
    z = z*exp(-1i*arg2)
    ; Set the future circle center
    ; at the origin
    if @mode == 0 
      z = - z + (1 + 1/@s)
    elseif (@mode == 1 && i == 2)
      z =  + z - (1 - 1/@s)
    elseif (@mode == 1 && i > 2)
      z = - z + (1 + 1/@s)
    endif
    ; Magnifiy z by s.
    z = @s*z
    endif
    
  endwhile
  
  ; "Stabilize" (Turns all the circles
  ; in the same direction).
  if @stab == true
    if (round(ii/2)*2 - ii) != 0
      zz = -zz
    endif
    zz = zz*exp(1i*sumarg)
  endif
  ; Apply Translation, Rotation and 
  ; Magnification 
  zz = zz + @center*@magn
  zz = zz*exp(-1i*pi/180*@rot)
  zz = zz/@magn
  
  #pixel = zz
  
  if !bail
    #solid = true
  endif
  
          
default:
  title = "Circly Koch Curve Mapping"
  helpfile = "sam-help/kctrans.htm"
  helptopic = "ckcmap"
  param mode
    caption = "Mode"
    default = 0
    enum = "Outside" "Mix"
  endparam
  param s
    caption = "Magnification step"
    default = 1.7
  endparam
  param n
    caption = "Curve Order"
    default = 3
  endparam
  param niter
    caption = "Number of Iterations"
    default = 20
  endparam
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param magn
    caption = "Size"
    default = .5
  endparam
  param r
    caption = "Twist Parameter"
    default = (1,0)
  endparam
  param stab
    caption = "Stabilize ?"
    default = true
  endparam
}


SqKochCurvemap {
; By Samuel Monnier, 7.1.00
transform:
  z = #pixel
  zz = #pixel
  float sumarg = 0.0
  float arg = atan2(z)
  bool bail = false
  int i = 0
  int ii = 0
  
  while i < @niter
    
  i = i + 1
  ;----------------
  ; First Iteration
  ;----------------
  if i == 2
    
    ; Twist
    z = 1/sqrt(@r)*real(z) + 1i*sqrt(@r)*imag(z)
    
    x = real(z)
    y = imag(z)
    
    ; Outside Mode
    if @mode == 0
      ; Draw a square
      if |x| < 1 && |y| < 1
        bail = true
        zz = #pixel
      endif
  
  
      ; Deal the case where z needs a rotation
      if abs(arg) < pi/4
        z = z*exp(1i*pi/2)
        sumarg = sumarg + pi/2
      elseif (arg < -pi/4) && (arg > -3*pi/4)
        z = z*exp(1i*pi)
        sumarg = sumarg + pi
      elseif abs(arg) > 3*pi/4
        z = z*exp(1i*3*pi/2)
        sumarg = sumarg + 3*pi/2
      endif
      z = z - 1i

    ; Inside Mode
    elseif @mode == 1
      ; Draws a (rotated) square
      z = 1/sqrt(2)*z*exp(1i*pi/4)
      sumarg = sumarg + pi/4
      x = real(z)
      y = imag(z)
      if |x| > 1 || |y| > 1
        bail = true
        zz = #pixel
      endif
      
      arg = atan2(z)
      
      ; Deal the case where z needs a rotation
      if abs(arg) < pi/4
        z = z*exp(1i*pi/2)
        sumarg = sumarg + pi/2
      elseif (arg < -pi/4) && (arg > -3*pi/4)
        z = z*exp(1i*pi)
        sumarg = sumarg + pi
      elseif abs(arg) > 3*pi/4
        z = z*exp(1i*3*pi/2)
        sumarg = sumarg + 3*pi/2
      endif
      z = -z + 1i
      
    endif
 
  ;----------------
  ;Other Iterations
  ;----------------
  elseif i > 2
    
    z = 1/sqrt(@r)*real(z) + 1i*sqrt(@r)*imag(z)
    
    x = real(z)
    y = imag(z)   
    if abs(x) < 1/@s && abs(y - 1/@s) < 1/@s
      bail = true
      zz = z
    endif
    
    ; Transforms the left segment
    if x < -1/@s && y < -x - 1/@s
      z = 2*@s/(@s-1)*z + (@s+1)/(@s-1)
    ; Transforms the right segment
    elseif x > 1/@s && y < x - 1/@s
      z = 2*@s/(@s-1)*z - (@s+1)/(@s-1)
    ; Transforms the vertical left segment
      elseif x <= -1/@s && y > -x - 1/@s
      z = z + 1/@s
      z = z*exp(-1i*pi/2)
      sumarg = sumarg - pi/2
      z = @s*z - 1
    ; Transforms the vertical right segment
    elseif x >= 1/@s && y > x - 1/@s
      z = z - 1/@s
      z = z*exp(1i*pi/2)
      sumarg = sumarg + pi/2
      z = @s*z + 1
    ; Transforms the top segment
    elseif abs(x) < 1/@s
      z = @s*z - 2*1i
    endif
    
  endif
  
  ; Bails out the point
  if bail
    ii = i
    i = @niter
  endif
    
  endwhile
  
  ; Make the images in the 
  ; little squares the same as
  ; in the big one.
  if ii > 2
    zz = @s*zz - 1i
    ; Corrects a little 
    ; problem with the inside
    ; mode
    if @mode == 1
      zz = -zz
    endif
  endif
  
  ; "Stabilize" (Turns all the circles
  ; in the same direction).
  if @stab == true
    if ii > 2
      zz = zz*exp(-1i*sumarg)
    endif
  endif
  
  ; Apply Translation, Rotation and 
  ; Magnification 
  zz = zz + @center*@magn
  zz = zz*exp(-1i*pi/180*@rot)
  zz = zz/@magn
  
  #pixel = zz
  
  if !bail
    #solid = true
  endif
            
default:
  title = "Squarry Koch Curve Mapping"
  helpfile = "sam-help/kctrans.htm"
  helptopic = "sqkcmap"
  param mode
    caption = "Mode"
    default = 0
    enum = "Outside" "Inside"
  endparam
  param s
    caption = "Magnification step"
    default = 4.0
  endparam
  param niter
    caption = "Number of Iterations"
    default = 20
  endparam
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param magn
    caption = "Size"
    default = 1.0
  endparam
  param r
    caption = "Twist Parameter"
    default = (1,0)
  endparam
  param stab
    caption = "Stabilize ?"
    default = true
  endparam
}



KochCurveScissorrot {
; By Samuel Monnier 5.1.00
transform:
  ; Perform translation, rotation and 
  ; magnification.
  z = #pixel
  z = z - @center
  z = z*exp(1i*pi/180*@rot)
  z = z/@magn
  ; Compute the Koch Curve
  float x = real(z)
  float y = imag(z)
  float sq3 = sqrt(3)
  bool first = true
  bool bail2 = false
  bool bail = false
  int i = 0
  while i < @niter
    i = i + 1
    ;----------------
    ; First Iteration
    ;----------------
    if first
    
    ; Draw the Star of David
    if (y + 1/sq3 > 0) && (sq3*x - y + 2/sq3 > 0) \
       && (sq3*x + y - 2/sq3 < 0)
      bail = true
    endif
    if (-y + 1/sq3 > 0) && (sq3*x + y + 2/sq3 > 0) \
       && (sq3*x - y - 2/sq3 < 0)
      bail = true
    endif
    
    ; Deal the case where z needs a rotation
    if (atan2(z) > 5/6*pi) || (atan2(z) < -pi/2)
      z = z*exp(1i*4/3*pi)
    endif
    if (atan2(z) < pi/6) && (atan2(z) > -pi/2)
      z = z*exp(1i*2/3*pi)
    endif
    z = z - 1i*1/sq3
  
    ;----------------
    ;Other Iterations
    ;----------------
    else
    x = real(z)
    y = imag(z)
    ; Transforms the left segment
    if x < -1/3
      z = 3*z + 2
    ; Transforms the right segment
    elseif x > 1/3
      z = 3*z - 2
    else
      ; Transforms the middle-left segment
      if x < 0
        z = z + 1/3
        z = z*exp(-1*1i*1/3*pi)
        z = 3*z - 1
      ; Transforms the middle-right segment
      else
        z = z - 1/3
        z = z*exp(1*1i*1/3*pi)
        z = 3*z + 1
      endif
    endif
    ; Magnify z so that a simple formula
    ; allows to compute... 
    z = 3*z
    x = real(z)
    y = imag(z)
    ; ...the new triangle on the segment   
    if (y > 0) && (sq3*x - y + sq3 > 0) \
       && (sq3*x + y - sq3 < 0)
      bail2 = true
    endif
    ; Restore the original value of z
    z = z/3
  
    endif
  
    first = false
    
  endwhile
  ; Look for inside points
  bool inside = true
  if bail == false && bail2 == false
    inside = false
  endif
  z = #pixel
  if inside
    z = z - @center
    z = z*exp(1i*pi/180*@rot2)
    z = z + @center
  endif
  #pixel = z
default:
  title = "Rotating Koch Curve Scissor"
  helpfile = "sam-help/kctrans.htm"
  helptopic = "rotkcsciss"
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param magn
    caption = "Size"
    default = 1.0
  endparam
  param niter
    caption = "Number of Iterations"
    default = 10
  endparam
  param rot2
    caption = "Rot. of the inside"
    default = 0.0
  endparam
}





CirclyKochCurvecol {
; By Samuel Monnier, 8.2.00
transform:
  z = #pixel
  float sumarg = 0.0
  float arg = atan2(z)
  float arg2 = 0
  bool bail = false
  int i = 0
  int ii = 0
  
  while i < @niter
    
    i = i + 1
    if i > 1
    z = 1/sqrt(@r)*real(z) + 1i*sqrt(@r)*imag(z)  
    ; Outside Mode
    if @mode == 0 || (@mode == 1 && i > 2)
      ; Draw a circle
      if |z| < 1
        bail = true
      endif
    ; Inside mode
    elseif (@mode == 1 && i == 2)
      if |z| > 1 
        bail = true
      endif
    endif
    
    sumarg = sumarg + arg2
    if bail
      ii = i
      i = @niter
    endif
  
    arg = atan2(z)
  
    ; Deal the case where z needs a rotation
    arg2 = round(@n/(2*pi)*arg)*2*pi/@n
  
    ; Prevent the "son-circle" drawed under the
    ; "mother" one from having babies...
    if round(@n/(2*pi)*arg) == 0 && i > 2
      if arg > 0
        arg2 = 2*pi/@n
      else
        arg2 = -2*pi/@n
      endif
    endif
    ; Rotate the z that need it.
    z = z*exp(-1i*arg2)
    ; Set the future circle center
    ; at the origin
    if @mode == 0 
      z = - z + (1 + 1/@s)
    elseif (@mode == 1 && i == 2)
      z =  + z - (1 - 1/@s)
    elseif (@mode == 1 && i > 2)
      z = - z + (1 + 1/@s)
    endif
    ; Magnifiy z by s.
    z = @s*z
    endif
    
  endwhile
  
  colour = (ii/@nbcol - floor(ii/@nbcol))*@nbcol
  
  #pixel = colour 
  
  if !bail
    #solid = true
  endif
  
          
default:
  title = "Circly Koch Curve Coloring"
  helpfile = "sam-help/kctrans.htm"
  helptopic = "ckccol"
  param mode
    caption = "Mode"
    default = 0
    enum = "Outside" "Mix"
  endparam
  param s
    caption = "Magnification step"
    default = 1.7
  endparam
  param n
    caption = "Curve Order"
    default = 3
  endparam
  param niter
    caption = "Number of Iterations"
    default = 20
  endparam
  param nbcol
    caption = "Number of colors"
    default = 3
  endparam
  param r
    caption = "Twist Parameter"
    default = (1,0)
  endparam
}

OctogonalScissor {
; By Samuel Monnier, 27.2.00
transform:
  z = #pixel
  z = z - @center
  z = z*exp(-1i*pi/180*@rot)
  z = z/@size
  float arg = 0
  float x = real(z)
  float y = imag(z) 
  float angle = @angle*pi/180
  if x < 0
    x = -x
  endif
  if y < 0
    y = -y
  endif
  z = x + flip(y)
  arg = atan2(z)
  if arg > pi/2 - angle
    z = z*exp(-1i*pi/2)
  elseif arg < pi/2 - angle && arg > angle
    z = z*exp(-1i*pi/4)
    z = z*cos(angle)/cos(pi/4-angle)
  endif
  int region = @region
  if region == 0 && real(z) < 1
    #solid = true
  elseif region == 1 && real(z) > 1
    #solid = true
  endif
default:
  title = "Octagonal Scissor"
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param size
    caption = "Size"
    default = 1.0
  endparam
  param angle
    caption = "Angle"
    default = 26.6
  endparam
  param region
    caption = "Solid Region"
    default = 0
    enum = "Inside" "Outside"
  endparam
}

OctogonLimitI {
; By Samuel Monnier, 1-2.00
; Here is a little tutorial about how to start an image with 
; this transform.
 
 ; First, choose the "Pixel" formula in mt.ufm and the 
 ; "Gradient" coloring in standard.ucl. Set the location 
 ; to a point close to zero, but not zero, because 
 ; there are some problem when the transform is 
 ; applied to an integer. Set for instance 
 ; (0.00001234, 0.0000000998756) or anything like 
 ; that. Then load the transform. Select then 
 ; Mode -> Shape Only. You should see a triangle. 
 ; Now you can modify this shape. You can only 
 ; modify the bottom side of the triangle, the other 
 ; sides will be modified in order to make the tiling 
 ; possible. This bottom side is the segment (0,0)-(1,0).
 ; So to modify the shape, select the parameter 
 ; "Point 1". Take the eyedropper and set it above or 
 ; below the bottom segment of the triangle. You will 
 ; see that the shape has changed. Now take the 
 ; parameter "Point 2" and do the same. You have ten 
 ; points to play with. Try not setting points too far 
 ; from the bottom segment because else the shape 
 ; risks intersecting itself and you'll get strange things. 
 ; Once you're satisfied with your shape, go back to 
 ; the "mapping" mode. this mode works like a scissor. 
 ; It cuts a tile in the underlaying image and build the 
 ; octogon with this tile.
 
 ; The "Color" mode allow you to make more 
 ; Escher-like images. This mode assign the same point 
 ; to all the points belonging to one tile and each tile is
 ; assigned a different point from the neighbouring ones. 
 ; So, if in the underlaying formula, these points are 
 ; colored with a different color, the tiles will look 
 ; differently colored. Use this with the Gradient coloring.
 ; You have three colors available and you can choose 
 ; which three points are assigned to the tiles with the 
 ; Color 1,2,3 parameters. The parameters "Center", 
 ; "Rotation" and "Magnification" must be used with the 
 ; Mapping mode and allow you to choose which 
 ; part of the underlaying image is mapped on the tile.

 ; 9.3.00
 ; I added more modes. These allow you to set some 
 ; tiles to solid color while the remaining ones are 
 ; computed as in the mapping mode. This allow you
 ; to make tiles that look really different from each other.


transform:
  z = #pixel
  arg = atan2(z)
  zz = 0
  ztest = 0
  float x = real(z)
  float y = imag(z) 
  bool bail = false
  bool bail0 = false
  bool bail1 = false
  bool bail2 = false
  bool bailtr = false
  bool endbail = false
  bool warn = false
  float col = 0
  int path0 = 3
  int path1 = 3
  int colour = 0
  ; Define the points
  float x1 = 0
  float y1 = 0
  float x2 = real(@p1)
  float y2 = imag(@p1)
  float x3 = real(@p2)
  float y3 = imag(@p2)
  float x4 = real(@p3)
  float y4 = imag(@p3)
  float x5 = real(@p4)
  float y5 = imag(@p4)
  float x6 = real(@p5)
  float y6 = imag(@p5)
  float x7 = real(@p6)
  float y7 = imag(@p6)
  float x8 = real(@p7)
  float y8 = imag(@p7)
  float x9 = real(@p8)
  float y9 = imag(@p8)
  float x10 = real(@p9)
  float y10 = imag(@p9)
  float x11 = real(@p10)
  float y11 = imag(@p10)
  float x12 = 1
  float y12 = 0
  ; Compute the slopes and the height
  float m12 = (y2-y1)/(x2-x1)
  float h12 = (x2*y1-x1*y2)/(x2-x1)
  float m23 = (y3-y2)/(x3-x2)
  float h23 = (x3*y2-x2*y3)/(x3-x2)
  float m34 = (y4-y3)/(x4-x3)
  float h34 = (x4*y3-x3*y4)/(x4-x3)
  float m45 = (y5-y4)/(x5-x4)
  float h45 = (x5*y4-x4*y5)/(x5-x4)
  float m56 = (y6-y5)/(x6-x5)
  float h56 = (x6*y5-x5*y6)/(x6-x5)
  float m67 = (y7-y6)/(x7-x6)
  float h67 = (x7*y6-x6*y7)/(x7-x6)
  float m78 = (y8-y7)/(x8-x7)
  float h78 = (x8*y7-x7*y8)/(x8-x7)
  float m89 = (y9-y8)/(x9-x8)
  float h89 = (x9*y8-x8*y9)/(x9-x8)
  float m910 = (y10-y9)/(x10-x9)
  float h910 = (x10*y9-x9*y10)/(x10-x9)
  float m1011 = (y11-y10)/(x11-x10)
  float h1011 = (x11*y10-x10*y11)/(x11-x10)
  float m1112 = (y12-y11)/(x12-x11)
  float h1112 = (x12*y11-x11*y12)/(x12-x11)
  int i = 0
  mode = @mode
  if mode != 1
  
  ; Sets up the first symetry
  if arg > pi/2
    z = z*exp(-1i*pi/2)
    colour = 1
  elseif arg < 0 && arg > -pi/2
    z = z*exp(1i*pi/2)
    colour = 1
  elseif arg < -pi/2
    z = z*exp(1i*pi)
  endif
  
  ; Begin the transformation 
  i = 0
  while i < @niter
  
  i = i + 1
  ztest = z
      
  ; -------------------------
  
  bail = false
  x = real(ztest)
  y = imag(ztest)
  
  ; Test the base line of the
  ; triangle.
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y > 0
    bail = true
  endif
    
  
  ; Store the bail value
  bail0 = bail
  bail = false
  
  
  ; -------------------------

  ; Test the left side of the
  ; triangle.
  
  ztest = ztest*exp(-1i*pi/2)
  x = real(ztest)
  y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y < m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y < m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y < m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y < m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y < m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y < m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y < m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y < m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y < m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y < m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y < m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y < m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y < m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y < m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y < m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y < m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y < m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y < m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y < 0
    bail = true
  endif
    
  
  ; Store the bail value
  bail1 = bail
  bail = false
  
  ; Restore the original value of ztest
  ztest = z
  
  
    ; -------------------------

  ; Test the right part of the right side 
  ; of the triangle.
  
  ztest = ztest - 1
  ztest = ztest*exp(1i*pi/4)
  ztest = ztest*sqrt(2)
  ztest = ztest + 1
  
  if real(ztest) > 0   
  
  x = real(ztest)
  y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y < m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y < m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y < m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y < m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y < m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y < m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y < m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y < m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y < m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y < m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y < m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y < m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y < m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y < m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y < m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y < m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y < m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y < m1112*x + h1112
      bail = !bail
    endif
  endif

  
  ; Left part of the right side
  else
  
  ztest = -ztest
  x = real(ztest)
  y = imag(ztest)
   
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  endif
    
  ; Store the bail value
  bail2 = bail
  bail = false
  
    ; Bails out the shape.
    if bail0 && bail1 && bail2
      endbail = true
      zz = z
      i = @niter
    endif


    ; Performs the iterative transformation
    ; Must do another big test... (sorry)
    ztest = z
    ztest = ztest - (.5,.5)
    ztest = ztest*exp(-1i*pi/4)
    ztest = ztest*sqrt(2)
    
    x = real(ztest)
    y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y > 0
    bail = true
  endif
    
  
  ; Store the bail value
  bailtr = bail
  bail = false
  
  if !warn && (bail0 && bail1) 
    ; Transform
    if !bail2 && !bailtr
      colour = colour + 1
      path0 = path0 + 1
      path1 = path1 - 1
      z = z - 1
      z = z*exp(1i*pi/4)
      z = sqrt(2)*z + 1
    elseif !bail2 && bailtr
      colour = colour - 1
      path0 = path0 - 1
      path1 = path1 + 1
      z = z - 1i
      z = z*exp(-1i*pi/4)
      z = sqrt(2)*z + 1i
    endif
    if path0 > 3
      path0 = 3
    elseif path1 > 3
      path1 = 3
    endif
  endif
  
  ; To fix a problem with the 
  ; four big central tiles
  if i == 1 && !bail1
    z = z*exp(-1i*pi/2)
    if colour == 1
      colour = 0
    else
      colour = 1
    endif
  elseif i == 1 && !bail0
    z = z*exp(1i*pi/2)
    if colour == 1
      colour = 0
    else
      colour = 1
    endif
  endif
  
  ; To fix another little problem    
  if warn && !endbail
    z = z - (.5,.5)
    z = -z
    z = z + (.5,.5)
    if path0 > 0
      colour = colour - 1
    elseif path0 == 0
      colour = colour + 1
    endif
    if .5*real(abs(#pixel))-1 < -imag(abs(#pixel))
      if path0 > 0
        colour = colour - 1
      elseif path0 == 0
        colour = colour + 1
      endif
    endif
  endif 
    
  if path0 == 0
    warn = true
  elseif path1 == 0
    warn = true 
  endif

 
  endwhile
  
  
  
  
  
  
  
  
  ; -------------------------------
  ; -------------------------------
  ; -------------------------------
  
  
  
  
  
  
  
  
  elseif mode == 1
  
  z = #pixel
  ztest = z
      
  ; -------------------------
  
  bail = false
  x = real(ztest)
  y = imag(ztest)
  
  ; Test the base line of the
  ; triangle.
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y > 0
    bail = true
  endif
    
  
  ; Store the bail value
  bail0 = bail
  bail = false
  
  
  ; -------------------------

  ; Test the left side of the
  ; triangle.
  
  ztest = ztest*exp(-1i*pi/2)
  x = real(ztest)
  y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y < m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y < m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y < m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y < m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y < m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y < m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y < m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y < m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y < m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y < m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y < m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y < m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y < m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y < m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y < m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y < m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y < m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y < m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y < 0
    bail = true
  endif
    
  
  ; Store the bail value
  bail1 = bail
  bail = false
  
  ; Restore the original value of ztest
  ztest = z
  
  
    ; -------------------------

  ; Test the right part of the right side 
  ; of the triangle.
  
  ztest = ztest - 1
  ztest = ztest*exp(1i*pi/4)
  ztest = ztest*sqrt(2)
  ztest = ztest + 1
  
  if real(ztest) > 0   
  
  x = real(ztest)
  y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y < m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y < m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y < m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y < m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y < m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y < m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y < m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y < m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y < m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y < m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y < m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y < m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y < m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y < m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y < m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y < m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y < m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y < m1112*x + h1112
      bail = !bail
    endif
  endif

  
  ; Left part of the right side
  else
  
  ztest = -ztest
  x = real(ztest)
  y = imag(ztest)
   
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  endif
    
  ; Store the bail value
  bail2 = bail
  bail = false
  
  ; Bails out the shape.
  endbail = true
  zz = z
  if !(bail0 && bail1 && bail2)
    #solid = true
    endbail = false

  endif



  endif
  col = colour - round(colour/3)*3
  if mode != 2
    
    ; Apply Translation, Rotation and 
    ; Magnification 
    zz = zz + @center*@magn
    zz = zz*exp(-1i*pi/180*@rot)
    zz = zz/@magn
  elseif mode == 2
    if col == 0
      zz = @colpoint1
    elseif col == 1
      zz = @colpoint2
    elseif col == -1
      zz = @colpoint3
    endif
  endif
  #pixel = zz
  
  if mode == 3 && col == 0
    #solid = true
  elseif mode == 4 && col == 1
    #solid = true
  elseif mode == 5 && col == -1
    #solid = true
  elseif mode == 6 && (col == 1 || col == -1)
    #solid = true
  elseif mode == 7 && (col == -1 || col == 0)
    #solid = true
  elseif mode == 8 && (col == 0 || col == 1)
    #solid = true
  endif
  
  if !endbail
    #solid = true
  endif 
          
default:
  title = "Octagon Limit I"
  helpfile = "sam-help/octlim.htm"
  param mode
    caption = "Mode"
    default = 0
    enum = "Mapping" "Shape Only" "Color" \
           "Tiles 1 Solid" "Tiles 2 Solid" \
           "Tiles 3 Solid" "Tiles 2 and 3 Solid" \
           "Tiles 3 and 1 Solid" "Tiles 1 and 2 Solid"
  endparam
  param niter
    caption = "Number of Iterations"
    default = 30
  endparam
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param magn
    caption = "Magnification"
    default = 1.0
  endparam
  param colpoint1
    caption = "Color 1"
    default = (0,0)
  endparam
  param colpoint2
    caption = "Color 2"
    default = (1,0)
  endparam
  param colpoint3
    caption = "Color 3"
    default = (2,0)
  endparam
  param p1
    caption = "Point 1"
    default = (1,0)
  endparam
  param p2
    caption = "Point 2"
    default = (1,0)
  endparam
  param p3
    caption = "Point 3"
    default = (1,0)
  endparam
  param p4
    caption = "Point 4"
    default = (1,0)
  endparam
  param p5
    caption = "Point 5"
    default = (1,0)
  endparam
  param p6
    caption = "Point 6"
    default = (1,0)
  endparam
  param p7
    caption = "Point 7"
    default = (1,0)
  endparam
  param p8
    caption = "Point 8"
    default = (1,0)
  endparam
  param p9
    caption = "Point 9"
    default = (1,0)
  endparam
  param p10
    caption = "Point 10"
    default = (1,0)
  endparam
}

RadialDitheringRandom {
transform:
  z = #pixel - @center
  z = z*exp(1i*pi/180*@rot)
  float arg = abs(atan2(z))/pi
  float angs = @angsol/360
  float angt = @angtran/360
  arg = arg/(1-angs-angt) - angs/(1-angs-angt) 
  float x = imag(#random)
  if arg < x
    #solid = true
  endif
default:
  title = "Radial Dithering (random)"
  helpfile = "sam-help/varioustrans.htm"
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param angsol
    caption = "Fully Solid Angle"
    default = 0.0
  endparam
  param angtran
    caption = "Fully Transparent Angle"
    default = 0.0
  endparam
}

OctogonalSliceMapping {
transform:
   z = 0
  float arg = 0
  float angle = @angle*pi/180
  
  z = #pixel
  arg = atan2(z)
  if arg > pi/2
    z = -1i*z
  elseif arg > -pi/2 && arg < 0
    z = 1i*z
  elseif arg < -pi/2
    z = -z
  endif
  arg = atan2(z)
  if arg > pi/2 - angle
    z = z*exp(-1i*pi/2)
  elseif arg < pi/2 - angle && arg > angle
    z = z*exp(-1i*pi/4)
    z = z*cos(angle)/cos(pi/4-angle)
  endif
  #pixel = z*exp(1i*pi/180*@rot)
default:
  title = "Octagonal (Slices) Mapping"
  param angle
    caption = "Angle"
    default = 26.6
  endparam
  param rot 
    caption = "Rotation"
    default = 0.0
  endparam
}

LinearDitheringRandom {
; By Samuel Monnier, 16.3.00
transform:
  z = #pixel - @left
  right = @right - @left
  z = z*exp(1i*pi/180*@rot)
  right = right*exp(1i*pi/180*@rot)
  right = real(right)
  z = z/cabs(right)
  if right < 0
    z = -z
  endif
  float x = real(z)
  float y = imag(#random)
  if x < y
    #solid = true
  endif
default:
  title = "Linear Dithering (random)"
  helpfile = "sam-help/varioustrans.htm"
  helptopic = "lindith"
  param left
    caption = "Solid Edge"
    default = (-1,0)
  endparam
  param right
    caption = "Transparent Edge"
    default = (1,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
}

<<Family>>Mapping {
; By Samuel Monnier, 20.3.00
transform:
  z = #pixel
  tilesel1 = 0
  tilesel2 = 0
  tilesel3 = 0
  tilesel4 = 0
  ztest = 0
  bool test = false
  
  z = z - @tilem
  z = z*exp(1i*pi/180*@rottile)
  if @mode == 0 || @mode == 1
    tilesel1 = @tilesel1 - @tilem
    tilesel1 = tilesel1*exp(1i*pi/180*@rottile)
    tilesel2 = @tilesel2 - @tilem
    tilesel2 = tilesel2*exp(1i*pi/180*@rottile)
    tilesel3 = @tilesel3 - @tilem
    tilesel3 = tilesel3*exp(1i*pi/180*@rottile)
    tilesel4 = @tilesel4 - @tilem
    tilesel4 = tilesel4*exp(1i*pi/180*@rottile)
  endif
  
  zc = round(z/@sizesq)*@sizesq
  if @mode == 2 || @mode == 3
    ztest = round(z/(2*@sizesq))*2*@sizesq
    if zc == ztest
      test = true
    endif
  elseif @mode == 4 || @mode == 5
    ztest = z-round(z/(2*@sizesq))*2*@sizesq
    if (abs(real(ztest)) > @sizesq/2 && abs(imag(ztest)) < @sizesq/2) || \
       (abs(real(ztest)) < @sizesq/2 && abs(imag(ztest)) > @sizesq/2)
      test = true
    endif
  endif
  
  if @mode == 0 || @mode == 1
    tilesel1 = round(tilesel1/@sizesq)*@sizesq
    tilesel2 = round(tilesel2/@sizesq)*@sizesq
    tilesel3 = round(tilesel3/@sizesq)*@sizesq
    tilesel4 = round(tilesel4/@sizesq)*@sizesq
  endif
  
  z = z*exp(-1i*pi/180*@rottile)
  zc = zc*exp(-1i*pi/180*@rottile)
  if @mode == 0 || @mode == 1
    tilesel1 = tilesel1*exp(-1i*pi/180*@rottile)
    tilesel2 = tilesel2*exp(-1i*pi/180*@rottile)
    tilesel3 = tilesel3*exp(-1i*pi/180*@rottile)
    tilesel4 = tilesel4*exp(-1i*pi/180*@rottile)
  endif
  
  z = z + @tilem
  zc = zc + @tilem
  if @mode == 0 || @mode == 1
    tilesel1 = tilesel1 + @tilem
    tilesel2 = tilesel2 + @tilem
    tilesel3 = tilesel3 + @tilem
    tilesel4 = tilesel4 + @tilem
  endif
  
  z = 2*(z - zc)/@sizesq 
  
  z = z*exp(1i*pi/180*@rottile)
  
  if @mode == 0
    if zc == tilesel1 || zc == tilesel2 || \
       zc == tilesel3 || zc == tilesel4
      #solid = true
    endif
  elseif @mode == 1
    if zc != tilesel1 && zc != tilesel2 && \
       zc != tilesel3 && zc != tilesel4
      #solid = true
    endif
  elseif @mode == 2 || @mode == 4
    if test == true
      #solid = true
    endif
  elseif @mode == 3 || @mode == 5
    if test == true
    else
      #solid = true
    endif
  elseif @mode == 6
    if imag(zc) < imag(@tilesel1)
      #solid = true
    endif
  elseif @mode == 7
    if imag(zc) > imag(@tilesel1)
      #solid = true
    endif
  elseif @mode == 8
    if real(zc) < real(@tilesel1)
      #solid = true
    endif
  elseif @mode == 9
    if real(zc) > real(@tilesel1)
      #solid = true
    endif
  endif
  
default:
  title = "<<Family>> Mapping"
  helpfile = "sam-help/julifamily.htm"
  helptopic = "fammap"
  
  param mode
    caption = "Mode"
    default = 0
    enum = "Selected Tiles Solid" "Unselected Tiles Solid" \
           "Gird In" "Gird Out" "Checkerboard In" "Checkerboard Out" \
           "Above Tile 1" "Below Tile 1" "Right from Tile 1" \
           "Left from Tile 1"
  endparam
    
  param tilesel1
    caption = "Selected Tile 1"
    default = (1e20,0)
  endparam
  param tilesel2
    caption = "Selected Tile 2"
    default = (1e20,0)
  endparam
  param tilesel3
    caption = "Selected Tile 3"
    default = (1e20,0)
  endparam
  param tilesel4
    caption = "Selected Tile 4"
    default = (1e20,0)
  endparam
  
  param tilem
    caption = "Tiling displacement"
    default = (0,0)
    hint = "Use the same value as in the formula"
  endparam

  param sizesq
    caption = "Size of the tiles"
    default = 0.6
    hint = "Use the same value as in the formula"
  endparam

  param rottile
    caption = "Tiling rotation"
    default = 0.0
    hint = "Use the same value as in the formula"
  endparam
}

SquareLimit {
; By Samuel Monnier, (...)-> 27.4.00
transform:
  z = #pixel
  arg = atan2(z)
  zz = 0
  ztest = 0
  float x = real(z)
  float y = imag(z)
  float col = 0 
  bool bail = false
  bool bail0 = false
  bool bail1 = false
  bool bail2 = false
  bool bailtr = false
  bool endbail = false
  bool warn = false
  bool leftright = false
  bool modsq = false
  bool warninvertcol = false
  bool firstj = false
  bool bhalf = false
  bool tileflag = false
  int path = 0
  int path0 = 3
  int path1 = 3
  int colour = 0
  ; Define the points
  float x1 = 0
  float y1 = 0
  float x2 = real(@p1)
  float y2 = imag(@p1)
  float x3 = real(@p2)
  float y3 = imag(@p2)
  float x4 = real(@p3)
  float y4 = imag(@p3)
  float x5 = real(@p4)
  float y5 = imag(@p4)
  float x6 = real(@p5)
  float y6 = imag(@p5)
  float x7 = real(@p6)
  float y7 = imag(@p6)
  float x8 = real(@p7)
  float y8 = imag(@p7)
  float x9 = real(@p8)
  float y9 = imag(@p8)
  float x10 = real(@p9)
  float y10 = imag(@p9)
  float x11 = real(@p10)
  float y11 = imag(@p10)
  float x12 = 1
  float y12 = 0
  ; Compute the slopes and the height
  float m12 = (y2-y1)/(x2-x1)
  float h12 = (x2*y1-x1*y2)/(x2-x1)
  float m23 = (y3-y2)/(x3-x2)
  float h23 = (x3*y2-x2*y3)/(x3-x2)
  float m34 = (y4-y3)/(x4-x3)
  float h34 = (x4*y3-x3*y4)/(x4-x3)
  float m45 = (y5-y4)/(x5-x4)
  float h45 = (x5*y4-x4*y5)/(x5-x4)
  float m56 = (y6-y5)/(x6-x5)
  float h56 = (x6*y5-x5*y6)/(x6-x5)
  float m67 = (y7-y6)/(x7-x6)
  float h67 = (x7*y6-x6*y7)/(x7-x6)
  float m78 = (y8-y7)/(x8-x7)
  float h78 = (x8*y7-x7*y8)/(x8-x7)
  float m89 = (y9-y8)/(x9-x8)
  float h89 = (x9*y8-x8*y9)/(x9-x8)
  float m910 = (y10-y9)/(x10-x9)
  float h910 = (x10*y9-x9*y10)/(x10-x9)
  float m1011 = (y11-y10)/(x11-x10)
  float h1011 = (x11*y10-x10*y11)/(x11-x10)
  float m1112 = (y12-y11)/(x12-x11)
  float h1112 = (x12*y11-x11*y12)/(x12-x11)
  int i = 0
  int j = 0
    
  mode = @mode
  if mode != 1 && abs(real(#pixel)) < 2 \
     && abs(imag(#pixel)) < 2
  
  ; Sets up the first symetry
  if arg > pi/2
    z = z*exp(-1i*pi/2)
    colour = 1
  elseif arg < 0 && arg > -pi/2
    z = z*exp(1i*pi/2)
    colour = 1
  elseif arg < -pi/2
    z = z*exp(1i*pi)
  endif
  
  if atan2(z) < pi/4
    bhalf = true
  endif
  
  ; To get a square instead of an octogon
  zz = z
  while j < @niter/2
    j = j + 1
    ztest = z
    x = real(ztest)
    y = imag(ztest)
    if x > 2*(2^j-1)/2^j && y > 2*(2^j-1)/2^j
      if j == 1
        colour = colour - 1
        firstj = true
      else
        firstj = false
      endif
      if j > 1 && arg > pi/2
        colour = colour + 1
      endif
      ztest = ztest - (2*(2^j-1)/2^j + 1/2^(j+1))*(1,1)
      ztest = ztest*exp(1i*pi/4)
      ztest = sqrt(2)*2^j*ztest
      arg = atan2(ztest)
      if arg > pi/2
        ztest = ztest*exp(-1i*pi/2)
        colour = colour - 1
        tileflag = true
      elseif arg < 0 && arg > -pi/2
        ztest = ztest*exp(1i*pi/2)
        colour = colour - 1
        warn = true
        tileflag = true
        if j == 1
          warninvertcol = true
        endif
      elseif arg < -pi/2
        ztest = ztest*exp(1i*pi)
        warn = true
        if j > 1
          warninvertcol = true
        endif
        tileflag = false
      else
        tileflag = false
      endif
      zz = ztest
      modsq = true
    else
      z = zz
    endif
  endwhile
  
  
  ; Begin the transformation 
  i = 0
  while i < @niter
  
  i = i + 1
  j = j + 1
  ztest = z
      
  ; -------------------------
  
  bail = false
  x = real(ztest)
  y = imag(ztest)
  
  ; Test the base line of the
  ; triangle.
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y > 0
    bail = true
  endif
    
  
  ; Store the bail value
  bail0 = bail
  bail = false
  
  
  ; -------------------------

  ; Test the left side of the
  ; triangle.
  
  ztest = ztest*exp(-1i*pi/2)
  x = real(ztest)
  y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y < m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y < m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y < m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y < m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y < m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y < m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y < m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y < m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y < m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y < m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y < m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y < m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y < m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y < m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y < m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y < m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y < m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y < m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y < 0
    bail = true
  endif
    
  
  ; Store the bail value
  bail1 = bail
  bail = false
  
  ; Restore the original value of ztest
  ztest = z
  
  
    ; -------------------------

  ; Test the right part of the right side 
  ; of the triangle.
  
  ztest = ztest - 1
  ztest = ztest*exp(1i*pi/4)
  ztest = ztest*sqrt(2)
  ztest = ztest + 1
  
  if real(ztest) > 0   
  
  x = real(ztest)
  y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y < m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y < m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y < m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y < m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y < m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y < m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y < m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y < m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y < m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y < m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y < m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y < m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y < m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y < m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y < m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y < m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y < m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y < m1112*x + h1112
      bail = !bail
    endif
  endif

  
  ; Left part of the right side
  else
  
  ztest = -ztest
  x = real(ztest)
  y = imag(ztest)
   
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  endif
    
  ; Store the bail value
  bail2 = bail
  bail = false
  
    ; Bails out the shape.
    if bail0 && bail1 && bail2
      endbail = true
      zz = z
      i = @niter
    endif


    ; Performs the iterative transformation
    ; Must do another big test... (sorry)
    ztest = z
    ztest = ztest - (.5,.5)
    ztest = ztest*exp(-1i*pi/4)
    ztest = ztest*sqrt(2)
    
    x = real(ztest)
    y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y > 0
    bail = true
  endif
    
  
  ; Store the bail value
  bailtr = bail
  bail = false
  
  if !warn && (bail0 && bail1) 
    ; Transform
    if !bail2 && !bailtr
      colour = colour + 1
      path = path + 1
      path0 = path0 + 1
      path1 = path1 - 1
      z = z - 1
      z = z*exp(1i*pi/4)
      z = sqrt(2)*z + 1
      if i == 1
        leftright = true
      endif
    elseif !bail2 && bailtr
      colour = colour - 1
      path = path - 1
      path0 = path0 - 1
      path1 = path1 + 1
      z = z - 1i
      z = z*exp(-1i*pi/4)
      z = sqrt(2)*z + 1i
    endif
    if path0 > 3
      path0 = 3
    elseif path1 > 3
      path1 = 3
    endif
  endif
  
  ; To fix a problem with the 
  ; four big central tiles
  if i == 1 && !bail1 && !modsq
    z = z*exp(-1i*pi/2)
    if colour == 1
      colour = 0
    else
      colour = 1
    endif
  elseif i == 1 && !bail1 && modsq
    z = z*exp(-1i*pi/2)
    if bhalf && firstj
      colour = colour - 1
    elseif bhalf && !firstj
    
    else
      colour = colour + 1
    endif
    if !tileflag && !firstj
      colour = colour - 1
    endif
  elseif i == 1 && !bail0 && !modsq
    z = z*exp(1i*pi/2)
    if colour == 1
      colour = 0
    else
      colour = 1
    endif
  elseif i == 1 && !bail0 && modsq
    z = z*exp(1i*pi/2)
    if bhalf && firstj
      colour = colour - 1
    elseif bhalf && !firstj

    else
      colour = colour + 1
    endif
    if !tileflag && !firstj
      colour = colour - 1
    endif
  endif
  
  ; To fix another little problem    
  if warn && !endbail
    z = z - (.5,.5)
    z = -z
    z = z + (.5,.5)
    if path0 > 0
      if warninvertcol
        colour = colour + 1
      else
        colour = colour - 1
      endif
    elseif path0 == 0
      if warninvertcol
        colour = colour - 1
      else
        colour = colour + 1
      endif
    endif
    if .5*real(abs(#pixel))-1 < -imag(abs(#pixel))
      if path0 > 0
        if warninvertcol
          colour = colour + 1
        else
          colour = colour - 1
        endif
      elseif path0 == 0
        if warninvertcol
          colour = colour - 1
        else
          colour = colour + 1
        endif
      endif
    endif
  endif 
  
  if path0 == 0
    warn = true
  elseif path1 == 0
    warn = true 
  endif
  
  ; To draw a square instead of an octogon
  if leftright == true
    if modsq == true
      if path > 1
        warn = true
        if firstj && bhalf
          warninvertcol = true
        endif
      endif
    else
      if path < 0
        warn = true
        if firstj && bhalf
          warninvertcol = true
        endif
      endif
    endif
  elseif leftright == false
    if modsq == true
      if path < -1
        warn = true
        if bhalf || !firstj
          warninvertcol = true
        endif
      endif
    else
      if path > 0
        warn = true
        if !firstj
          warninvertcol = true
        endif
      endif
    endif
  endif
  
  if path0 == 0 && !modsq
    warn = true
    if warninvertcol == true
      warninvertcol = false
    endif
  elseif path1 == 0 && !modsq  
    warn = true 
    if warninvertcol == true
      warninvertcol = false
    endif
  endif
      
  endwhile
  
  
  
  
  
  
  
  
  ; -------------------------------
  ; -------------------------------
  ; -------------------------------
  
  
  
  
  
  
  
  
  elseif mode == 1 && abs(real(#pixel)) < 2 \
     && abs(imag(#pixel)) < 2
  
  z = #pixel
  ztest = z
      
  ; -------------------------
  
  bail = false
  x = real(ztest)
  y = imag(ztest)
  
  ; Test the base line of the
  ; triangle.
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y > 0
    bail = true
  endif
    
  
  ; Store the bail value
  bail0 = bail
  bail = false
  
  
  ; -------------------------

  ; Test the left side of the
  ; triangle.
  
  ztest = ztest*exp(-1i*pi/2)
  x = real(ztest)
  y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y < m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y < m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y < m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y < m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y < m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y < m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y < m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y < m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y < m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y < m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y < m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y < m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y < m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y < m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y < m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y < m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y < m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y < m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y < 0
    bail = true
  endif
    
  
  ; Store the bail value
  bail1 = bail
  bail = false
  
  ; Restore the original value of ztest
  ztest = z
  
  
    ; -------------------------

  ; Test the right part of the right side 
  ; of the triangle.
  
  ztest = ztest - 1
  ztest = ztest*exp(1i*pi/4)
  ztest = ztest*sqrt(2)
  ztest = ztest + 1
  
  if real(ztest) > 0   
  
  x = real(ztest)
  y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y < m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y < m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y < m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y < m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y < m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y < m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y < m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y < m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y < m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y < m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y < m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y < m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y < m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y < m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y < m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y < m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y < m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y < m1112*x + h1112
      bail = !bail
    endif
  endif

  
  ; Left part of the right side
  else
  
  ztest = -ztest
  x = real(ztest)
  y = imag(ztest)
   
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  endif
    
  ; Store the bail value
  bail2 = bail
  bail = false
  
  ; Bails out the shape.
  endbail = true
  zz = z
  if !(bail0 && bail1 && bail2)
    #solid = true
    endbail = false

  endif



  endif
  
  col = colour - round(colour/3)*3  
  if mode != 2
    ; Apply Translation, Rotation and 
    ; Magnification 
    zz = zz + @center*@magn
    zz = zz*exp(-1i*pi/180*@rot)
    zz = zz/@magn
  elseif mode == 2 
    if col == 0
      zz = @colpoint1
    elseif col == 1
      zz = @colpoint2
    elseif col == -1
      zz = @colpoint3
    endif
  endif
  
  if mode == 3 && col == 0
    #solid = true
  elseif mode == 4 && col == 1
    #solid = true
  elseif mode == 5 && col == -1
    #solid = true
  elseif mode == 6 && (col == 1 || col == -1)
    #solid = true
  elseif mode == 7 && (col == -1 || col == 0)
    #solid = true
  elseif mode == 8 && (col == 0 || col == 1)
    #solid = true
  endif
  
  if !endbail || abs(real(#pixel)) > 2 \
     || abs(imag(#pixel)) > 2 
    #solid = true
  endif 
  
  #pixel = zz
          
default:
  title = "Square Limit"
  helpfile = "sam-help/octlim.htm"
  helptopic = "squarelim"
  param mode
    caption = "Mode"
    default = 0
    enum = "Mapping" "Shape Only" "Color" \
           "Tiles 1 Solid" "Tiles 2 Solid" \
           "Tiles 3 Solid" "Tiles 2 and 3 Solid" \
           "Tiles 3 and 1 Solid" "Tiles 1 and 2 Solid"
  endparam
  param niter
    caption = "Number of Iterations"
    default = 30
  endparam
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param magn
    caption = "Magnification"
    default = 1.0
  endparam
  param colpoint1
    caption = "Color 1"
    default = (0,0)
  endparam
  param colpoint2
    caption = "Color 2"
    default = (1,0)
  endparam
  param colpoint3
    caption = "Color 3"
    default = (2,0)
  endparam
  param p1
    caption = "Point 1"
    default = (1,0)
  endparam
  param p2
    caption = "Point 2"
    default = (1,0)
  endparam
  param p3
    caption = "Point 3"
    default = (1,0)
  endparam
  param p4
    caption = "Point 4"
    default = (1,0)
  endparam
  param p5
    caption = "Point 5"
    default = (1,0)
  endparam
  param p6
    caption = "Point 6"
    default = (1,0)
  endparam
  param p7
    caption = "Point 7"
    default = (1,0)
  endparam
  param p8
    caption = "Point 8"
    default = (1,0)
  endparam
  param p9
    caption = "Point 9"
    default = (1,0)
  endparam
  param p10
    caption = "Point 10"
    default = (1,0)
  endparam
}

smaller&smaller {
; By Samuel Monnier, 5.5.00

transform:
  z = #pixel*1.2
  arg = atan2(z)
  zz = 0
  ztest = 0
  float x = real(z)
  float y = imag(z) 
  bool bail = false
  bool bail0 = false
  bool bail1 = false
  bool bail2 = false
  bool bailtr = false
  bool endbail = false
  bool warn = false
  bool mir = false
  float col = 0
  int path0 = 0
  int path1 = 0
  int colour = 0
  ; Define the points
  float x1 = 0
  float y1 = 0
  float x2 = real(@p1)
  float y2 = imag(@p1)
  float x3 = real(@p2)
  float y3 = imag(@p2)
  float x4 = real(@p3)
  float y4 = imag(@p3)
  float x5 = real(@p4)
  float y5 = imag(@p4)
  float x6 = real(@p5)
  float y6 = imag(@p5)
  float x7 = real(@p6)
  float y7 = imag(@p6)
  float x8 = real(@p7)
  float y8 = imag(@p7)
  float x9 = real(@p8)
  float y9 = imag(@p8)
  float x10 = real(@p9)
  float y10 = imag(@p9)
  float x11 = real(@p10)
  float y11 = imag(@p10)
  float x12 = 1
  float y12 = 0
  ; Compute the slopes and the height
  float m12 = (y2-y1)/(x2-x1)
  float h12 = (x2*y1-x1*y2)/(x2-x1)
  float m23 = (y3-y2)/(x3-x2)
  float h23 = (x3*y2-x2*y3)/(x3-x2)
  float m34 = (y4-y3)/(x4-x3)
  float h34 = (x4*y3-x3*y4)/(x4-x3)
  float m45 = (y5-y4)/(x5-x4)
  float h45 = (x5*y4-x4*y5)/(x5-x4)
  float m56 = (y6-y5)/(x6-x5)
  float h56 = (x6*y5-x5*y6)/(x6-x5)
  float m67 = (y7-y6)/(x7-x6)
  float h67 = (x7*y6-x6*y7)/(x7-x6)
  float m78 = (y8-y7)/(x8-x7)
  float h78 = (x8*y7-x7*y8)/(x8-x7)
  float m89 = (y9-y8)/(x9-x8)
  float h89 = (x9*y8-x8*y9)/(x9-x8)
  float m910 = (y10-y9)/(x10-x9)
  float h910 = (x10*y9-x9*y10)/(x10-x9)
  float m1011 = (y11-y10)/(x11-x10)
  float h1011 = (x11*y10-x10*y11)/(x11-x10)
  float m1112 = (y12-y11)/(x12-x11)
  float h1112 = (x12*y11-x11*y12)/(x12-x11)
  int i = 0
  mode = @mode
  if mode != 1
  
  ; Sets up the first symetry
  if arg > pi/2
    z = z*exp(-1i*pi/2)
  elseif arg < 0 && arg > -pi/2
    z = z*exp(1i*pi/2)
  elseif arg < -pi/2
    z = z*exp(1i*pi)
  endif
  arg = atan2(z)
  if arg < pi/4
    z = z-1
    z = (1,1) - z
    mir = true
  else
    z = z-1i
    z = (1,1) - z
  endif
 
  
  ; Begin the transformation 
  i = 0
  while i < @niter
  
  i = i + 1
  ztest = z
      
  ; -------------------------
  
  bail = false
  x = real(ztest)
  y = imag(ztest)
  
  ; Test the base line of the
  ; triangle.
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y > 0
    bail = true
  endif
    
  
  ; Store the bail value
  bail0 = bail
  bail = false
  
  
  ; -------------------------

  ; Test the left side of the
  ; triangle.
  
  ztest = ztest*exp(-1i*pi/2)
  x = real(ztest)
  y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y < m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y < m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y < m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y < m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y < m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y < m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y < m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y < m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y < m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y < m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y < m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y < m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y < m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y < m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y < m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y < m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y < m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y < m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y < 0
    bail = true
  endif
    
  
  ; Store the bail value
  bail1 = bail
  bail = false
  
  ; Restore the original value of ztest
  ztest = z
  
  
    ; -------------------------

  ; Test the right part of the right side 
  ; of the triangle.
  
  ztest = ztest - 1
  ztest = ztest*exp(1i*pi/4)
  ztest = ztest*sqrt(2)
  ztest = ztest + 1
  
  if real(ztest) > 0   
  
  x = real(ztest)
  y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y < m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y < m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y < m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y < m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y < m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y < m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y < m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y < m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y < m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y < m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y < m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y < m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y < m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y < m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y < m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y < m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y < m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y < m1112*x + h1112
      bail = !bail
    endif
  endif

  
  ; Left part of the right side
  else
  
  ztest = -ztest
  x = real(ztest)
  y = imag(ztest)
   
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  endif
    
  ; Store the bail value
  bail2 = bail
  bail = false
  
    ; Bails out the shape.
    if bail0 && bail1 && bail2
      endbail = true
      zz = z
      i = @niter
    endif


    ; Performs the iterative transformation
    ; Must do another big test... (sorry)
    ztest = z
    ztest = ztest - (.5,.5)
    ztest = ztest*exp(-1i*pi/4)
    ztest = ztest*sqrt(2)
    
    x = real(ztest)
    y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y > 0
    bail = true
  endif
    
  
  ; Store the bail value
  bailtr = bail
  bail = false
  
  if !warn && (bail0 && bail1) 
    ; Transform
    if !bail2 && !bailtr
      colour = colour + 1
      path0 = path0 + 1
      path1 = 0
      z = z - 1
      z = z*exp(1i*pi/4)
      z = sqrt(2)*z + 1
    elseif !bail2 && bailtr
      colour = colour - 1
      path0 = 0
      path1 = path1 + 1
      z = z - 1i
      z = z*exp(-1i*pi/4)
      z = sqrt(2)*z + 1i
    endif
;    if path0 > 2
;      path0 = 2
;    elseif path1 > 2
;      path1 = 2
;    endif
  endif
  
  ; To fix a problem with the 
  ; four big central tiles
  if i == 1 && !bail1
    if !mir
      z = z*exp(-1i*pi/2)
      warn = true
    endif
  elseif (i == 1 || i == 2)&& !bail0
    if mir
      z = z*exp(1i*pi/2)
      warn = true
    endif
  endif
  
  ; To fix another little problem    
  if warn && !endbail
    z = z - (.5,.5)
    z = -z
    z = z + (.5,.5)
    if mir
      colour = colour - 1
    else
      colour = colour + 1
    endif
  endif 
    
  if path0 == 2
    warn = true
  elseif path1 == 2
    warn = true 
  endif

  if i == 1 && !mir && path0 == 1
    warn = true
  elseif i == 1 && mir && path1 == 1
    warn = true
  endif
    
    
  endwhile
  
  
  
  
  
  
  
  
  ; -------------------------------
  ; -------------------------------
  ; -------------------------------
  
  
  
  
  
  
  
  
  elseif mode == 1
  
  z = #pixel
  ztest = z
      
  ; -------------------------
  
  bail = false
  x = real(ztest)
  y = imag(ztest)
  
  ; Test the base line of the
  ; triangle.
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y > 0
    bail = true
  endif
    
  
  ; Store the bail value
  bail0 = bail
  bail = false
  
  
  ; -------------------------

  ; Test the left side of the
  ; triangle.
  
  ztest = ztest*exp(-1i*pi/2)
  x = real(ztest)
  y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y < m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y < m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y < m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y < m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y < m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y < m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y < m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y < m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y < m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y < m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y < m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y < m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y < m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y < m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y < m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y < m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y < m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y < m1112*x + h1112
      bail = !bail
    endif
  endif
  
  ; If z is "beside" the segment 
  if (x < 0 || x > 1) && y < 0
    bail = true
  endif
    
  
  ; Store the bail value
  bail1 = bail
  bail = false
  
  ; Restore the original value of ztest
  ztest = z
  
  
    ; -------------------------

  ; Test the right part of the right side 
  ; of the triangle.
  
  ztest = ztest - 1
  ztest = ztest*exp(1i*pi/4)
  ztest = ztest*sqrt(2)
  ztest = ztest + 1
  
  if real(ztest) > 0   
  
  x = real(ztest)
  y = imag(ztest)
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y < m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y < m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y < m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y < m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y < m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y < m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y < m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y < m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y < m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y < m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y < m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y < m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y < m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y < m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y < m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y < m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y < m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y < m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y < m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y < m1112*x + h1112
      bail = !bail
    endif
  endif

  
  ; Left part of the right side
  else
  
  ztest = -ztest
  x = real(ztest)
  y = imag(ztest)
   
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  endif
    
  ; Store the bail value
  bail2 = bail
  bail = false
  
  ; Bails out the shape.
  endbail = true
  zz = z
  if !(bail0 && bail1 && bail2)
    #solid = true
    endbail = false

  endif



  endif
  col = colour - round(colour/3)*3
  if mode != 2
    
    ; Apply Translation, Rotation and 
    ; Magnification 
    zz = zz + @center*@magn
    zz = zz*exp(-1i*pi/180*@rot)
    zz = zz/@magn
  elseif mode == 2
    if col == 0
      zz = @colpoint1
    elseif col == 1
      zz = @colpoint2
    elseif col == -1
      zz = @colpoint3
    endif
  endif
  #pixel = zz
  
  if mode == 3 && col == 0
    #solid = true
  elseif mode == 4 && col == 1
    #solid = true
  elseif mode == 5 && col == -1
    #solid = true
  elseif mode == 6 && (col == 1 || col == -1)
    #solid = true
  elseif mode == 7 && (col == -1 || col == 0)
    #solid = true
  elseif mode == 8 && (col == 0 || col == 1)
    #solid = true
  endif
  
  if !endbail
    #solid = true
  endif 
          
default:
  title = "Smaller & Smaller"
  helpfile = "sam-help/octlim.htm"
  helptopic = "sands"
  param mode
    caption = "Mode"
    default = 0
    enum = "Mapping" "Shape Only" "Color" \
           "Tiles 1 Solid" "Tiles 2 Solid" \
           "Tiles 3 Solid" "Tiles 2 and 3 Solid" \
           "Tiles 3 and 1 Solid" "Tiles 1 and 2 Solid"
  endparam
  param niter
    caption = "Number of Iterations"
    default = 30
  endparam
  param center
    caption = "Center"
    default = (0,0)
  endparam
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  param magn
    caption = "Magnification"
    default = 1.0
  endparam
  param colpoint1
    caption = "Color 1"
    default = (0,0)
  endparam
  param colpoint2
    caption = "Color 2"
    default = (1,0)
  endparam
  param colpoint3
    caption = "Color 3"
    default = (2,0)
  endparam
  param p1
    caption = "Point 1"
    default = (1,0)
  endparam
  param p2
    caption = "Point 2"
    default = (1,0)
  endparam
  param p3
    caption = "Point 3"
    default = (1,0)
  endparam
  param p4
    caption = "Point 4"
    default = (1,0)
  endparam
  param p5
    caption = "Point 5"
    default = (1,0)
  endparam
  param p6
    caption = "Point 6"
    default = (1,0)
  endparam
  param p7
    caption = "Point 7"
    default = (1,0)
  endparam
  param p8
    caption = "Point 8"
    default = (1,0)
  endparam
  param p9
    caption = "Point 9"
    default = (1,0)
  endparam
  param p10
    caption = "Point 10"
    default = (1,0)
  endparam
}

Smaller&SmallerScissor {
; By Samuel Monnier, 6.5.00
transform:
  z = #pixel*1.2
  float arg = atan2(z)
  bool bail = false
  bool shortbail = false 
  ; Define the points
  float x1 = 0
  float y1 = 0
  float x2 = real(@p1)
  float y2 = imag(@p1)
  float x3 = real(@p2)
  float y3 = imag(@p2)
  float x4 = real(@p3)
  float y4 = imag(@p3)
  float x5 = real(@p4)
  float y5 = imag(@p4)
  float x6 = real(@p5)
  float y6 = imag(@p5)
  float x7 = real(@p6)
  float y7 = imag(@p6)
  float x8 = real(@p7)
  float y8 = imag(@p7)
  float x9 = real(@p8)
  float y9 = imag(@p8)
  float x10 = real(@p9)
  float y10 = imag(@p9)
  float x11 = real(@p10)
  float y11 = imag(@p10)
  float x12 = 1
  float y12 = 0
  ; Compute the slopes and the height
  float m12 = (y2-y1)/(x2-x1)
  float h12 = (x2*y1-x1*y2)/(x2-x1)
  float m23 = (y3-y2)/(x3-x2)
  float h23 = (x3*y2-x2*y3)/(x3-x2)
  float m34 = (y4-y3)/(x4-x3)
  float h34 = (x4*y3-x3*y4)/(x4-x3)
  float m45 = (y5-y4)/(x5-x4)
  float h45 = (x5*y4-x4*y5)/(x5-x4)
  float m56 = (y6-y5)/(x6-x5)
  float h56 = (x6*y5-x5*y6)/(x6-x5)
  float m67 = (y7-y6)/(x7-x6)
  float h67 = (x7*y6-x6*y7)/(x7-x6)
  float m78 = (y8-y7)/(x8-x7)
  float h78 = (x8*y7-x7*y8)/(x8-x7)
  float m89 = (y9-y8)/(x9-x8)
  float h89 = (x9*y8-x8*y9)/(x9-x8)
  float m910 = (y10-y9)/(x10-x9)
  float h910 = (x10*y9-x9*y10)/(x10-x9)
  float m1011 = (y11-y10)/(x11-x10)
  float h1011 = (x11*y10-x10*y11)/(x11-x10)
  float m1112 = (y12-y11)/(x12-x11)
  float h1112 = (x12*y11-x11*y12)/(x12-x11)
  
  
  ; Sets up the first symetry
  if abs(arg) < pi/4
    z = z*exp(1i*pi/2)
  elseif abs(arg) > 3*pi/4
    z = z*exp(-1i*pi/2)
  elseif arg < -pi/4 && arg > -3*pi/4
    z = z*exp(1i*pi)
  endif
  z = z - 2i
  if real(z) < -2
    shortbail = true
  elseif real(z) > -2 && real(z) < -1
    z = -z - 1
    bail = !bail
  elseif real(z) > -1 && real(z) < 0
    z = z + 1
  elseif real(z) > 0 && real(z) < 1
    z = -z + 1
    bail = !bail
  elseif real(z) > 1 && real(z) < 2
    z = z - 1
  elseif real(z) > 2
    shortbail = true
  endif
   
  if !shortbail
  
  x = real(z)
  y = imag(z)
  
  
  ; Point 1 - Point 2
  if x > x1 && x < x2
    if y > m12*x + h12 
      bail = !bail
    endif
  endif
  if x < x1 && x > x2
    if y > m12*x + h12
      bail = !bail
    endif
  endif
  
  ; Point 2 - Point 3
  if x > x2 && x < x3
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  if x < x2 && x > x3 
    if y > m23*x + h23 
      bail = !bail
    endif
  endif
  
  ; Point 3 - Point 4
  if x > x3 && x < x4
    if y > m34*x + h34 
      bail = !bail
    endif
  endif
  if x < x3 && x > x4 
    if y > m34*x + h34
      bail = !bail
    endif
  endif
  
  ; Point 4 - Point 5
  if x > x4 && x < x5
    if y > m45*x + h45 
      bail = !bail
    endif
  endif
  if x < x4 && x > x5 
    if y > m45*x + h45
      bail = !bail
    endif
  endif
  
  ; Point 5 - Point 6
  if x > x5 && x < x6
    if y > m56*x + h56 
      bail = !bail
    endif
  endif
  if x < x5 && x > x6 
    if y > m56*x + h56
      bail = !bail
    endif
  endif
  
  ; Point 6 - Point 7
  if x > x6 && x < x7
    if y > m67*x + h67 
      bail = !bail
    endif
  endif
  if x < x6 && x > x7 
    if y > m67*x + h67
      bail = !bail
    endif
  endif
  
  ; Point 7 - Point 8
  if x > x7 && x < x8
    if y > m78*x + h78 
      bail = !bail
    endif
  endif
  if x < x7 && x > x8 
    if y > m78*x + h78
      bail = !bail
    endif
  endif
  
  ; Point 8 - Point 9
  if x > x8 && x < x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  if x < x8 && x > x9
    if y > m89*x + h89 
      bail = !bail
    endif
  endif
  
  ; Point 9 - Point 10
  if x > x9 && x < x10
    if y > m910*x + h910 
      bail = !bail
    endif
  endif
  if x < x9 && x > x10 
    if y > m910*x + h910
      bail = !bail
    endif
  endif
  
  ; Point 10 - Point 11
  if x > x10 && x < x11
    if y > m1011*x + h1011 
      bail = !bail
    endif
  endif
  if x < x10 && x > x11
    if y > m1011*x + h1011
      bail = !bail
    endif
  endif
  
  ; Point 11 - Point 12
  if x > x11 && x < x12
    if y > m1112*x + h1112 
      bail = !bail
    endif
  endif
  if x < x11 && x > x12
    if y > m1112*x + h1112
      bail = !bail
    endif
  endif
  
  endif
  
   ; If z is "beside" the segment 
;  if (x < 0 || x > 1) && y < 0
;    bail = true
;  endif
  
  float reg = @reg
  if !bail && !shortbail && reg == 0
    #solid = true
  elseif (bail || shortbail) && reg == 1
    #solid = true
  endif  
  
default:
  title = "Smaller & Smaller Scissor"
  helpfile = "sam-help/varioustrans.htm"
  helptopic = "sandssc"
  
  param reg
    caption = "Solid Region"
    default = 0
    enum = "Inside" "Outside"
  endparam
  param p1
    caption = "Point 1"
    default = (1,0)
  endparam
  param p2
    caption = "Point 2"
    default = (1,0)
  endparam
  param p3
    caption = "Point 3"
    default = (1,0)
  endparam
  param p4
    caption = "Point 4"
    default = (1,0)
  endparam
  param p5
    caption = "Point 5"
    default = (1,0)
  endparam
  param p6
    caption = "Point 6"
    default = (1,0)
  endparam
  param p7
    caption = "Point 7"
    default = (1,0)
  endparam
  param p8
    caption = "Point 8"
    default = (1,0)
  endparam
  param p9
    caption = "Point 9"
    default = (1,0)
  endparam
  param p10
    caption = "Point 10"
    default = (1,0)
  endparam
}

GlassTiling {
; By Samuel Monnier, 13.5.00
transform:
  
  ; Performs preliminary 
  ; transformations
  z = #pixel-@shift
  z = z*exp(1i*pi/180*@rot)
  
  scale = 1/@size
  
  ; Center of the square containing z
  zc = round(scale*z)/scale
  
  ; Corners of this square
  zc1 = zc + (.5,.5)/scale
  zc2 = zc + (-.5,.5)/scale
  zc3 = zc + (.5,-.5)/scale
  zc4 = zc + (-.5,-.5)/scale
  
  ; Computes distances from the point
  ; to the corners 
  d1 = real(z - zc)*scale + 0.5
  d2 = 1 - d1
  d3 = imag(z - zc)*scale + 0.5
  d4 = 1 - d3
  
  ; Powers them...
  d1 = d1^@power
  d2 = d2^@power
  d3 = d3^@power
  d4 = d4^@power
  
  ; The new value of z
  z = (zc1*d1*d3 + zc3*d1*d4 + zc2*d2*d3 + zc4*d2*d4)
  z = z*exp(1i*@spin*d1*d2*d3*d4)
  
  ; "Undo" the preliminary 
  ; tramsformations
  z = z*exp(-1i*pi/180*@rot)
  #pixel = z + @shift
  
default:
  title = "Glass Tiling"
  
  param power
    caption = "Power"
    default = .8
  endparam
  
  param spin
    caption = "Spin"
    default = (0,0)
  endparam
  
  param size
    caption = "Tiling Size"
    default = .3
  endparam
   
  param shift
    caption = "Tiling Shift"
    default = (0,0)
  endparam
  
  param rot
    caption = "Tiling Rotation"
    default = 0.0
  endparam
}

Rings {
; By Samuel Monnier, 19.6.00 - 23.6.00
transform:
  ; Performs ragnification and rotation
  z = #pixel/@size*exp(-1i*pi/180*@rot)
  ; Coordinate of the tile
  zc = round(z)
  ; Coordinate of the point in the tile
  zz = z - zc
  zz2 = 0
  
  ; Initialization
  int tra = 0
  
  bool bail = false
  bool bail1 = false
  bool bail2 = false
  bool bail3 = false
  bool bail4 = false
  
  bool cb1 = false
  bool cb2 = false
  bool cb3 = false
  bool cb4 = false
  
  ; Determines which rings will be
  ; visible (global shape)
  if @smode == 0
    cb1 = true
    cb2 = true
    cb3 = true
    cb4 = true
  elseif @smode == 1
    if cabs(zc+(.5,.5)) < @r
      cb1 = true
    endif
    if cabs(zc+(-.5,.5)) < @r
      cb2 = true
    endif 
    if cabs(zc+(.5,-.5)) < @r
      cb3 = true
    endif
    if cabs(zc+(-.5,-.5)) < @r
      cb4 = true
    endif
  elseif @smode == 2
    if cabs(zc+(1,1)) < @r
      cb1 = true
    endif
    if cabs(zc+(0,1)) < @r
      cb2 = true
    endif 
    if cabs(zc+(1,0)) < @r
      cb3 = true
    endif
    if cabs(zc) < @r
      cb4 = true
    endif
  elseif @smode == 3
    if cabs(zc+(1,1)) < @r || real(zc) == -1 || imag(zc) == -1
      cb1 = true
    endif
    if cabs(zc+(0,1)) < @r || real(zc) == 0 || imag(zc) == -1
      cb2 = true
    endif 
    if cabs(zc+(1,0)) < @r || real(zc) == -1 || imag(zc) == 0
      cb3 = true
    endif
    if cabs(zc) < @r || real(zc) == 0 || imag(zc) == 0
      cb4 = true
    endif
  elseif @smode == 4
    if cabs(zc+(1,1)) < @r || real(zc) == -1 || imag(zc) == -1 \
       || real(zc)+imag(zc) == -2 || real(zc)-imag(zc) == 0
      cb1 = true
    endif
    if cabs(zc+(0,1)) < @r || real(zc) == 0 || imag(zc) == -1 \
       || real(zc)+imag(zc) == -1 || real(zc)-imag(zc) == 1
      cb2 = true
    endif 
    if cabs(zc+(1,0)) < @r || real(zc) == -1 || imag(zc) == 0 \
       || real(zc)+imag(zc) == -1 || real(zc)-imag(zc) == -1
      cb3 = true
    endif
    if cabs(zc) < @r || real(zc) == 0 || imag(zc) == 0 \
       || real(zc)+imag(zc) == 0 || real(zc)-imag(zc) == 0
      cb4 = true
    endif
    
  endif  
    
    
  ; Check if the points belongs to one of the 
  ; four rings crossing the tile  
  if cb1
    if cabs(zz-(.5,.5)) < @r1 
      tra = tra + 1
      if cabs(zz-(.5,.5)) > @r1 - @w
        bail = true
        bail1 = true
      endif
    endif
  endif
  
  if cb2
    if cabs(zz-(-.5,.5)) < @r1 
      tra = tra + 1
      if cabs(zz-(-.5,.5)) > @r1 - @w
        bail = true
        bail2 = true
      endif
    endif
  endif

  if cb3
    if cabs(zz-(.5,-.5)) < @r1 
      tra = tra + 1
      if cabs(zz-(.5,-.5)) > @r1 - @w
        bail = true
        bail3 = true
      endif
    endif
  endif
  
  if cb4  
    if cabs(zz-(-.5,-.5)) < @r1   
      tra = tra + 1
      if cabs(zz-(-.5,-.5)) > @r1 - @w
        bail = true
        bail4 = true
      endif
    endif
  endif
  
  ; The differents modes
  ; 0 and 1 : Scissor-like
  if @mode == 0
    if !bail
      #solid = true
    endif
  elseif @mode == 1
    if bail
      #solid = true
    endif
  ; 2 : Confuse code (must computes when
  ; one ring is "above" another). It works however...
  elseif @mode == 2
    if !bail
      #solid = true
    endif
    
    if bail1 && !bail3
      if bail4 && real(zz) > 0
        zz2 = zz-(-.5,-.5)
      else  
        zz2 = zz-(.5,.5)
      endif
    elseif bail2 && !bail1  
      if bail3 && real(zz) > 0
        zz2 = zz-(.5,-.5)
      else  
        zz2 = zz-(-.5,.5)
      endif
    elseif bail4 && !bail2  
      if bail1 && real(zz) > 0
        zz2 = zz-(.5,.5)
      else  
        zz2 = zz-(-.5,-.5)
      endif
    elseif bail3 && !bail4 
      if bail2 && real(zz) > 0
        zz2 = zz-(-.5,.5)
      else  
        zz2 = zz-(.5,-.5)
      endif
    endif

    #pixel = zz2
    
  ; Tiling mode
  elseif @mode == 3
    if tra % 2 == 0
      #solid = true
    endif
  elseif @mode == 4
    if tra % 2 == 1
      #solid = true
    endif
  
  endif 
  
default:
  title = "Intricated Rings (4,4)"
  helpfile = "sam-help/rings.htm"
  
  param mode
    caption = "Mode"
    default = 2
    enum = "One-Piece In" "One-Piece Out" "Intricated Rings" \
           "Tiling In" "Tiling Out"
  endparam
  
  param smode
    caption = "Global Shape"
    default = 0
    enum = "Plane" "Disk I" "Disk II" \
           "Cross" "Star"
  endparam
  
  param r
    caption = "Global Shape Size"
    default = 2.0
  endparam
  
  param r1
    caption = "Ring Size"
    default = 1.0
  endparam
  
  param w
    caption = "Ring Width"
    default = .05
  endparam
  
  param size
    caption = "Pattern Size"
    default = 1.0
  endparam
  
  param rot
    caption = "Pattern Rotation"
    default = 0.0
  endparam
}

Quasip3d {
; By Samuel Monnier, 24.6.00 - 28.6.00
transform:
  p = 0
  #pixel = #pixel + 134 - 16i
  
  float px = 0
  float py = 0
  float pz = 0
  float npx = 0
  float npy = 0
  float npz = 0
  float cx = 0
  float cy = 0
  float cz = 0
  float v000x = 0
  float v000y = 0
  float v000z = 0
  float v001x = 0
  float v001y = 0
  float v001z = 0
  float v010x = 0
  float v010y = 0
  float v010z = 0
  float v011x = 0
  float v011y = 0
  float v011z = 0
  float v100x = 0
  float v100y = 0
  float v100z = 0
  float v101x = 0
  float v101y = 0
  float v101z = 0
  float v110x = 0
  float v110y = 0
  float v110z = 0
  float v111x = 0
  float v111y = 0
  float v111z = 0
  float nv000x = 0
  float nv000y = 0
  float nv000z = 0
  float nv001x = 0
  float nv001y = 0
  float nv001z = 0
  float nv010x = 0
  float nv010y = 0
  float nv010z = 0
  float nv011x = 0
  float nv011y = 0
  float nv011z = 0
  float nv100x = 0
  float nv100y = 0
  float nv100z = 0
  float nv101x = 0
  float nv101y = 0
  float nv101z = 0
  float nv110x = 0
  float nv110y = 0
  float nv110z = 0
  float nv111x = 0
  float nv111y = 0
  float nv111z = 0
  
  float d000 = 0
  float d001 = 0
  float d010 = 0
  float d011 = 0
  float d100 = 0
  float d101 = 0
  float d110 = 0
  float d111 = 0
  
  float ix = 0
  float iy = 0
  float iz = 0
  float jx = 0
  float jy = 0
  float jz = 0
  float nix = 0
  float njx = 0
  float njy = 0
  float njz = 0
  
  float a = 0
  float b = 0
  float c = 0
  float norm = 0
  float dist = 0
  float dmax = 0
  
  float m00to01 = 0
  float h00to01 = 0
  float m01to11 = 0
  float h01to11 = 0
  float m11to10 = 0
  float h11to10 = 0
  float m10to00 = 0
  float h10to00 = 0
  float t00to01 = 0
  float t01to11 = 0
  float t11to10 = 0
  float t10to00 = 0
  
  float u1x = 0
  float u1y = 0
  float u2x = 0
  float u2y = 0
  
  float xrot = pi/180*@xrot
  float yrot = pi/180*@yrot 
  float zrot = pi/180*@zrot
  
  bool ok000 = true
  bool ok100 = true
  bool ok010 = true
  bool ok110 = true
  bool ok001 = true
  bool ok101 = true
  bool ok011 = true
  bool ok111 = true
  
  bool bail = false
  
  int tiletype = 3
  int loopi = 0
  
  ; Computation of the maximal distance :
  ; Before rotation, the vectors defining the 
  ; plane are i = (1,0,0) and j = (0,1,0). Then perform rotation

  ix = 1
  iy = 0
  iz = 0
  jx = 0
  jy = 1
  jz = 0
  
  ; Rotation along the x axis
  jy = cos(xrot)
  jz = sin(xrot)

  ; Rotation along the y axis
  iz = -sin(yrot)
  ix = cos(yrot)
  njz = cos(yrot)*jz
  jx = sin(yrot)*jz
  jz = njz
  ; Rotation along the z axis
  nix = cos(zrot)*ix
  iy = sin(zrot)*ix
  ix = nix
  njx = cos(zrot)*jx - sin(zrot)*jy
  njy = sin(zrot)*jx + cos(zrot)*jy
  jx = njx
  jy = njy
   
  ; The plane has an equation given by det(i,j,p)=
  ; a*x + b*y + c*z = 0
  a = iy*jz-iz*jy
  b = iz*jx-ix*jz
  c = ix*jy-iy*jx
  
  ; We now compute the distance of (.5,.5,.5), (.5,-.5,.5),
  ; (-.5,.5,.5) and (-.5,-.5,.5) to the plane and take the 
  ; biggest
  
  norm = 2*sqrt(a^2+b^2+c^2)
  dist = abs(1/norm*(a+b+c))
  dmax = dist
  dist = abs(1/norm*(a-b+c)) 
  if dist > dmax
    dmax = dist
  endif
  dist = abs(1/norm*(-a+b+c)) 
  if dist > dmax
    dmax = dist
  endif
  dist = abs(1/norm*(-a-b+c)) 
  if dist > dmax
    dmax = dist
  endif
  
  
  ; End of the computation of the maximal distance.
  
  ; Starts the transform
    
  while !bail && loopi < 7

  p = #pixel
  
  ok000 = true
  ok100 = true
  ok010 = true
  ok110 = true
  ok001 = true
  ok101 = true
  ok011 = true
  ok111 = true
  
  ; Coordinates of p in the 3-dimentional space
  px = real(p)
  py = imag(p)
  pz = 0
  
  ; Rotation along the x axis
  npy = cos(xrot)*py - sin(xrot)*pz
  npz = sin(xrot)*py + cos(xrot)*pz
  py = npy
  pz = npz
  
  ; Rotation along the y axis
  npz = cos(yrot)*pz - sin(yrot)*px
  npx = sin(yrot)*pz + cos(yrot)*px
  pz = npz
  px = npx
  
  ; Rotation along the z axis
  npx = cos(zrot)*px - sin(zrot)*py
  npy = sin(zrot)*px + cos(zrot)*py
  px = npx
  py = npy
  
  ; Center of the cube containing the considered point
  if loopi == 0  
    cx = round(px)
    cy = round(py)
    cz = round(pz)
  elseif loopi == 1
    cx = round(px) + 1
    cy = round(py)
    cz = round(pz)
  elseif loopi == 2
    cx = round(px) - 1
    cy = round(py)
    cz = round(pz)
  elseif loopi == 3
    cx = round(px) 
    cy = round(py) + 1
    cz = round(pz)
  elseif loopi == 4
    cx = round(px) 
    cy = round(py) - 1
    cz = round(pz)
  elseif loopi == 5
    cx = round(px) 
    cy = round(py)
    cz = round(pz) + 1
  elseif loopi == 6
    cx = round(px) 
    cy = round(py)
    cz = round(pz) - 1
  endif
    
  ; Vertexs
  v000x = cx - .5
  v000y = cy - .5
  v000z = cz - .5
  
  v111x = cx + .5
  v111y = cy + .5
  v111z = cz + .5
  
  v100x = v111x
  v100y = v000y
  v100z = v000z
  
  v010x = v000x
  v010y = v111y
  v010z = v000z
  
  v110x = v111x
  v110y = v111y
  v110z = v000z
  
  v001x = v000x
  v001y = v000y 
  v001z = v111z
  
  v101x = v111x
  v101y = v000y
  v101z = v111z
  
  v011x = v000x
  v011y = v111y
  v011z = v111z
  
  ; Now we have to perform the inverse rotation on
  ; all the vertexs... :-(
  
  nv000x = cos(-zrot)*v000x - sin(-zrot)*v000y
  nv000y = sin(-zrot)*v000x + cos(-zrot)*v000y
  v000x = nv000x
  v000y = nv000y
  nv000z = cos(-yrot)*v000z - sin(-yrot)*v000x
  nv000x = sin(-yrot)*v000z + cos(-yrot)*v000x
  v000z = nv000z
  v000x = nv000x
  nv000y = cos(-xrot)*v000y - sin(-xrot)*v000z
  nv000z = sin(-xrot)*v000y + cos(-xrot)*v000z
  v000y = nv000y
  v000z = nv000z
  
  nv001x = cos(-zrot)*v001x - sin(-zrot)*v001y
  nv001y = sin(-zrot)*v001x + cos(-zrot)*v001y
  v001x = nv001x
  v001y = nv001y
  nv001z = cos(-yrot)*v001z - sin(-yrot)*v001x
  nv001x = sin(-yrot)*v001z + cos(-yrot)*v001x
  v001z = nv001z
  v001x = nv001x
  nv001y = cos(-xrot)*v001y - sin(-xrot)*v001z
  nv001z = sin(-xrot)*v001y + cos(-xrot)*v001z
  v001y = nv001y
  v001z = nv001z
  
  nv010x = cos(-zrot)*v010x - sin(-zrot)*v010y
  nv010y = sin(-zrot)*v010x + cos(-zrot)*v010y
  v010x = nv010x
  v010y = nv010y
  nv010z = cos(-yrot)*v010z - sin(-yrot)*v010x
  nv010x = sin(-yrot)*v010z + cos(-yrot)*v010x
  v010z = nv010z
  v010x = nv010x
  nv010y = cos(-xrot)*v010y - sin(-xrot)*v010z
  nv010z = sin(-xrot)*v010y + cos(-xrot)*v010z
  v010y = nv010y
  v010z = nv010z
  
  nv011x = cos(-zrot)*v011x - sin(-zrot)*v011y
  nv011y = sin(-zrot)*v011x + cos(-zrot)*v011y
  v011x = nv011x
  v011y = nv011y
  nv011z = cos(-yrot)*v011z - sin(-yrot)*v011x
  nv011x = sin(-yrot)*v011z + cos(-yrot)*v011x
  v011z = nv011z
  v011x = nv011x
  nv011y = cos(-xrot)*v011y - sin(-xrot)*v011z
  nv011z = sin(-xrot)*v011y + cos(-xrot)*v011z
  v011y = nv011y
  v011z = nv011z
  
  nv100x = cos(-zrot)*v100x - sin(-zrot)*v100y
  nv100y = sin(-zrot)*v100x + cos(-zrot)*v100y
  v100x = nv100x
  v100y = nv100y
  nv100z = cos(-yrot)*v100z - sin(-yrot)*v100x
  nv100x = sin(-yrot)*v100z + cos(-yrot)*v100x
  v100z = nv100z
  v100x = nv100x
  nv100y = cos(-xrot)*v100y - sin(-xrot)*v100z
  nv100z = sin(-xrot)*v100y + cos(-xrot)*v100z
  v100y = nv100y
  v100z = nv100z
  
  nv101x = cos(-zrot)*v101x - sin(-zrot)*v101y
  nv101y = sin(-zrot)*v101x + cos(-zrot)*v101y
  v101x = nv101x
  v101y = nv101y
  nv101z = cos(-yrot)*v101z - sin(-yrot)*v101x
  nv101x = sin(-yrot)*v101z + cos(-yrot)*v101x
  v101z = nv101z
  v101x = nv101x
  nv101y = cos(-xrot)*v101y - sin(-xrot)*v101z
  nv101z = sin(-xrot)*v101y + cos(-xrot)*v101z
  v101y = nv101y
  v101z = nv101z
  
  nv110x = cos(-zrot)*v110x - sin(-zrot)*v110y
  nv110y = sin(-zrot)*v110x + cos(-zrot)*v110y
  v110x = nv110x
  v110y = nv110y
  nv110z = cos(-yrot)*v110z - sin(-yrot)*v110x
  nv110x = sin(-yrot)*v110z + cos(-yrot)*v110x
  v110z = nv110z
  v110x = nv110x
  nv110y = cos(-xrot)*v110y - sin(-xrot)*v110z
  nv110z = sin(-xrot)*v110y + cos(-xrot)*v110z
  v110y = nv110y
  v110z = nv110z
  
  nv111x = cos(-zrot)*v111x - sin(-zrot)*v111y
  nv111y = sin(-zrot)*v111x + cos(-zrot)*v111y
  v111x = nv111x
  v111y = nv111y
  nv111z = cos(-yrot)*v111z - sin(-yrot)*v111x
  nv111x = sin(-yrot)*v111z + cos(-yrot)*v111x
  v111z = nv111z
  v111x = nv111x
  nv111y = cos(-xrot)*v111y - sin(-xrot)*v111z
  nv111z = sin(-xrot)*v111y + cos(-xrot)*v111z
  v111y = nv111y
  v111z = nv111z
  
  ; Done... !!
  
  ; Distance from each vertex to the plane
  d000 = abs(v000z)
  d001 = abs(v001z)
  d010 = abs(v010z)
  d011 = abs(v011z)
  d100 = abs(v100z)
  d101 = abs(v101z)
  d110 = abs(v110z)
  d111 = abs(v111z)
  
  ; Eliminate the vertexs that are too far
  ; from the plane.
  if d000 > dmax
    ok000 = false
  endif
  if d001 > dmax
    ok001 = false
  endif
  if d010 > dmax
    ok010 = false
  endif
  if d011 > dmax
    ok011 = false
  endif
  if d100 > dmax
    ok100 = false
  endif
  if d101 > dmax
    ok101 = false
  endif
  if d110 > dmax
    ok110 = false
  endif
  if d111 > dmax
    ok111 = false
  endif
  
  
  ; Restores the original value for p's coordinates
  px = real(p)
  py = imag(p)
  
  ; Checks if the vertexs of this side aren't too far and...
  if ok000 && ok001 && ok010 && ok011
    m00to01 = (v001y-v000y)/(v001x-v000x)
    h00to01 = (v001x*v000y-v000x*v001y)/(v001x-v000x)
    m01to11 = (v011y-v001y)/(v011x-v001x)
    h01to11 = (v011x*v001y-v001x*v011y)/(v011x-v001x)
    m11to10 = (v010y-v011y)/(v010x-v011x)
    h11to10 = (v010x*v011y-v011x*v010y)/(v010x-v011x)
    m10to00 = (v000y-v010y)/(v000x-v010x)
    h10to00 = (v000x*v010y-v010x*v000y)/(v000x-v010x)
    t00to01 = m00to01*px + h00to01 - py
    t01to11 = m01to11*px + h01to11 - py
    t11to10 = m11to10*px + h11to10 - py
    t10to00 = m10to00*px + h10to00 - py
    
    ; ...checks if the point is under this side.
    if (t00to01 < 0 && t11to10 > 0) || (t00to01 > 0 && t11to10 < 0)
      if (t01to11 < 0 && t10to00 > 0) || (t01to11 > 0 && t10to00 < 0)
        ; If so, computes the new coordinates of p.
        tiletype = 0
        px = px - v000x
        py = py - v000y
        u1x = v001x - v000x
        u1y = v001y - v000y
        u2x = v010x - v000x
        u2y = v010y - v000y
        npx = 1/(u1x*u2y-u1y*u2x)*(u2y*px - u2x*py)
        npy = 1/(u1x*u2y-u1y*u2x)*(-u1y*px + u1x*py)
        #pixel = npx + flip(npy)
      endif
    endif
  endif
  
  ; Restores the original value for p's coordinates
  px = real(p)
  py = imag(p)
  
  if ok100 && ok101 && ok110 && ok111
    m00to01 = (v101y-v100y)/(v101x-v100x)
    h00to01 = (v101x*v100y-v100x*v101y)/(v101x-v100x)
    m01to11 = (v111y-v101y)/(v111x-v101x)
    h01to11 = (v111x*v101y-v101x*v111y)/(v111x-v101x)
    m11to10 = (v110y-v111y)/(v110x-v111x)
    h11to10 = (v110x*v111y-v111x*v110y)/(v110x-v111x)
    m10to00 = (v100y-v110y)/(v100x-v110x)
    h10to00 = (v100x*v110y-v110x*v100y)/(v100x-v110x)
    t00to01 = m00to01*px + h00to01 - py
    t01to11 = m01to11*px + h01to11 - py
    t11to10 = m11to10*px + h11to10 - py
    t10to00 = m10to00*px + h10to00 - py
    
    if (t00to01 < 0 && t11to10 > 0) || (t00to01 > 0 && t11to10 < 0)
      if (t01to11 < 0 && t10to00 > 0) || (t01to11 > 0 && t10to00 < 0)
        tiletype = 0
        px = px - v100x
        py = py - v100y
        u1x = v101x - v100x
        u1y = v101y - v100y
        u2x = v110x - v100x
        u2y = v110y - v100y
        npx = 1/(u1x*u2y-u1y*u2x)*(u2y*px - u2x*py)
        npy = 1/(u1x*u2y-u1y*u2x)*(-u1y*px + u1x*py)
        #pixel = npx + flip(npy)
      endif
    endif
  endif 
  
  ; Restores the original value for p's coordinates
  px = real(p)
  py = imag(p)
  
  if ok000 && ok001 && ok100 && ok101
    m00to01 = (v001y-v000y)/(v001x-v000x)
    h00to01 = (v001x*v000y-v000x*v001y)/(v001x-v000x)
    m01to11 = (v101y-v001y)/(v101x-v001x)
    h01to11 = (v101x*v001y-v001x*v101y)/(v101x-v001x)
    m11to10 = (v100y-v101y)/(v100x-v101x)
    h11to10 = (v100x*v101y-v101x*v100y)/(v100x-v101x)
    m10to00 = (v000y-v100y)/(v000x-v100x)
    h10to00 = (v000x*v100y-v100x*v000y)/(v000x-v100x)
    t00to01 = m00to01*px + h00to01 - py
    t01to11 = m01to11*px + h01to11 - py
    t11to10 = m11to10*px + h11to10 - py
    t10to00 = m10to00*px + h10to00 - py
    
    if (t00to01 < 0 && t11to10 > 0) || (t00to01 > 0 && t11to10 < 0)
      if (t01to11 < 0 && t10to00 > 0) || (t01to11 > 0 && t10to00 < 0)
        tiletype = 1
        px = px - v000x
        py = py - v000y
        u1x = v100x - v000x
        u1y = v100y - v000y
        u2x = v001x - v000x
        u2y = v001y - v000y
        npx = 1/(u1x*u2y-u1y*u2x)*(u2y*px - u2x*py)
        npy = 1/(u1x*u2y-u1y*u2x)*(-u1y*px + u1x*py)
        #pixel = npx + flip(npy)
      endif
    endif
  endif
 
  ; Restores the original value for p's coordinates
  px = real(p)
  py = imag(p)
  
  if ok010 && ok011 && ok110 && ok111
    m00to01 = (v011y-v010y)/(v011x-v010x)
    h00to01 = (v011x*v010y-v010x*v011y)/(v011x-v010x)
    m01to11 = (v111y-v011y)/(v111x-v011x)
    h01to11 = (v111x*v011y-v011x*v111y)/(v111x-v011x)
    m11to10 = (v110y-v111y)/(v110x-v111x)
    h11to10 = (v110x*v111y-v111x*v110y)/(v110x-v111x)
    m10to00 = (v010y-v110y)/(v010x-v110x)
    h10to00 = (v010x*v110y-v110x*v010y)/(v010x-v110x)
    t00to01 = m00to01*px + h00to01 - py
    t01to11 = m01to11*px + h01to11 - py
    t11to10 = m11to10*px + h11to10 - py
    t10to00 = m10to00*px + h10to00 - py
    
    if (t00to01 < 0 && t11to10 > 0) || (t00to01 > 0 && t11to10 < 0)
      if (t01to11 < 0 && t10to00 > 0) || (t01to11 > 0 && t10to00 < 0)
        tiletype = 1
        ;#solid = true
        px = px - v010x
        py = py - v010y
        u1x = v110x - v010x
        u1y = v110y - v010y
        u2x = v011x - v010x
        u2y = v011y - v010y
        npx = 1/(u1x*u2y-u1y*u2x)*(u2y*px - u2x*py)
        npy = 1/(u1x*u2y-u1y*u2x)*(-u1y*px + u1x*py)
        #pixel = npx + flip(npy)
      endif
    endif
  endif

 
  ; Restores the original value for p's coordinates
  px = real(p)
  py = imag(p)
  
  if ok000 && ok010 && ok100 && ok110
    m00to01 = (v010y-v000y)/(v010x-v000x)
    h00to01 = (v010x*v000y-v000x*v010y)/(v010x-v000x)
    m01to11 = (v110y-v010y)/(v110x-v010x)
    h01to11 = (v110x*v010y-v010x*v110y)/(v110x-v010x)
    m11to10 = (v100y-v110y)/(v100x-v110x)
    h11to10 = (v100x*v110y-v110x*v100y)/(v100x-v110x)
    m10to00 = (v000y-v100y)/(v000x-v100x)
    h10to00 = (v000x*v100y-v100x*v000y)/(v000x-v100x)
    t00to01 = m00to01*px + h00to01 - py
    t01to11 = m01to11*px + h01to11 - py
    t11to10 = m11to10*px + h11to10 - py
    t10to00 = m10to00*px + h10to00 - py

    if (t00to01 < 0 && t11to10 > 0) || (t00to01 > 0 && t11to10 < 0)
      if (t01to11 < 0 && t10to00 > 0) || (t01to11 > 0 && t10to00 < 0)
        tiletype = 2
        px = px - v000x
        py = py - v000y
        u1x = v010x - v000x
        u1y = v010y - v000y
        u2x = v100x - v000x
        u2y = v100y - v000y
        npx = 1/(u1x*u2y-u1y*u2x)*(u2y*px - u2x*py)
        npy = 1/(u1x*u2y-u1y*u2x)*(-u1y*px + u1x*py)
        #pixel = npx + flip(npy)
      endif
    endif
  endif
  
  ; Restores the original value for p's coordinates
  px = real(p)
  py = imag(p)
  
  if ok001 && ok011 && ok101 && ok111
    m00to01 = (v011y-v001y)/(v011x-v001x)
    h00to01 = (v011x*v001y-v001x*v011y)/(v011x-v001x)
    m01to11 = (v111y-v011y)/(v111x-v011x)
    h01to11 = (v111x*v011y-v011x*v111y)/(v111x-v011x)
    m11to10 = (v101y-v111y)/(v101x-v111x)
    h11to10 = (v101x*v111y-v111x*v101y)/(v101x-v111x)
    m10to00 = (v001y-v101y)/(v001x-v101x)
    h10to00 = (v001x*v101y-v101x*v001y)/(v001x-v101x)
    t00to01 = m00to01*px + h00to01 - py
    t01to11 = m01to11*px + h01to11 - py
    t11to10 = m11to10*px + h11to10 - py
    t10to00 = m10to00*px + h10to00 - py
    ;#solid = true
    
    if (t00to01 < 0 && t11to10 > 0) || (t00to01 > 0 && t11to10 < 0)
      if (t01to11 < 0 && t10to00 > 0) || (t01to11 > 0 && t10to00 < 0)
        tiletype = 2
        px = px - v001x
        py = py - v001y
        u1x = v011x - v001x
        u1y = v011y - v001y
        u2x = v101x - v001x
        u2y = v101y - v001y
        npx = 1/(u1x*u2y-u1y*u2x)*(u2y*px - u2x*py)
        npy = 1/(u1x*u2y-u1y*u2x)*(-u1y*px + u1x*py)
        #pixel = npx + flip(npy)
      endif
    endif
  endif
 
;  if tiletype == 0
;    #solid = true
;  endif
  
  ; A trick...
  if tiletype != 3 
    bail = true
  elseif tiletype == 3
    loopi = loopi + 1
  endif
 
  endwhile

  
  
  
  if @mode != 1
    #pixel = #pixel - (.5,.5)
    ; Performs Magnification, Rotation and Shift
    p = #pixel
    p = p/@size
    p = p*exp(1i*pi/180*@rot)
    p = p - @center
    #pixel = p
    if @mode == 2
      if tiletype != 0
        #solid = true
      endif
    elseif @mode == 3
      if tiletype != 1
        #solid = true
      endif
    elseif @mode == 4
      if tiletype != 2
        #solid = true
      endif
    elseif @mode == 5
      if tiletype == 0
        #solid = true
      endif
    elseif @mode == 6
      if tiletype == 1
        #solid = true
      endif
    elseif @mode == 7
      if tiletype == 2
        #solid = true
      endif
    endif
    
  elseif @mode == 1
    if tiletype == 0
      #pixel = @col1
    elseif tiletype == 1
      #pixel = @col2
    elseif tiletype == 2
      #pixel = @col3
    endif
  endif
  
default:
  title = "Quasiperiodic Tiling (3d lattice)"
  
  param mode 
    caption = "Mode"
    default = 0
    enum = "Mapping" "Color" "Tile Type 0" \
           "Tile Type 1" "Tile Type 2" "Tile Types 1 and 2" \
           "Tile Types 2 and 0" "Tile Types 0 and 1"
  endparam
  
  param xrot
    caption = "x Rotation Angle"
    default = 34.0
  endparam
      
  param yrot
    caption = "y Rotation Angle"
    default = 34.0
  endparam

  param zrot
    caption = "z Rotation Angle"
    default = 1.0
  endparam

  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param size
    caption = "Mapping size"
    default = 1.0
  endparam
  
  param col1
    caption = "Color 1"
    default = (0,0)
  endparam
  
  param col2
    caption = "Color 2"
    default = (1,0)
  endparam
  
  param col3
    caption = "Color 3"
    default = (2,0)
  endparam
  
  
}

Tiling11 {
; By Samuel Monnier, 15.6.00 - 22.6.00
transform:
  ; Pattern Magnification and Rotation
  z = #pixel/@size*exp(-1i*pi/180*@rot)
  ; Bottom left corner of the tile
  zc = floor(z)
  ; Coordinate of the point in the tile
  zz = z - zc

  
  
  ; Computes the coordinates of the selected tiles
  st1 = floor(@stile1/@size)
  st2 = floor(@stile2/@size)
  st3 = floor(@stile3/@size)
  st4 = floor(@stile4/@size)

  ; Computes the coordinates of the two shape mask
  ; parameters
  smp1 = floor(@smaskp1/@size)
  smp2 = floor(@smaskp2/@size)

  ; Initialization...
  bool cj = false
  bool bail = false
  bool bail1 = false
  bool bail2 = false
  bool bail3 = false
  bool bail4 = false
  
  cr1 = 0
  cr2 = 0
  cr3 = 0
  cr4 = 0
  ci1 = 0
  ci2 = 0
  ci3 = 0
  ci4 = 0 
         
  perot = 1
  
  float x = 0
  float y = 0
    
  float m = 0
  float h = 0  
    
  ; Define the points
  float x1 = 0
  float y1 = 0
  float x2 = real(@p1)
  float y2 = imag(@p1)
  float x3 = real(@p2)
  float y3 = imag(@p2)
  float x4 = real(@p3)
  float y4 = imag(@p3)
  float x5 = real(@p4)
  float y5 = imag(@p4)
  float x6 = real(@p5)
  float y6 = imag(@p5)
  float x7 = real(@p6)
  float y7 = imag(@p6)
  float x8 = real(@p7)
  float y8 = imag(@p7)
  float x9 = real(@p8)
  float y9 = imag(@p8)
  float x10 = real(@p9)
  float y10 = imag(@p9)
  float x11 = real(@p10)
  float y11 = imag(@p10)
  float x12 = 1
  float y12 = 0
  
  ; Compute the slopes and the heights
  float m12 = (y2-y1)/(x2-x1)
  float h12 = (x2*y1-x1*y2)/(x2-x1)
  float m23 = (y3-y2)/(x3-x2)
  float h23 = (x3*y2-x2*y3)/(x3-x2)
  float m34 = (y4-y3)/(x4-x3)
  float h34 = (x4*y3-x3*y4)/(x4-x3)
  float m45 = (y5-y4)/(x5-x4)
  float h45 = (x5*y4-x4*y5)/(x5-x4)
  float m56 = (y6-y5)/(x6-x5)
  float h56 = (x6*y5-x5*y6)/(x6-x5)
  float m67 = (y7-y6)/(x7-x6)
  float h67 = (x7*y6-x6*y7)/(x7-x6)
  float m78 = (y8-y7)/(x8-x7)
  float h78 = (x8*y7-x7*y8)/(x8-x7)
  float m89 = (y9-y8)/(x9-x8)
  float h89 = (x9*y8-x8*y9)/(x9-x8)
  float m910 = (y10-y9)/(x10-x9)
  float h910 = (x10*y9-x9*y10)/(x10-x9)
  float m1011 = (y11-y10)/(x11-x10)
  float h1011 = (x11*y10-x10*y11)/(x11-x10)
  float m1112 = (y12-y11)/(x12-x11)
  float h1112 = (x12*y11-x11*y12)/(x12-x11)
  
  int i = 0
  
  ; Corners of the square
  zc1 = zc
  zc2 = zc + (1,0)
  zc3 = zc + (1,1)
  zc4 = zc + (0,1)
  
  ; Longitudinal mode. Defines the parameters that 
  ; will mirror vertically the broken line.
  if @lmode == 0
    if abs(real(zc)+imag(zc))%4 == 0
      cr1 = (1,1)
      cr2 = (-1,1)
      cr3 = (1,1)
      cr4 = (1,-1)
    elseif abs(real(zc)+imag(zc))%4 == 1
      cr1 = (-1,1)
      cr2 = (-1,1)
      cr3 = (-1,-1)
      cr4 = (1,1)
    elseif abs(real(zc)+imag(zc))%4 == 2
      cr1 = (-1,1)
      cr2 = (1,1)
      cr3 = (-1,1)
      cr4 = (-1,-1)
    elseif abs(real(zc)+imag(zc))%4 == 3
      cr1 = (1,1)
      cr2 = (1,1)
      cr3 = (1,-1)
      cr4 = (-1,1)
    endif
  elseif @lmode == 1 
    cr1 = (1,1)
    cr2 = (1,1)
    cr3 = (1,1)
    cr4 = (1,1)
  elseif @lmode == 2
    if abs(real(zc)+imag(zc))%4 == 0
      cr1 = (1,1)
      cr2 = (-1,1)
      cr3 = (1,-1)
      cr4 = (1,1)
    elseif abs(real(zc)+imag(zc))%4 == 1
      cr1 = (-1,1)
      cr2 = (-1,1)
      cr3 = (-1,1)
      cr4 = (1,-1)
    elseif abs(real(zc)+imag(zc))%4 == 2
      cr1 = (-1,1)
      cr2 = (1,1)
      cr3 = (-1,-1)
      cr4 = (-1,1)
    elseif abs(real(zc)+imag(zc))%4 == 3
      cr1 = (1,1)
      cr2 = (1,1)
      cr3 = (1,1)
      cr4 = (-1,-1)
    endif
    
  elseif @lmode == 3
    if abs(real(zc)+imag(zc))%4 == 0
      cr1 = (1,1)
      cr2 = (1,1)
      cr3 = (1,-1)
      cr4 = (1,1)
    elseif abs(real(zc)+imag(zc))%4 == 1
      cr1 = (1,1)
      cr2 = (1,1)
      cr3 = (1,1)
      cr4 = (1,-1)
    elseif abs(real(zc)+imag(zc))%4 == 2
      cr1 = (1,1)
      cr2 = (1,1)
      cr3 = (1,-1)
      cr4 = (1,1)
    elseif abs(real(zc)+imag(zc))%4 == 3
      cr1 = (1,1)
      cr2 = (1,1)
      cr3 = (1,1)
      cr4 = (1,-1)
    endif
    
  elseif @lmode == 4
    if abs(real(zc))%4 == 0
      cr1 = (1,1)
      cr2 = (1,1)
      cr3 = (1,-1)
      cr4 = (1,1)
    elseif abs(real(zc))%4 == 1
      cr1 = (1,1)
      cr2 = (1,1)
      cr3 = (1,1)
      cr4 = (1,-1)
    elseif abs(real(zc))%4 == 2
      cr1 = (1,1)
      cr2 = (1,1)
      cr3 = (1,-1)
      cr4 = (1,1)
    elseif abs(real(zc))%4 == 3
      cr1 = (1,1)
      cr2 = (1,1)
      cr3 = (1,1)
      cr4 = (1,-1)
    endif
  
  ; Quasiperiodic "Standard"  
  elseif @lmode == 5
    cr1 = (@seed/(zc1+124-74i) - round(@seed/(zc1+124-74i)))
    cr2 = (@seed/(zc2+124-74i) - round(@seed/(zc2+124-74i)))
    cr3 = (@seed/(zc3+124-74i) - round(@seed/(zc3+124-74i)))
    cr4 = (@seed/(zc4+124-74i) - round(@seed/(zc4+124-74i)))
    cr1 = cr1 + (@seed/(zc1-83+174i) - round(@seed/(zc1-83+174i)))  
    cr2 = cr2 + (@seed/(zc2-83+174i) - round(@seed/(zc2-83+174i)))
    cr3 = cr3 + (@seed/(zc3-83+174i) - round(@seed/(zc3-83+174i)))
    cr4 = cr4 + (@seed/(zc4-83+174i) - round(@seed/(zc4-83+174i)))
  
  ; Quasiperiodic "Function"    
  elseif @lmode == 6
    cr1 = (@f1(@ffact*zc1) - round(@f1(@ffact*zc1)))
    cr2 = (@f1(@ffact*zc2) - round(@f1(@ffact*zc2)))
    cr3 = (@f1(@ffact*zc3) - round(@f1(@ffact*zc3)))
    cr4 = (@f1(@ffact*zc4) - round(@f1(@ffact*zc4)))
    
  endif

  ; Idem for the transverse mode
  if @tmode == 0
    if abs(real(zc)+imag(zc))%4 == 0
      ci1 = (1,1)
      ci2 = (-1,1)
      ci3 = (1,1)
      ci4 = (1,-1)
    elseif abs(real(zc)+imag(zc))%4 == 1
      ci1 = (-1,1)
      ci2 = (-1,1)
      ci3 = (-1,-1)
      ci4 = (1,1)
    elseif abs(real(zc)+imag(zc))%4 == 2
      ci1 = (-1,1)
      ci2 = (1,1)
      ci3 = (-1,1)
      ci4 = (-1,-1)
    elseif abs(real(zc)+imag(zc))%4 == 3
      ci1 = (1,1)
      ci2 = (1,1)
      ci3 = (1,-1)
      ci4 = (-1,1)
    endif
    
  elseif @tmode == 1 
    ci1 = (1,1)
    ci2 = (1,1)
    ci3 = (1,1)
    ci4 = (1,1)
  
  elseif @tmode == 2
    if abs(real(zc)+imag(zc))%4 == 0
      ci1 = (1,1)
      ci2 = (-1,1)
      ci3 = (1,-1)
      ci4 = (1,1)
    elseif abs(real(zc)+imag(zc))%4 == 1
      ci1 = (-1,1)
      ci2 = (-1,1)
      ci3 = (-1,1)
      ci4 = (1,-1)
    elseif abs(real(zc)+imag(zc))%4 == 2
      ci1 = (-1,1)
      ci2 = (1,1)
      ci3 = (-1,-1)
      ci4 = (-1,1)
    elseif abs(real(zc)+imag(zc))%4 == 3
      ci1 = (1,1)
      ci2 = (1,1)
      ci3 = (1,1)
      ci4 = (-1,-1)
    endif
    
  elseif @tmode == 3
    if abs(real(zc)+imag(zc))%4 == 0
      ci1 = (1,1)
      ci2 = (1,1)
      ci3 = (1,-1)
      ci4 = (1,1)
    elseif abs(real(zc)+imag(zc))%4 == 1
      ci1 = (1,1)
      ci2 = (1,1)
      ci3 = (1,1)
      ci4 = (1,-1)
    elseif abs(real(zc)+imag(zc))%4 == 2
      ci1 = (1,1)
      ci2 = (1,1)
      ci3 = (1,-1)
      ci4 = (1,1)
    elseif abs(real(zc)+imag(zc))%4 == 3
      ci1 = (1,1)
      ci2 = (1,1)
      ci3 = (1,1)
      ci4 = (1,-1)
    endif
    
  elseif @tmode == 4
    if abs(real(zc))%4 == 0
      ci1 = (1,1)
      ci2 = (1,1)
      ci3 = (1,-1)
      ci4 = (1,1)
    elseif abs(real(zc))%4 == 1
      ci1 = (1,1)
      ci2 = (1,1)
      ci3 = (1,1)
      ci4 = (1,-1)
    elseif abs(real(zc))%4 == 2
      ci1 = (1,1)
      ci2 = (1,1)
      ci3 = (1,-1)
      ci4 = (1,1)
    elseif abs(real(zc))%4 == 3
      ci1 = (1,1)
      ci2 = (1,1)
      ci3 = (1,1)
      ci4 = (1,-1)
    endif
    
  ; Quasiperiodic "Standard"  
  elseif @tmode == 5
    ci1 = (@seed/(zc1+132-111i) - round(@seed/(zc1+132-111i)))
    ci2 = (@seed/(zc2+132-111i) - round(@seed/(zc2+132-111i)))
    ci3 = (@seed/(zc3+132-111i) - round(@seed/(zc3+132-111i)))
    ci4 = (@seed/(zc4+132-111i) - round(@seed/(zc4+132-111i)))
    ci1 = ci1 + (@seed/(zc1-121+154i) - round(@seed/(zc1-121+154i)))  
    ci2 = ci2 + (@seed/(zc2-121+154i) - round(@seed/(zc2-121+154i)))
    ci3 = ci3 + (@seed/(zc3-121+154i) - round(@seed/(zc3-121+154i)))
    ci4 = ci4 + (@seed/(zc4-121+154i) - round(@seed/(zc4-121+154i)))
  
  ; Quasiperiodic "Function"    
  elseif @tmode == 6
    ci1 = (@f1(@ffact*zc1) - round(@f1(@ffact*zc1)))
    ci2 = (@f1(@ffact*zc2) - round(@f1(@ffact*zc2)))
    ci3 = (@f1(@ffact*zc3) - round(@f1(@ffact*zc3)))
    ci4 = (@f1(@ffact*zc4) - round(@f1(@ffact*zc4)))
    
  endif
  
;  if cr4 > 0
;    #solid = true
;  endif
  
    
  ;--------------
  ; Starts Here !
  ;--------------

  
  while i < 4
    i = i + 1
    
    z = zz
    
    cj = false
    
    ; For the bottom side of the tile        
    if i == 1
      ; Vertical symetry (longitudinal mode)
      if real(cr1)*real(cr2) > 0
        z = conj(-z) + (1,0)
      endif
      ; Horizontal symetry (transverse mode)
      if real(ci1)*real(ci2) > 0
        z = conj(z)
        cj = true
      endif
    endif
    
    ; For the left side of the tile 
    if i == 2
      z = z*exp(-1i*pi/2) + 1i
      if imag(cr2)*imag(cr3) > 0
        z = conj(-z) + (1,0)
      endif
      if imag(ci2)*imag(ci3) > 0
        z = conj(z)
        cj = true
      endif
    endif
    
    ; Top side
    if i == 3
      z = -z + (1,1)
      if real(cr3)*real(cr4) <= 0
        z = conj(-z) + (1,0)
      endif
      if real(ci3)*real(ci4) <= 0
        z = conj(z)
        cj = true
      endif
    endif
    
    ; Right side
    if i == 4
      z = z*exp(1i*pi/2) + 1
      if imag(cr4)*imag(cr1) <= 0
        z = conj(-z) + (1,0)
      endif
      if imag(ci4)*imag(ci1) <= 0
        z = conj(z)
        cj = true
      endif
    endif
    
    x = real(z)
    y = imag(z)
    
    ; Broken line bailout
    
    ; Point 1 - Point 2
    if x > x1 && x < x2
      if y > m12*x + h12 
        bail = !bail
      endif
    endif
    if x < x1 && x > x2
      if y > m12*x + h12
        bail = !bail
      endif
    endif
    
    ; Point 2 - Point 3
    if x > x2 && x < x3
      if y > m23*x + h23 
        bail = !bail
      endif
    endif
    if x < x2 && x > x3 
      if y > m23*x + h23 
        bail = !bail
      endif
    endif
    
    ; Point 3 - Point 4
    if x > x3 && x < x4
      if y > m34*x + h34 
        bail = !bail
      endif
    endif
    if x < x3 && x > x4 
      if y > m34*x + h34
        bail = !bail
      endif
    endif
    
    ; Point 4 - Point 5
    if x > x4 && x < x5
      if y > m45*x + h45 
        bail = !bail
      endif
    endif
    if x < x4 && x > x5 
      if y > m45*x + h45
        bail = !bail
      endif
    endif
    
    ; Point 5 - Point 6
    if x > x5 && x < x6
      if y > m56*x + h56 
        bail = !bail
      endif
    endif
    if x < x5 && x > x6 
      if y > m56*x + h56
        bail = !bail
      endif
    endif
  
    ; Point 6 - Point 7
    if x > x6 && x < x7
      if y > m67*x + h67 
        bail = !bail
      endif
    endif
    if x < x6 && x > x7 
      if y > m67*x + h67
        bail = !bail
      endif
    endif
  
    ; Point 7 - Point 8
    if x > x7 && x < x8
      if y > m78*x + h78 
        bail = !bail
      endif
    endif
    if x < x7 && x > x8 
      if y > m78*x + h78
        bail = !bail
      endif
    endif
  
    ; Point 8 - Point 9
    if x > x8 && x < x9
      if y > m89*x + h89 
        bail = !bail
      endif
    endif
    if x < x8 && x > x9
      if y > m89*x + h89 
        bail = !bail
      endif
    endif
  
    ; Point 9 - Point 10
    if x > x9 && x < x10
      if y > m910*x + h910 
        bail = !bail
      endif
    endif
    if x < x9 && x > x10 
      if y > m910*x + h910
        bail = !bail
      endif
    endif
  
    ; Point 10 - Point 11
    if x > x10 && x < x11
      if y > m1011*x + h1011 
        bail = !bail
      endif
    endif
    if x < x10 && x > x11
      if y > m1011*x + h1011
        bail = !bail
      endif
    endif
  
    ; Point 11 - Point 12
    if x > x11 && x < x12
      if y > m1112*x + h1112 
        bail = !bail
      endif
    endif
    if x < x11 && x > x12
      if y > m1112*x + h1112
        bail = !bail
      endif
    endif
    
    ; Records the results
    if i == 1 
      if !bail
        bail1 = true
      endif
      if cj
        bail1 = !bail1
      endif
    endif
    
    if i == 2 
      if !bail
        bail2 = true
      endif
      if cj
        bail2 = !bail2
      endif
    endif
    
    if i == 3 
      if !bail
        bail3 = true
      endif
      if cj
        bail3 = !bail3
      endif
    endif
    
    if i == 4 
      if !bail
        bail4 = true
      endif
      if cj
        bail4 = !bail4
      endif
    endif
    
    bail = false  
      
  endwhile
  
  z = zz

  ; If the pixel must be assigned another tile
  if bail1
    z = z + 1i
    zc = zc - 1i
  elseif bail2
    z = z - 1
    zc = zc + 1
  elseif bail3
    z = z - 1i
    zc = zc + 1i
  elseif bail4
    z = z + 1
    zc = zc - 1
  endif
  
  ; Mask
  ; Checkerboard 
  if @mask == 1
    if (real(zc)%2 + imag(zc)%2)%2 == 0
      #solid = true
    endif
  elseif @mask == 2
    if (real(zc)%2 + imag(zc)%2 + 1)%2 == 0
      #solid = true
    endif
  ; Vertical stripes
  elseif @mask == 3
    if real(zc)%2 == 0
      #solid = true
    endif
  elseif @mask == 4
    if real(zc+1)%2 == 0
      #solid = true
    endif
  ; Horizontal stripes
  elseif @mask == 5
    if imag(zc)%2 == 0
      #solid = true
    endif
  elseif @mask == 6
    if imag(zc+1i)%2 == 0
      #solid = true
    endif
  ; Selected tiles  
  elseif @mask == 7
    if (zc == st1 || zc == st2 || zc == st3 || zc == st4)
      #solid = true
    endif
  elseif @mask == 8
    if (zc != st1 && zc != st2 && zc != st3 && zc != st4)
      #solid = true
    endif
  ; Diagonal
  elseif @mask == 9
    if (real(zc) + imag(zc))%3 != 0
      #solid = true
    endif
  elseif @mask == 10
    if (real(zc) + imag(zc) + 1)%3 != 0
      #solid = true
    endif  
  elseif @mask == 11
    if (real(zc) + imag(zc) + 2)%3 != 0
      #solid = true
    endif
  endif
  
  zc2 = zc*exp(1i*pi/180*@rot)
  
  ; Shape mask
  ; Square
  if @mask2 == 1
    if (real(zc2-smp1) < 0 && real(zc2-smp2) < 0) || \
         (real(zc2-smp1) > 0 && real(zc2-smp2) > 0) || \
       (imag(zc2-smp1) < 0 && imag(zc2-smp2) < 0) || \
       (imag(zc2-smp1) > 0 && imag(zc2-smp2) > 0) 
      #solid = true
    endif
    
  elseif @mask2 == 2
    if (real(zc2-smp1) <= 0 || real(zc2-smp2) <= 0) && \
         (real(zc2-smp1) >= 0 || real(zc2-smp2) >= 0) && \
       (imag(zc2-smp1) <= 0 || imag(zc2-smp2) <= 0) && \
       (imag(zc2-smp1) >= 0 || imag(zc2-smp2) >= 0) 
      #solid = true
    endif
    
  ; Circle
  elseif @mask2 == 3
    if cabs(zc2-(smp1+smp2)/2) > cabs(smp2-smp1)/2
      #solid = true
    endif
    
  elseif @mask2 == 4
    if cabs(zc2-(smp1+smp2)/2) <= cabs(smp2-smp1)/2
      #solid = true
    endif
    
  ; Half Plane  
  elseif @mask2 == 5
    m = (imag(smp2)-imag(smp1))/(real(smp2)-real(smp1))
    h = (real(smp2)*imag(smp1)-real(smp1)*imag(smp2))/(real(smp2)-real(smp1))
    if m*real(zc2) + h < imag(zc2)
      #solid = true
    endif   
  
  elseif @mask2 == 6
    m = (imag(smp2)-imag(smp1))/(real(smp2)-real(smp1))
    h = (real(smp2)*imag(smp1)-real(smp1)*imag(smp2))/(real(smp2)-real(smp1))
    if m*real(zc2) + h > imag(zc2)
      #solid = true
    endif       

  endif
  
  ; Rotation Mode
  if @rmode == 0
    if abs(real(zc))%2 == 0 && abs(imag(zc))%2 == 0
      perot = 1i
    elseif abs(real(zc))%2 == 1 && abs(imag(zc))%2 == 0
      perot = 1
    elseif abs(real(zc))%2 == 0 && abs(imag(zc))%2 == 1
      perot = -1
    elseif abs(real(zc))%2 == 1 && abs(imag(zc))%2 == 1
      perot = -1i
    endif
  elseif @rmode == 1 
    if abs(real(zc))%2 == 0 && abs(imag(zc))%2 == 0
      perot = 1i
    elseif abs(real(zc))%2 == 1 && abs(imag(zc))%2 == 0
      perot = 1
    elseif abs(real(zc))%2 == 0 && abs(imag(zc))%2 == 1
      perot = 1
    elseif abs(real(zc))%2 == 1 && abs(imag(zc))%2 == 1
      perot = -1
    endif
  elseif @rmode == 2
    if abs(real(zc))%2 == 0 && abs(imag(zc))%2 == 0
      perot = -1i
    elseif abs(real(zc))%2 == 1 && abs(imag(zc))%2 == 0
      perot = 1
    elseif abs(real(zc))%2 == 0 && abs(imag(zc))%2 == 1
      perot = 1i
    elseif abs(real(zc))%2 == 1 && abs(imag(zc))%2 == 1
      perot = -1
    endif
    
  elseif @rmode == 3
    if abs(real(zc))%2 == 0 && abs(imag(zc))%2 == 0
      perot = -1i
    elseif abs(real(zc))%2 == 1 && abs(imag(zc))%2 == 0
      perot = 1
    elseif abs(real(zc))%2 == 0 && abs(imag(zc))%2 == 1
      perot = 1i
    elseif abs(real(zc))%2 == 1 && abs(imag(zc))%2 == 1
      perot = 1
    endif
    
  ; Quasiperiodic "Standard"  
  elseif @rmode == 4
    perot = 1
    if real(@seed/(zc+164-74i) - round(@seed/(zc+164-74i))) > 0
      perot = -conj(perot)
    endif
    if real(@seed/(zc-83+134i) - round(@seed/(zc-83+134i))) > 0
      perot = flip(perot)
    endif

  endif
  
  ; Mapping Rotation, Magnification and Shift
  z = z*exp(-1i*pi/180*@mrot)/@mag
  z = z - (.5,.5)
  z = z*perot
  #pixel = z - @center
  
  if @chmode == 1 && zc != (0,0);
    #solid = true
  endif
  
default:
  title = "(4,4) Tiling"
  helpfile = "sam-help/tiling.htm"
  
  param chmode
    caption = "Mode"
    enum = "Tiling" "Drop Points"
    default = 0
  endparam 
  
  param lmode
    caption = "Longitudinal Mode"
    enum = "A" "B" "C" "D" "E" "Quasiperiodic" "Quasiperiodic (Function)"
    default = 2
  endparam
  
  param tmode
    caption = "Transverse Mode"
    enum = "A" "B" "C" "D" "E" "Quasiperiodic" "Quasiperiodic (Function)"
    default = 2
  endparam
  
  param rmode
    caption = "Rotation Mode"
    enum = "A" "B" "C" "D" "Quasiperiodic" "Constant"
    default = 0
  endparam
 
  param mask
    caption = "Mask"
    default = 0
    enum = "None" "Checkerboard In" "Checkerboard Out" \
           "Vertical Stripes In" "Vertical Stripes Out" \
           "Horizontal Stripes In" "Horizontal Stripes Out" \
           "Unselected Tiles" "Selected Tiles" "Diagonal 1" \
           "Diagonal 2" "Diagonal 3"
  endparam 
  
  param size
    caption = "Pattern Size"
    default = 1.0
  endparam
  
  param rot
    caption = "Pattern Rotation"
    default = 0.0
  endparam  
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param mrot
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param mag
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  
  param mask2
    caption = "Shape Mask"
    default = 0
    enum = "None" "Square Out" "Square In" \
           "Circle Out" "Circle In" "Half Plane" \
           "Half Plane Reverse"
  endparam
  
  param smaskp1
    caption = "Shape Mask p1"
    default = (2,2)
  endparam
  param smaskp2
    caption = "Shape Mask p2"
    default = (-2,-2)
  endparam
  
  param p1
    caption = "Point 1"
    default = (1,0)
  endparam
  param p2
    caption = "Point 2"
    default = (1,0)
  endparam
  param p3
    caption = "Point 3"
    default = (1,0)
  endparam
  param p4
    caption = "Point 4"
    default = (1,0)
  endparam
  param p5
    caption = "Point 5"
    default = (1,0)
  endparam
  param p6
    caption = "Point 6"
    default = (1,0)
  endparam
  param p7
    caption = "Point 7"
    default = (1,0)
  endparam
  param p8
    caption = "Point 8"
    default = (1,0)
  endparam
  param p9
    caption = "Point 9"
    default = (1,0)
  endparam
  param p10
    caption = "Point 10"
    default = (1,0)
  endparam
  
  param stile1
    caption = "Selected Tile"
    default = (1e20,0)
  endparam
  param stile2
    caption = "Selected Tile"
    default = (1e20,0)
  endparam
  param stile3
    caption = "Selected Tile"
    default = (1e20,0)
  endparam
  param stile4
    caption = "Selected Tile"
    default = (1e20,0)
  endparam
  
  param ffact
    caption = "Function Factor"
    default = .3
  endparam

  param seed
    caption = "Seed"
    default = 123456234234.0
  endparam
  
  func f1
    caption = "Randomizing Function"
    default = exp()
  endfunc

}

CentralTesselation {
; By Samuel Monnier 20.7.00 -> 22.7.00
transform:
  z = #pixel
  zst = 0
  zst2 = 0
  float arg = 0
  float x = 0
  float y = 0
  float a = 0
  float b = 0
  unrot = 0
  int i = 0
  int n = 0
  int col = 0
  bool bail = false
  bool bail2 = false
  bool bleft = false
  bool bright = false
  bool warn = false
  
  ; Define the points
  float x1 = 0
  float y1 = 0
  float x2 = real(@p1)
  float y2 = imag(@p1)
  float x3 = real(@p2)
  float y3 = imag(@p2)
  float x4 = real(@p3)
  float y4 = imag(@p3)
  float x5 = real(@p4)
  float y5 = imag(@p4)
  float x6 = real(@p5)
  float y6 = imag(@p5)
  float x7 = real(@p6)
  float y7 = imag(@p6)
  float x8 = real(@p7)
  float y8 = imag(@p7)
  float x9 = real(@p8)
  float y9 = imag(@p8)
  float x10 = real(@p9)
  float y10 = imag(@p9)
  float x11 = real(@p10)
  float y11 = imag(@p10)
  float x12 = 1
  float y12 = 0
  ; Compute the slopes and the height
  float m12 = (y2-y1)/(x2-x1)
  float h12 = (x2*y1-x1*y2)/(x2-x1)
  float m23 = (y3-y2)/(x3-x2)
  float h23 = (x3*y2-x2*y3)/(x3-x2)
  float m34 = (y4-y3)/(x4-x3)
  float h34 = (x4*y3-x3*y4)/(x4-x3)
  float m45 = (y5-y4)/(x5-x4)
  float h45 = (x5*y4-x4*y5)/(x5-x4)
  float m56 = (y6-y5)/(x6-x5)
  float h56 = (x6*y5-x5*y6)/(x6-x5)
  float m67 = (y7-y6)/(x7-x6)
  float h67 = (x7*y6-x6*y7)/(x7-x6)
  float m78 = (y8-y7)/(x8-x7)
  float h78 = (x8*y7-x7*y8)/(x8-x7)
  float m89 = (y9-y8)/(x9-x8)
  float h89 = (x9*y8-x8*y9)/(x9-x8)
  float m910 = (y10-y9)/(x10-x9)
  float h910 = (x10*y9-x9*y10)/(x10-x9)
  float m1011 = (y11-y10)/(x11-x10)
  float h1011 = (x11*y10-x10*y11)/(x11-x10)
  float m1112 = (y12-y11)/(x12-x11)
  float h1112 = (x12*y11-x11*y12)/(x12-x11)
  
  if imag(z) > 0
    z = z + @shift/2
  else
    z = z - @shift/2
  endif
   
  arg = atan2(z)
  while i < 2*@order
    i = i + 1
    if arg < (i-@order)*pi/@order && arg > (i-1-@order)*pi/@order
      z = z*exp(-1i*(2*(i-@order)-1)*pi/(2*@order))
      unrot = exp(1i*(2*(i-@order)-1)*pi/(2*@order))
      if i%2 == 0
        col = col + 1
      endif
      if @shift > 0
        if i == 1  || i == @order + 1
          warn = true
        endif
      elseif @shift < 0
        if i == @order || i == 2*@order
          warn = true
        endif
      endif 
    endif
  endwhile
  z = z*1i
  x = real(z)
  y = imag(z)
  a = cos(pi/(2*@order))
  b = 2*sin(pi/(2*@order))
  n = ceil(y/a)
  y = y - floor(y/a)*a
  
  if round(2*(x-b/4)/b)/2 == (n-1)/2
    bleft = true
  endif
  
  if round(2*(x+b/4)/b)/2 == -(n-1)/2
    bright = true
  endif
  
  if n%2 != 0
    x = x - b/2
  endif
  
  if warn == true
    warn = false
    if n < abs(@shift)+1
      warn = true
    endif
  endif
  
  x = x - round(x/b)*b
  if 2*a/b*x + y > a
    x = -x + b/2
    y = -y + a
    unrot = -unrot
    col = col + 1
  elseif -2*a/b*x + y > a
    x = -x - b/2
    y = -y + a
    unrot = -unrot
    col = col + 1
  endif
  
  z = x + 1i*y
  zst = z
  zst2 = zst
  
  i = 0
  
  while i < 3
    i = i + 1
    z = zst
    if i == 1
      z = z + b/2
      z = z*exp(-1i*atan2(b/2+1i*a))
      z = 2*z - 1
    elseif i == 2
      z = z - b/2
      z = z*exp(-1i*atan2(-b/2+1i*a))
      z = 2*z - 1
      bail = !bail
    elseif i == 3
      z = 2*z/b
      bail = !bail
    endif
    
    if real(z) < 0
      z = -z
      bail = !bail
    endif
    
    x = real(z)
    y = imag(z)
      
    ; Point 1 - Point 2
    if x > x1 && x < x2
      if y > m12*x + h12 
        bail = !bail
      endif
    endif
    if x < x1 && x > x2
      if y > m12*x + h12
        bail = !bail
      endif
    endif
    
    ; Point 2 - Point 3
    if x > x2 && x < x3
      if y > m23*x + h23 
        bail = !bail
      endif
    endif
    if x < x2 && x > x3 
     if y > m23*x + h23 
        bail = !bail
      endif
    endif
    
    ; Point 3 - Point 4
    if x > x3 && x < x4
      if y > m34*x + h34 
        bail = !bail
      endif
    endif
    if x < x3 && x > x4 
      if y > m34*x + h34
        bail = !bail
      endif
    endif
    
    ; Point 4 - Point 5
    if x > x4 && x < x5
      if y > m45*x + h45 
        bail = !bail
      endif
    endif
    if x < x4 && x > x5 
      if y > m45*x + h45
        bail = !bail
      endif
    endif
    
    ; Point 5 - Point 6
    if x > x5 && x < x6
      if y > m56*x + h56 
        bail = !bail
      endif
    endif
    if x < x5 && x > x6 
      if y > m56*x + h56
        bail = !bail
      endif
    endif

    ; Point 6 - Point 7
    if x > x6 && x < x7
      if y > m67*x + h67 
        bail = !bail
      endif
    endif
    if x < x6 && x > x7 
      if y > m67*x + h67
        bail = !bail
      endif
    endif

    ; Point 7 - Point 8
    if x > x7 && x < x8
      if y > m78*x + h78 
        bail = !bail
      endif
    endif
    if x < x7 && x > x8 
      if y > m78*x + h78
        bail = !bail
      endif
    endif

    ; Point 8 - Point 9
    if x > x8 && x < x9
      if y > m89*x + h89 
        bail = !bail
      endif
    endif
    if x < x8 && x > x9
      if y > m89*x + h89 
        bail = !bail
      endif
    endif

    ; Point 9 - Point 10
    if x > x9 && x < x10
      if y > m910*x + h910 
        bail = !bail
      endif
    endif
    if x < x9 && x > x10 
      if y > m910*x + h910
        bail = !bail
      endif
    endif

    ; Point 10 - Point 11
    if x > x10 && x < x11
      if y > m1011*x + h1011 
        bail = !bail
      endif
    endif
    if x < x10 && x > x11
      if y > m1011*x + h1011
        bail = !bail
      endif
    endif

    ; Point 11 - Point 12
    if x > x11 && x < x12
      if y > m1112*x + h1112 
        bail = !bail
      endif
    endif
    if x < x11 && x > x12
      if y > m1112*x + h1112
        bail = !bail
      endif
    endif
    
    x = real(zst)
    y = imag(zst)
    
    if bail && !bail2 && i == 1
      if @shift > 0
      if bleft && !warn
        zst2 = zst - 1i*a
        zst2 = zst2*exp(1i*pi/@order)
        zst2 = zst2 + 1i*a
        unrot = unrot*exp(-1i*pi/@order)
      else
        x = -x - b/2
        y = -y + a
        unrot = -unrot
        zst2 = x + 1i*y
      endif
      else
      if bleft
        zst2 = zst - 1i*a
        zst2 = zst2*exp(1i*pi/@order)
        zst2 = zst2 + 1i*a
        unrot = unrot*exp(-1i*pi/@order)
      elseif bright && warn
        x = -x + b/2
        y = -y + a
        unrot = -unrot
        zst2 = x + 1i*y
      else
        x = -x - b/2
        y = -y + a
        unrot = -unrot
        zst2 = x + 1i*y
      endif
      endif
      bail2 = true
      col = col + 1
    elseif bail && !bail2 && i == 2
      if @shift > 0
      if bright
        zst2 = zst - 1i*a
        zst2 = zst2*exp(-1i*pi/@order)
        zst2 = zst2 + 1i*a
        unrot = unrot*exp(1i*pi/@order)
      elseif bleft && warn
        x = -x - b/2
        y = -y + a
        unrot = -unrot
        zst2 = x + 1i*y
      else
        x = -x + b/2
        y = -y + a
        unrot = -unrot
        zst2 = x + 1i*y 
      endif
      else
      if bright && !warn
        zst2 = zst - 1i*a
        zst2 = zst2*exp(-1i*pi/@order)
        zst2 = zst2 + 1i*a
        unrot = unrot*exp(1i*pi/@order)
      else
        x = -x + b/2
        y = -y + a
        unrot = -unrot
        zst2 = x + 1i*y 
      endif
      endif
      bail2 = true
      col = col + 1
    elseif bail && !bail2 && i == 3
      x = -x
      y = -y
      zst2 = x + 1i*y
      col = col + 1
      unrot = -unrot
    endif
    
    
  endwhile
  
  zst2 = zst2 - 1i*a/3
  z = zst2
  
  if !@stab
    unrot = 1
  endif
  
  if @mode == 1
    if col%2 == 0
      #solid = true
    endif
  elseif @mode == 2
    if col%2 == 1
      #solid = true
    endif
  endif
  
  z = z - @center
  z = z*@magn*exp(1i*pi/180*@rot)
  z = z*unrot
  #pixel = z
default:
  title = "Central Tesselations"
  helpfile = "sam-help/centraltess.htm"
  
  
  param mode
    caption = "Mode"
    default = 0
    enum = "All the Tiles" "Tiles I" "Tiles II"
  endparam
  
  param order
    caption = "Symetry Order (/2)"
    default = 5
  endparam
  
  param shift
    caption = "Top/Bottom Part Shift"
    default = 0
  endparam
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot 
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param magn
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param p1
    caption = "Point 1"
    default = (1,0)
  endparam
  param p2
    caption = "Point 2"
    default = (1,0)
  endparam
  param p3
    caption = "Point 3"
    default = (1,0)
  endparam
  param p4
    caption = "Point 4"
    default = (1,0)
  endparam
  param p5
    caption = "Point 5"
    default = (1,0)
  endparam
  param p6
    caption = "Point 6"
    default = (1,0)
  endparam
  param p7
    caption = "Point 7"
    default = (1,0)
  endparam
  param p8
    caption = "Point 8"
    default = (1,0)
  endparam
  param p9
    caption = "Point 9"
    default = (1,0)
  endparam
  param p10
    caption = "Point 10"
    default = (1,0)
  endparam
}

SemiRegularTesselationI {
; By Samuel Monnier, 8.6.00
; Many improvements later...
; Spiral tesselation added : 5.8.00
transform:
  z = #pixel
  zz = 0
  ztest = 0
  zpix = 0
  float r = cabs(z)
  float arg = atan2(z)
  float argc = 0
  float x = 0
  float y = 0
  float kx = 0
  float ky = 0
  float rcx = 0
  float rcy = 0
  float slopey = 0
  
  if @spiral
  
    if @slope == 0
  
      argc = round(arg*@orderx/(2*pi))/@orderx*2*pi
      x = (arg - argc)*@orderx/(2*pi)
 
      y = (log(r)-round(log(r)*@ordery)/@ordery)*@ordery
    
    else
  
      slopey = -1/@slope
  
      kx = round((log(r)-arg*@slope)/(@slope*2*pi)*@orderx)/@orderx
      rcx = @slope*(arg+2*pi*kx)
      x = (log(r) - rcx)*.159/@slope*@orderx
  
      ky = round((log(r)-arg*slopey)/(slopey*2*pi)*@ordery)/@ordery
      rcy = slopey*(arg+2*pi*ky)
      y = (log(r) - rcy)*.159/slopey*@ordery

    endif
  
    x = x*2
    y = y*2*sqrt(3)
  
  else
  
    x = real(z)
    y = imag(z)
    
  endif
    
  float xc = round(x/2)*2
  float yc = round(y/(2*sqrt(3)))*2*sqrt(3)
  float xx = x - xc
  float yy = y - yc
  
  int shapetype = 0
  
  zz = xx + flip(yy)
  
  if !@dual
  
  ztest = zz 
  ztest = ztest + .5 - sqrt(3)/2*1i 
  ztest = ztest*exp(1i*pi/6)
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - 1.5 - sqrt(3)/2*1i 
  ztest = ztest*exp(1i*pi/6)
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + 1.5 + sqrt(3)/2*1i 
  ztest = ztest*exp(1i*pi/6)
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - .5 + sqrt(3)/2*1i 
  ztest = ztest*exp(1i*pi/6)
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 1
  endif  
  
  ztest = zz 
  ztest = ztest - .5 - sqrt(3)/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + .5 + 5*sqrt(3)/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + .5 + sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - .5 - 5*sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
  endif
  
  endif
  
  if @dual
    
    ztest = zz
    ztest = zz + .5 + sqrt(3)/2*1i
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      zpix = ztest
    endif
    
    ztest = zz
    ztest = zz - 1.5 + sqrt(3)/2*1i
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      zpix = ztest
    endif
    
    ztest = zz
    ztest = zz - .5 - sqrt(3)/2*1i
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      zpix = ztest
    endif
    
    ztest = zz
    ztest = zz + 1.5 - sqrt(3)/2*1i
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      zpix = ztest
    endif
    
    ztest = zz
    ztest = ztest*exp(1i*pi/3)
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      shapetype = 1
      if @stab
        ztest = ztest*exp(-1i*pi/3)
      endif  
      zpix = ztest    
    endif
    
    ztest = zz
    ztest = zz + 1 + sqrt(3)*1i
    ztest = ztest*exp(1i*pi/3)
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      shapetype = 1
      if @stab
        ztest = ztest*exp(-1i*pi/3)
      endif  
      zpix = ztest    
    endif
    
    ztest = zz
    ztest = zz - 1 + sqrt(3)*1i
    ztest = ztest*exp(1i*pi/3)
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      shapetype = 1
      if @stab
        ztest = ztest*exp(-1i*pi/3)
      endif  
      zpix = ztest    
    endif
    
    ztest = zz
    ztest = zz + 1 - sqrt(3)*1i
    ztest = ztest*exp(1i*pi/3)
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      shapetype = 1
      if @stab
        ztest = ztest*exp(-1i*pi/3)
      endif  
      zpix = ztest    
    endif
    
    ztest = zz
    ztest = zz - 1 - sqrt(3)*1i
    ztest = ztest*exp(1i*pi/3)
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      shapetype = 1
      if @stab
        ztest = ztest*exp(-1i*pi/3)
      endif  
      zpix = ztest    
    endif
    
    ztest = zz
    ztest = zz + 1
    ztest = ztest*exp(-1i*pi/3)
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      shapetype = 2
      if @stab
        ztest = ztest*exp(1i*pi/3)
      endif  
      zpix = ztest    
    endif
    
    ztest = zz
    ztest = zz - 1
    ztest = ztest*exp(-1i*pi/3)
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      shapetype = 2
      if @stab
        ztest = ztest*exp(1i*pi/3)
      endif  
      zpix = ztest    
    endif
    
    ztest = zz
    ztest = zz - sqrt(3)*1i
    ztest = ztest*exp(-1i*pi/3)
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      shapetype = 2
      if @stab
        ztest = ztest*exp(1i*pi/3)
      endif  
      zpix = ztest    
    endif
    
    ztest = zz
    ztest = zz + sqrt(3)*1i
    ztest = ztest*exp(-1i*pi/3)
    if abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1/sqrt(3) && \
       abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1/sqrt(3)
      shapetype = 2
      if @stab
        ztest = ztest*exp(1i*pi/3)
      endif  
      zpix = ztest    
    endif
    
  endif
  
  zpix = zpix/@magn
  zpix = zpix*exp(1i*pi/180*@rot)
  zpix = zpix - @center
  
  if !@dual
    if @mode == 1
      if shapetype == 0
        #solid = true
      endif
    elseif @mode == 2
      if shapetype == 1
        #solid = true
      endif
    endif
  else
    if @mode == 3
      if shapetype != 0
        #solid = true
      endif
    elseif @mode == 4
      if shapetype != 1
        #solid = true
      endif
    elseif @mode == 5
      if shapetype != 2
        #solid = true
      endif
    endif
  endif
  
  if @stabs
    zpix = zpix*exp(-1i*arg)
  endif
  
  #pixel = zpix  
  
default:
  title = "Semi Regular Tesselation I"
  helpfile = "sam-help/srtess.htm"
  
  param spiral
    caption = "Spiral Tesselation ?"
    default = false
  endparam
  
  param dual
    caption = "Dual Tesselation ?"
    default = false
  endparam
  
  param mode
    caption = "Mode"
    enum = "All the tiles" "Hexagons" "Triangles" \
           "Dual I" "Dual II" "Dual III"
    default = 0
  endparam
  
   param magn
    caption = "Magnification"
    default = 1.0
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam  
  
  param center
    caption = "Center"
    default = (0,0)
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param orderx
    caption = "Spiral Order I"
    default = 6
  endparam
  
  param ordery
    caption = "Spiral Order II"
    default = 6.0
  endparam
  
  param slope
    caption = "Spiral Slope"
    default = .5
  endparam
  
  param stabs
    caption = "Stabilize Spiral ?"
    default = false
  endparam
}

SemiRegularTesselationIII {
; By Samuel Monnier, 8.6.00
; Many improvements later...
; Spiral tesselation added : 5.8.00
transform:
  z = #pixel
  float r = cabs(z)
  float arg = atan2(z)
  float argc = 0
  float x = 0
  float y = 0
  float kx = 0
  float ky = 0
  float rcx = 0
  float rcy = 0
  float slopey = 0
  
  if @spiral
  
    if @slope == 0
  
      argc = round(arg*@orderx/(2*pi))/@orderx*2*pi
      x = (arg - argc)*@orderx/(2*pi)
 
      y = (log(r)-round(log(r)*@ordery)/@ordery)*@ordery
    
    else
  
      slopey = -1/@slope
  
      kx = round((log(r)-arg*@slope)/(@slope*2*pi)*@orderx)/@orderx
      rcx = @slope*(arg+2*pi*kx)
      x = (log(r) - rcx)*.159/@slope*@orderx
  
      ky = round((log(r)-arg*slopey)/(slopey*2*pi)*@ordery)/@ordery
      rcy = slopey*(arg+2*pi*ky)
      y = (log(r) - rcy)*.159/slopey*@ordery

    endif
  
    x = x*(1+sqrt(3))
    y = y*(1+sqrt(3))
  
  else
  
    x = real(z)
    y = imag(z)
    
  endif
  
  float xc = round(x/(1+sqrt(3)))*(1+sqrt(3))
  float yc = round(y/(1+sqrt(3)))*(1+sqrt(3))
  float xx = x - xc
  float yy = y - yc
  zz = xx + flip(yy)
  zpix = 0
  
  int shapetype = 0
  
  if !@dual
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/4 - (1-sqrt(3))/4*1i
  ztest = ztest*exp(1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/4 - (1-sqrt(3))/4*1i
  ztest = ztest*exp(-1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/4 - ((1-sqrt(3))/4 + (1+sqrt(3))/2)*1i
  ztest = ztest*exp(-1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(1i*pi/6)
    endif
    zpix = ztest
  endif
  
   ztest = zz 
  ztest = ztest - (1+sqrt(3))/4 - ((1-sqrt(3))/4 + (1+sqrt(3))/2)*1i
  ztest = ztest*exp(1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/4 - ((1-sqrt(3))/4 - (1+sqrt(3))/2)*1i
  ztest = ztest*exp(-1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/4 - ((1-sqrt(3))/4 - (1+sqrt(3))/2)*1i
  ztest = ztest*exp(1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + sqrt(3)/6 - 1/2*1i
  ztest = ztest*exp(-1i*pi/2)
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = ztest*exp(1i*pi/2)
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - sqrt(3)/6 - 1/2*1i
  ztest = ztest*exp(1i*pi/2)
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = ztest*exp(-1i*pi/2)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + sqrt(3)/3*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + 2*sqrt(3)/3*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest - (sqrt(3)/3 + 1)*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + (sqrt(3)+1)/2 - (1-sqrt(3)/3)/2*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest - (sqrt(3)+1)/2 - (1-sqrt(3)/3)/2*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + (sqrt(3)+1)/2 - (1+sqrt(3)/3)/2*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - (sqrt(3)+1)/2 - (1+sqrt(3)/3)/2*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + 1/2 + sqrt(3)/3 + sqrt(3)/2*1i
  ztest = ztest*exp(1i*pi/2)
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = ztest*exp(-1i*pi/2)
    endif
    zpix = ztest
    shapetype = 3
  endif
  
  ztest = zz 
  ztest = ztest - 1/2 - sqrt(3)/3 + sqrt(3)/2*1i
  ztest = ztest*exp(-1i*pi/2)
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = ztest*exp(1i*pi/2)
    endif
    zpix = ztest
    shapetype = 4
  endif
  
  else
    
    ztest = zz 
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest - (1+sqrt(3))/2 - (1+sqrt(3))/2*1i
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest - (1+sqrt(3))/2 + (1+sqrt(3))/2*1i
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest + (1+sqrt(3))/2 - (1+sqrt(3))/2*1i
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest + (1+sqrt(3))/2 + (1+sqrt(3))/2*1i
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest - 1i
    ztest = -ztest
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      shapetype = 1
      if @stab
        ztest = -ztest
      endif
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest + sqrt(3)*1i
    ztest = -ztest
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      shapetype = 1
      if @stab
        ztest = -ztest
      endif
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest + (sqrt(3)+1)/2 + (sqrt(3)-1)/2*1i
    ztest = -ztest
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      shapetype = 1
      if @stab
        ztest = -ztest
      endif
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest - (sqrt(3)+1)/2 + (sqrt(3)-1)/2*1i
    ztest = -ztest
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      shapetype = 1
      if @stab
        ztest = -ztest
      endif
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest + .5 + sqrt(3)/2*1i
    ztest = 1i*ztest
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      shapetype = 2
      if @stab
        ztest = -1i*ztest
      endif
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest + .5 - (2+sqrt(3))/2*1i
    ztest = 1i*ztest
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      shapetype = 2
      if @stab
        ztest = -1i*ztest
      endif
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest + sqrt(3)/2 - .5*1i
    ztest = -1i*ztest
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      shapetype = 3
      if @stab
        ztest = 1i*ztest
      endif
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest - .5 + sqrt(3)/2*1i
    ztest = -1i*ztest
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      shapetype = 3
      if @stab
        ztest = 1i*ztest
      endif
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest - .5 - (2+sqrt(3))/2*1i
    ztest = -1i*ztest
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      shapetype = 3
      if @stab
        ztest = 1i*ztest
      endif
      zpix = ztest
    endif
    
    ztest = zz 
    ztest = ztest - sqrt(3)/2 - .5*1i
    ztest = 1i*ztest
    if imag(ztest) < .5 && sqrt(3)*real(ztest) - imag(ztest) > -1 && \
       sqrt(3)*real(ztest) + imag(ztest) < 1 && \
       1/sqrt(3)*real(ztest) - imag(ztest) < sqrt(3)/3 && \
       1/sqrt(3)*real(ztest) + imag(ztest) > -sqrt(3)/3
      shapetype = 2
      if @stab
        ztest = -1i*ztest
      endif
      zpix = ztest
    endif
        
            
                
  endif    
      
  zpix = zpix/@magn
  zpix = zpix*exp(1i*pi/180*@rot)
  zpix = zpix - @center
  
  if !@dual
  
  if @mode == 1
    if shapetype == 0
      #solid = true
    endif
  elseif @mode == 2
    if shapetype != 0
      #solid = true
    endif
  elseif @mode == 3
    if shapetype != 1 && shapetype != 3
      #solid = true
    endif
  elseif @mode == 4
    if shapetype != 2 && shapetype != 4
      #solid = true
    endif    
  elseif @mode == 5
    if shapetype != 1 && shapetype != 4
      #solid = true
    endif
  elseif @mode == 6
    if shapetype != 2 && shapetype != 3
      #solid = true
    endif
  endif
  
  else
    if @mode == 7
      if shapetype != 0
        #solid = true
      endif
    elseif @mode == 8
      if shapetype != 1
        #solid = true
      endif
    elseif @mode == 9
      if shapetype != 2
        #solid = true
      endif
    elseif @mode == 10
      if shapetype != 3
        #solid = true
      endif    
    endif
    
  endif
  
  if @stabs
    zpix = zpix*exp(-1i*arg)
  endif
    
  #pixel = zpix  
  
default:
  title = "Semi Regular Tesselation III"
  helpfile = "sam-help/srtess.htm"
  
  param spiral
    caption = "Spiral Tesselation ?"
    default = false
  endparam
  
  param dual
    caption = "Dual Tesselation ?"
    default = false
  endparam
  
  param mode
    caption = "Mode"
    enum = "All the tiles" "Triangles" "Squares"  \
           "Pattern 1" "Pattern 1bis" "Pattern 2" \
           "Pattern 2bis" "Dual I" "Dual II" "Dual III" \
           "Dual IV"
    default = 0
  endparam
  
   param magn
    caption = "Magnification"
    default = 1.0
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam  
  
  param center
    caption = "Center"
    default = (0,0)
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param orderx
    caption = "Spiral Order I"
    default = 4
  endparam
  
  param ordery
    caption = "Spiral Order II"
    default = 6.0
  endparam
  
  param slope
    caption = "Spiral Slope"
    default = .75
  endparam
  
  param stabs
    caption = "Stabilize Spiral ?"
    default = false
  endparam
}

SemiRegularTesselationIV {
; By Samuel Monnier, 9.7.00
; Many improvements later...
; Spiral tesselation added : 6.8.00
transform:
  z = #pixel
  float r = cabs(z)
  float arg = atan2(z)
  float argc = 0
  float x = 0
  float y = 0
  float kx = 0
  float ky = 0
  float rcx = 0
  float rcy = 0
  float slopey = 0
  
  if @spiral
  
    if @slope == 0
  
      argc = round(arg*@orderx/(2*pi))/@orderx*2*pi
      x = (arg - argc)*@orderx/(2*pi)
 
      y = (log(r)-round(log(r)*@ordery)/@ordery)*@ordery
    
    else
  
      slopey = -1/@slope
  
      kx = round((log(r)-arg*@slope)/(@slope*2*pi)*@orderx)/@orderx
      rcx = @slope*(arg+2*pi*kx)
      x = (log(r) - rcx)*.159/@slope*@orderx
  
      ky = round((log(r)-arg*slopey)/(slopey*2*pi)*@ordery)/@ordery
      rcy = slopey*(arg+2*pi*ky)
      y = (log(r) - rcy)*.159/slopey*@ordery

    endif
  
    x = x*(1+sqrt(3))
    y = y*(3+sqrt(3))
  
  else
  
    x = real(z)
    y = imag(z)
    
  endif
  float xc = round(x/(1+sqrt(3)))*(1+sqrt(3))
  float yc = round(y/(3+sqrt(3)))*(3+sqrt(3))
  float xx = x - xc
  float yy = y - yc
  zz = xx + flip(yy)
  zpix = 0
  
  int shapetype = 0
  
  if !@dual
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/4 - (3+sqrt(3))/4*1i
  ztest = ztest*exp(-1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(1i*pi/6) 
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/4 - (3+sqrt(3))/4*1i
  ztest = ztest*exp(1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(-1i*pi/6) 
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/4 + (3+sqrt(3))/4*1i
  ztest = ztest*exp(-1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(1i*pi/6) 
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/4 + (3+sqrt(3))/4*1i
  ztest = ztest*exp(1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(-1i*pi/6) 
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/2
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/2
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (3+sqrt(3))/2*1i
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (3+sqrt(3))/2*1i
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (3+sqrt(3))/3*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - (3+sqrt(3))/3*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest 
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/2 + (3+sqrt(3))/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest 
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/2 + (3+sqrt(3))/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest 
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/2 - (3+sqrt(3))/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/2 - (3+sqrt(3))/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/2 + (3+sqrt(3))/2*1i 
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/2 + (3+sqrt(3))/2*1i 
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/2 - (3+sqrt(3))/2*1i 
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/2 - (3+sqrt(3))/2*1i 
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    zpix = ztest
    shapetype = 2
  endif
  
  else
  
  ztest = zz 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = -ztest 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/2 + (3+sqrt(3))/2*1i 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/2 + (3+sqrt(3))/2*1i 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    zpix = ztest
  endif
  
  ztest = zz
  ztest = ztest + (1+sqrt(3))/2 - (3+sqrt(3))/2*1i 
  ztest = -ztest 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
  endif
  
  ztest = zz
  ztest = ztest - (1+sqrt(3))/2 - (3+sqrt(3))/2*1i 
  ztest = -ztest 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest*exp(1i*pi/3) 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    shapetype = 1
    if @stab
      ztest = ztest*exp(-1i*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = -ztest*exp(1i*pi/3) 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    shapetype = 1
    if @stab
      ztest = -ztest*exp(-1i*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/2 + (3+sqrt(3))/2*1i
  ztest = ztest*exp(1i*pi/3) 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    shapetype = 1
    if @stab
      ztest = ztest*exp(-1i*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz
  ztest = ztest - (1+sqrt(3))/2 - (3+sqrt(3))/2*1i 
  ztest = -ztest*exp(1i*pi/3) 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    shapetype = 1
    if @stab
      ztest = -ztest*exp(-1i*pi/3)
    endif
    zpix = ztest
  endif

  
  
  
  ztest = zz 
  ztest = ztest*exp(-1i*pi/3) 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    shapetype = 2
    if @stab
      ztest = ztest*exp(1i*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = -ztest*exp(-1i*pi/3) 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    shapetype = 2
    if @stab
      ztest = -ztest*exp(1i*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/2 + (3+sqrt(3))/2*1i
  ztest = ztest*exp(-1i*pi/3) 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    shapetype = 2
    if @stab
      ztest = ztest*exp(1i*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz
  ztest = ztest + (1+sqrt(3))/2 - (3+sqrt(3))/2*1i 
  ztest = -ztest*exp(-1i*pi/3) 
  if sqrt(3)*real(ztest) - imag(ztest) < 0 && \
     sqrt(3)*real(ztest) + imag(ztest) > 0 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3) && \
     -1/sqrt(3)*real(ztest) + imag(ztest) < 1 + 1/sqrt(3)
    ztest = ztest - 1i
    shapetype = 2
    if @stab
      ztest = -ztest*exp(1i*pi/3)
    endif
    zpix = ztest
  endif
  
  endif
      
  zpix = zpix/@magn
  zpix = zpix*exp(1i*pi/180*@rot)
  zpix = zpix - @center

  if !@dual
  
  if @mode == 1
    if shapetype != 0
      #solid = true
    endif
  elseif @mode == 2
    if shapetype != 1
      #solid = true
    endif
  elseif @mode == 3
    if shapetype != 2
      #solid = true
    endif
  endif
  
  else
  
  if @mode == 4
    if shapetype != 0
      #solid = true
    endif
  elseif @mode == 5
    if shapetype != 1
      #solid = true
    endif
  elseif @mode == 6
    if shapetype != 2
      #solid = true
    endif
  endif

  endif
  
  if @stabs
    zpix = zpix*exp(-1i*arg)
  endif
  
  #pixel = zpix  
  
default:
  title = "Semi Regular Tesselation IV"
  helpfile = "sam-help/srtess.htm"
  
  param spiral
    caption = "Spiral Tesselation ?"
    default = false
  endparam
  
  param dual
    caption = "Dual Tesselation ?"
    default = false
  endparam
  
  param mode
    caption = "Mode"
    enum = "All the tiles" "Squares" "Triangles" \
           "Hexagons" "Dual I" "Dual II" "Dual III"
    default = 0
  endparam
  
   param magn
    caption = "Magnification"
    default = 1.0
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam  
  
  param center
    caption = "Center"
    default = (0,0)
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param orderx
    caption = "Spiral Order I"
    default = 4
  endparam
  
  param ordery
    caption = "Spiral Order II"
    default = 6.0
  endparam
  
  param slope
    caption = "Spiral Slope"
    default = .4
  endparam
  
  param stabs
    caption = "Stabilize Spiral ?"
    default = false
  endparam
}

SemiRegularTesselationV {
; By Samuel Monnier, 10.7.00
; Many improvements later...
; Spiral tesselation added : 6.8.00
transform:
  z = #pixel
  float r = cabs(z)
  float arg = atan2(z)
  float argc = 0
  float x = 0
  float y = 0
  float kx = 0
  float ky = 0
  float rcx = 0
  float rcy = 0
  float slopey = 0
  
  if @spiral
  
    if @slope == 0
  
      argc = round(arg*@orderx/(2*pi))/@orderx*2*pi
      x = (arg - argc)*@orderx/(2*pi)
 
      y = (log(r)-round(log(r)*@ordery)/@ordery)*@ordery
    
    else
  
      slopey = -1/@slope
  
      kx = round((log(r)-arg*@slope)/(@slope*2*pi)*@orderx)/@orderx
      rcx = @slope*(arg+2*pi*kx)
      x = (log(r) - rcx)*.159/@slope*@orderx
  
      ky = round((log(r)-arg*slopey)/(slopey*2*pi)*@ordery)/@ordery
      rcy = slopey*(arg+2*pi*ky)
      y = (log(r) - rcy)*.159/slopey*@ordery

    endif
  
    x = x*(2+sqrt(3))
    y = y*(3+2*sqrt(3))
  
  else
  
    x = real(z)
    y = imag(z)
    
  endif
  
  float xc = round(x/(2+sqrt(3)))*(2+sqrt(3))
  float yc = round(y/(3+2*sqrt(3)))*(3+2*sqrt(3))
  float xx = x - xc
  float yy = y - yc
  zz = xx + flip(yy)
  zpix = 0
  
  int shapetype = 0
  
  if !@dual
  
  ztest = zz 
  ztest = ztest + (6+5*sqrt(3))/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + (2+sqrt(3))/2 - (3+sqrt(3))/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - (2+sqrt(3))/2 - (3+sqrt(3))/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + (2+sqrt(3))/2 - (9+5*sqrt(3))/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - (2+sqrt(3))/2 - (9+5*sqrt(3))/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - (2+sqrt(3))/2*1i
  if abs(real(ztest)) < 1+sqrt(3)/2 && abs(imag(ztest)) < 1+sqrt(3)/2 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(1/sqrt(3)*real(ztest) - imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(sqrt(3)*real(ztest) + imag(ztest)) < (4+2*sqrt(3))/2 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < (4+2*sqrt(3))/2
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (4+3*sqrt(3))/2*1i
  if abs(real(ztest)) < 1+sqrt(3)/2 && abs(imag(ztest)) < 1+sqrt(3)/2 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(1/sqrt(3)*real(ztest) - imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(sqrt(3)*real(ztest) + imag(ztest)) < (4+2*sqrt(3))/2 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < (4+2*sqrt(3))/2
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (2+sqrt(3))/2 + (1+sqrt(3))/2*1i
  if abs(real(ztest)) < 1+sqrt(3)/2 && abs(imag(ztest)) < 1+sqrt(3)/2 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(1/sqrt(3)*real(ztest) - imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(sqrt(3)*real(ztest) + imag(ztest)) < (4+2*sqrt(3))/2 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < (4+2*sqrt(3))/2
    zpix = ztest
  endif
  
  
  ztest = zz 
  ztest = ztest - (2+sqrt(3))/2 + (1+sqrt(3))/2*1i
  if abs(real(ztest)) < 1+sqrt(3)/2 && abs(imag(ztest)) < 1+sqrt(3)/2 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(1/sqrt(3)*real(ztest) - imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(sqrt(3)*real(ztest) + imag(ztest)) < (4+2*sqrt(3))/2 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < (4+2*sqrt(3))/2
    zpix = ztest
  endif
        
  
  else
  
          
  ztest = zz 
  ztest = ztest + sqrt(3)/2*1i
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3 
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (2+sqrt(3))/2 - (3+sqrt(3))/2*1i
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3 
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (2+sqrt(3))/2 - (3+sqrt(3))/2*1i
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3 
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/2 - .5*1i
  ztest = ztest*exp(-1i*pi/3)
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = ztest*exp(1i*pi/3)
    endif 
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - .5 + (1+sqrt(3))*1i
  ztest = ztest*exp(-1i*pi/3)
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = ztest*exp(1i*pi/3)
    endif 
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - .5 - (2+sqrt(3))*1i
  ztest = ztest*exp(-1i*pi/3)
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = ztest*exp(1i*pi/3)
    endif 
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/2 - .5*1i
  ztest = ztest*exp(1i*pi/3)
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = ztest*exp(-1i*pi/3)
    endif 
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + .5 + (1+sqrt(3))*1i
  ztest = ztest*exp(1i*pi/3)
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = ztest*exp(-1i*pi/3)
    endif 
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + .5 - (2+sqrt(3))*1i
  ztest = ztest*exp(1i*pi/3)
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = ztest*exp(-1i*pi/3)
    endif 
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + .5
  ztest = ztest*exp(1i*2*pi/3)
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = ztest*exp(-1i*2*pi/3)
    endif 
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/2 - (3+2*sqrt(3))/2*1i
  ztest = ztest*exp(1i*2*pi/3)
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = ztest*exp(-1i*2*pi/3)
    endif 
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/2 + (3+2*sqrt(3))/2*1i
  ztest = ztest*exp(1i*2*pi/3)
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = ztest*exp(-1i*2*pi/3)
    endif 
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - .5
  ztest = ztest*exp(-1i*2*pi/3)
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = ztest*exp(1i*2*pi/3)
    endif 
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/2 - (3+2*sqrt(3))/2*1i
  ztest = ztest*exp(-1i*2*pi/3)
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = ztest*exp(1i*2*pi/3)
    endif 
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/2 + (3+2*sqrt(3))/2*1i
  ztest = ztest*exp(-1i*2*pi/3)
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = ztest*exp(1i*2*pi/3)
    endif 
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + (2+sqrt(3))/2*1i
  ztest = -ztest
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = -ztest
    endif 
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest - (2+sqrt(3))/2 - (1+sqrt(3))/2*1i
  ztest = -ztest
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = -ztest
    endif 
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + (2+sqrt(3))/2 - (1+sqrt(3))/2*1i
  ztest = -ztest
  if imag(ztest) > -.5 && 1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = -ztest
    endif 
    zpix = ztest
    shapetype = 2
  endif
  
  endif
  
          
  zpix = zpix/@magn
  zpix = zpix*exp(1i*pi/180*@rot)
  zpix = zpix - @center
  
  if !@dual
  
  if @mode == 1
    if shapetype != 0
      #solid = true
    endif
  elseif @mode == 2
    if shapetype != 1
      #solid = true
    endif
  endif
  
  else
    
  if @mode == 3
    if shapetype != 0
      #solid = true
    endif
  elseif @mode == 4
    if shapetype != 1
      #solid = true
    endif
  elseif @mode == 5
    if shapetype != 2
      #solid = true
    endif
  endif  
    
  endif  
  
  if @stabs
    zpix = zpix*exp(-1i*arg)
  endif
  
  #pixel = zpix  
  
default:
  title = "Semi Regular Tesselation V"
  helpfile = "sam-help/srtess.htm"
  
  param spiral
    caption = "Spiral Tesselation ?"
    default = false
  endparam
  
  param dual
    caption = "Dual Tesselation ?"
    default = false
  endparam
  
  param mode
    caption = "Mode"
    enum = "All the tiles" "Dodecagons" "Triangles" \
           "Dual I" "Dual II" "Dual III"
    default = 0
  endparam
  
   param magn
    caption = "Magnification"
    default = 1.0
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam  
  
  param center
    caption = "Center"
    default = (0,0)
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param orderx
    caption = "Spiral Order I"
    default = 1
  endparam
  
  param ordery
    caption = "Spiral Order II"
    default = 12.0
  endparam
  
  param slope
    caption = "Spiral Slope"
    default = .05
  endparam
  
  param stabs
    caption = "Stabilize Spiral ?"
    default = false
  endparam
}

SemiRegularTesselationVI {
; By Samuel Monnier, 10.7.00
; Many improvements later...
; Spiral tesselation added : 6.8.00
transform:
  z = #pixel
  float r = cabs(z)
  float arg = atan2(z)
  float argc = 0
  float x = 0
  float y = 0
  float kx = 0
  float ky = 0
  float rcx = 0
  float rcy = 0
  float slopey = 0
  
  if @spiral
  
    if @slope == 0
  
      argc = round(arg*@orderx/(2*pi))/@orderx*2*pi
      x = (arg - argc)*@orderx/(2*pi)
 
      y = (log(r)-round(log(r)*@ordery)/@ordery)*@ordery
    
    else
  
      slopey = -1/@slope
  
      kx = round((log(r)-arg*@slope)/(@slope*2*pi)*@orderx)/@orderx
      rcx = @slope*(arg+2*pi*kx)
      x = (log(r) - rcx)*.159/@slope*@orderx
  
      ky = round((log(r)-arg*slopey)/(slopey*2*pi)*@ordery)/@ordery
      rcy = slopey*(arg+2*pi*ky)
      y = (log(r) - rcy)*.159/slopey*@ordery

    endif
  
    x = x
    y = y*(2+sqrt(3))
  
  else
  
    x = real(z)
    y = imag(z)
    
  endif

  float xc = round(x)
  float yc = round(y/(2+sqrt(3)))*(2+sqrt(3))
  float xx = x - xc
  float yy = y - yc
  zz = xx + flip(yy)
  zpix = 0
  
  int shapetype = 0
  
  if !@dual
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3)/6)*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + .5 - (1+2*sqrt(3)/6)*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest - .5 - (1+2*sqrt(3)/6)*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + (sqrt(3)/6)*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + .5 + (2*sqrt(3)/6)*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - .5 + (2*sqrt(3)/6)*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - .5*1i
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + .5 + (1+sqrt(3))/2*1i
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - .5 + (1+sqrt(3))/2*1i
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    zpix = ztest
  endif
  
  else
    
  ztest = zz 
  ztest = ztest - .5 - 1i
  if abs(real(ztest)) < .5 && imag(ztest) > -.5 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + .5 - 1i
  if abs(real(ztest)) < .5 && imag(ztest) > -.5 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + sqrt(3)/2*1i
  if abs(real(ztest)) < .5 && imag(ztest) > -.5 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    zpix = ztest
    shapetype = 1
  endif
  
  
  ztest = zz 
  ztest = ztest - .5
  ztest = -ztest
  if abs(real(ztest)) < .5 && imag(ztest) > -.5 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + .5
  ztest = -ztest
  if abs(real(ztest)) < .5 && imag(ztest) > -.5 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest - (2+sqrt(3))/2*1i
  ztest = -ztest
  if abs(real(ztest)) < .5 && imag(ztest) > -.5 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 3
  endif
  
  ztest = zz 
  ztest = ztest + (2+sqrt(3))/2*1i
  ztest = -ztest
  if abs(real(ztest)) < .5 && imag(ztest) > -.5 && \
     1/sqrt(3)*real(ztest) + imag(ztest) < sqrt(3)/3 && \
     1/sqrt(3)*real(ztest) - imag(ztest) > -sqrt(3)/3
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 3
  endif
  
  
  endif
      
  zpix = zpix/@magn
  zpix = zpix*exp(1i*pi/180*@rot)
  zpix = zpix - @center
  
  if !@dual
  
  if @mode == 1
    if shapetype != 0
      #solid = true
    endif
  elseif @mode == 2
    if shapetype == 0
      #solid = true
    endif
  elseif @mode == 3
    if shapetype != 1
      #solid = true
    endif
  elseif @mode == 4
    if shapetype != 2
      #solid = true
    endif
  endif
  
  endif
  
  if @stabs
    zpix = zpix*exp(-1i*arg)
  endif
  
  #pixel = zpix  
  
default:
  title = "Semi Regular Tesselation VI"
  helpfile = "sam-help/srtess.htm"
  
  param spiral
    caption = "Spiral Tesselation ?"
    default = false
  endparam
  
  param dual
    caption = "Dual Tesselation ?"
    default = false
  endparam
  
  param mode
    caption = "Mode"
    enum = "All the tiles" "Squares" "Triangles" \
           "Triangles Up" "Triangles Down"            
    default = 0
  endparam
  
   param magn
    caption = "Magnification"
    default = 1.0
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam  
  
  param center
    caption = "Center"
    default = (0,0)
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param orderx
    caption = "Spiral Order I"
    default = 16.0
  endparam
  
  param ordery
    caption = "Spiral Order II"
    default = 4.0
  endparam
  
  param slope
    caption = "Spiral Slope"
    default = 1.0
  endparam
  
  param stabs
    caption = "Stabilize Spiral ?"
    default = false
  endparam
}

SemiRegularTesselationVII {
; By Samuel Monnier, 11.7.00
; Many improvements later...
; Spiral tesselation added : 6.8.00
transform:
  z = #pixel
  float r = cabs(z)
  float arg = atan2(z)
  float argc = 0
  float x = 0
  float y = 0
  float kx = 0
  float ky = 0
  float rcx = 0
  float rcy = 0
  float slopey = 0
  
  if @spiral
  
    if @slope == 0
  
      argc = round(arg*@orderx/(2*pi))/@orderx*2*pi
      x = (arg - argc)*@orderx/(2*pi)
 
      y = (log(r)-round(log(r)*@ordery)/@ordery)*@ordery
    
    else
  
      slopey = -1/@slope
  
      kx = round((log(r)-arg*@slope)/(@slope*2*pi)*@orderx)/@orderx
      rcx = @slope*(arg+2*pi*kx)
      x = (log(r) - rcx)*.159/@slope*@orderx
  
      ky = round((log(r)-arg*slopey)/(slopey*2*pi)*@ordery)/@ordery
      rcy = slopey*(arg+2*pi*ky)
      y = (log(r) - rcy)*.159/slopey*@ordery

    endif
  
    x = x*(3+sqrt(3))
    y = y*(3+3*sqrt(3))
  
  else
  
    x = real(z)
    y = imag(z)
    
  endif
  
  float xc = round(x/(3+sqrt(3)))*(3+sqrt(3))
  float yc = round(y/(3+3*sqrt(3)))*(3+3*sqrt(3))
  float xx = x - xc
  float yy = y - yc
  zz = xx + flip(yy)
  zpix = 0
  
  int shapetype = 0
  
  if !@dual
  
  ztest = zz 
  ztest = ztest - (3+sqrt(3))/2
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (3+sqrt(3))/2
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (3+sqrt(3))/4 + (3+3*sqrt(3))/4*1i
  ztest = ztest*exp(1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (3+sqrt(3))/4 - (3+3*sqrt(3))/4*1i
  ztest = ztest*exp(1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (3+sqrt(3))/4 + (3+3*sqrt(3))/4*1i
  ztest = ztest*exp(-1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (3+sqrt(3))/4 - (3+3*sqrt(3))/4*1i
  ztest = ztest*exp(-1i*pi/6)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (3+3*sqrt(3))/2*1i
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (3+3*sqrt(3))/2*1i
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    zpix = ztest
  endif
  
  ztest = zz 
  if abs(real(ztest)) < 1+sqrt(3)/2 && abs(imag(ztest)) < 1+sqrt(3)/2 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(1/sqrt(3)*real(ztest) - imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(sqrt(3)*real(ztest) + imag(ztest)) < (4+2*sqrt(3))/2 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < (4+2*sqrt(3))/2
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz
  ztest = ztest - (3+sqrt(3))/2 - (3+3*sqrt(3))/2*1i 
  if abs(real(ztest)) < 1+sqrt(3)/2 && abs(imag(ztest)) < 1+sqrt(3)/2 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(1/sqrt(3)*real(ztest) - imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(sqrt(3)*real(ztest) + imag(ztest)) < (4+2*sqrt(3))/2 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < (4+2*sqrt(3))/2
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz
  ztest = ztest + (3+sqrt(3))/2 - (3+3*sqrt(3))/2*1i 
  if abs(real(ztest)) < 1+sqrt(3)/2 && abs(imag(ztest)) < 1+sqrt(3)/2 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(1/sqrt(3)*real(ztest) - imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(sqrt(3)*real(ztest) + imag(ztest)) < (4+2*sqrt(3))/2 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < (4+2*sqrt(3))/2
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz
  ztest = ztest - (3+sqrt(3))/2 + (3+3*sqrt(3))/2*1i 
  if abs(real(ztest)) < 1+sqrt(3)/2 && abs(imag(ztest)) < 1+sqrt(3)/2 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(1/sqrt(3)*real(ztest) - imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(sqrt(3)*real(ztest) + imag(ztest)) < (4+2*sqrt(3))/2 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < (4+2*sqrt(3))/2
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz
  ztest = ztest + (3+sqrt(3))/2 + (3+3*sqrt(3))/2*1i 
  if abs(real(ztest)) < 1+sqrt(3)/2 && abs(imag(ztest)) < 1+sqrt(3)/2 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(1/sqrt(3)*real(ztest) - imag(ztest)) < (6+4*sqrt(3))/6 && \
     abs(sqrt(3)*real(ztest) + imag(ztest)) < (4+2*sqrt(3))/2 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < (4+2*sqrt(3))/2
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + (3+sqrt(3))/2 + (1+sqrt(3))/2*1i
  ztest = ztest*exp(1i*pi/6) 
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest - (3+sqrt(3))/2 + (1+sqrt(3))/2*1i
  ztest = ztest*exp(1i*pi/6) 
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + (3+sqrt(3))/2 - (1+sqrt(3))/2*1i
  ztest = ztest*exp(1i*pi/6) 
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest - (3+sqrt(3))/2 - (1+sqrt(3))/2*1i
  ztest = ztest*exp(1i*pi/6) 
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))*1i
  ztest = ztest*exp(1i*pi/6) 
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))*1i
  ztest = ztest*exp(1i*pi/6) 
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
 
  else
    
  ztest = zz 
  ztest = ztest - (2+sqrt(3))/2 - .5*1i
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - .5 - (2+sqrt(3))/2*1i
  ztest = ztest*exp(-1i*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(1i*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(3))/2 - (1+sqrt(3))/2*1i
  ztest = ztest*exp(-1i*2*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(1i*2*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (2+sqrt(3))/2 + .5*1i
  ztest = -ztest 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + .5 + (2+sqrt(3))/2*1i
  ztest = ztest*exp(1i*2*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(-1i*2*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(3))/2 + (1+sqrt(3))/2*1i
  ztest = ztest*exp(1i*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(-1i*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + .5 + (2+3*sqrt(3))/2*1i
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (2+sqrt(3))/2 + (1+2*sqrt(3))/2*1i
  ztest = ztest*exp(-1i*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(1i*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - 1 + (1+sqrt(3))*1i
  ztest = ztest*exp(-1i*2*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(1i*2*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - .5 - (2+3*sqrt(3))/2*1i
  ztest = -ztest 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (2+sqrt(3))/2 - (1+2*sqrt(3))/2*1i
  ztest = ztest*exp(1i*2*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(-1i*2*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + 1 - (1+sqrt(3))*1i
  ztest = ztest*exp(1i*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(-1i*pi/3)
    endif
    zpix = ztest
  endif
  
  ztest = conj(zz) 
  ztest = ztest - (2+sqrt(3))/2 - .5*1i
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    zpix = conj(ztest)
    shapetype = 1
  endif
  
  ztest = conj(zz) 
  ztest = ztest - .5 - (2+sqrt(3))/2*1i
  ztest = ztest*exp(-1i*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(1i*pi/3)
    endif
    zpix = conj(ztest)
    shapetype = 1
  endif
  
  ztest = conj(zz) 
  ztest = ztest + (1+sqrt(3))/2 - (1+sqrt(3))/2*1i
  ztest = ztest*exp(-1i*2*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(1i*2*pi/3)
    endif
    zpix = conj(ztest)
    shapetype = 1
  endif
  
  ztest = conj(zz) 
  ztest = ztest + (2+sqrt(3))/2 + .5*1i
  ztest = -ztest 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = -ztest
    endif
    zpix = conj(ztest)
    shapetype = 1
  endif
  
  ztest = conj(zz) 
  ztest = ztest + .5 + (2+sqrt(3))/2*1i
  ztest = ztest*exp(1i*2*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(-1i*2*pi/3)
    endif
    zpix = conj(ztest)
    shapetype = 1
  endif
  
  ztest = conj(zz) 
  ztest = ztest - (1+sqrt(3))/2 + (1+sqrt(3))/2*1i
  ztest = ztest*exp(1i*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(-1i*pi/3)
    endif
    zpix = conj(ztest)
    shapetype = 1
  endif
  
  ztest = conj(zz) 
  ztest = ztest + .5 + (2+3*sqrt(3))/2*1i
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    zpix = conj(ztest)
    shapetype = 1
  endif
  
  ztest = conj(zz) 
  ztest = ztest + (2+sqrt(3))/2 + (1+2*sqrt(3))/2*1i
  ztest = ztest*exp(-1i*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(1i*pi/3)
    endif
    zpix = conj(ztest)
    shapetype = 1
  endif
  
  ztest = conj(zz) 
  ztest = ztest - 1 + (1+sqrt(3))*1i
  ztest = ztest*exp(-1i*2*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(1i*2*pi/3)
    endif
    zpix = conj(ztest)
    shapetype = 1
  endif
  
  ztest = conj(zz) 
  ztest = ztest - .5 - (2+3*sqrt(3))/2*1i
  ztest = -ztest 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = -ztest
    endif
    zpix = conj(ztest)
    shapetype = 1
  endif
  
  ztest = conj(zz) 
  ztest = ztest - (2+sqrt(3))/2 - (1+2*sqrt(3))/2*1i
  ztest = ztest*exp(1i*2*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(-1i*2*pi/3)
    endif
    zpix = conj(ztest)
    shapetype = 1
  endif
  
  ztest = conj(zz) 
  ztest = ztest + 1 - (1+sqrt(3))*1i
  ztest = ztest*exp(1i*pi/3) 
  if real(ztest) < .5 && imag(ztest) > -.5 && real(ztest) - sqrt(3)*imag(ztest) > -1
    if @stab
      ztest = ztest*exp(-1i*pi/3)
    endif
    zpix = conj(ztest)
    shapetype = 1
  endif
  
  endif
      
  zpix = zpix/@magn
  zpix = zpix*exp(1i*pi/180*@rot)
  zpix = zpix - @center
  
  if !@dual
  
  if @mode == 1
    if shapetype != 0
      #solid = true
    endif
  elseif @mode == 2
    if shapetype != 1
      #solid = true
    endif
  elseif @mode == 3
    if shapetype != 2
      #solid = true
    endif
  endif
  
  else
  
  if @mode == 4
    if shapetype != 0
      #solid = true
    endif
  elseif @mode == 5
    if shapetype == 0
      #solid = true
    endif
  endif
  
  endif
  
  if @stabs
    zpix = zpix*exp(-1i*arg)
  endif
  
  #pixel = zpix  
  
default:
  title = "Semi Regular Tesselation VII"
  helpfile = "sam-help/srtess.htm"
  
  param spiral
    caption = "Spiral Tesselation ?"
    default = false
  endparam
  
  param dual
    caption = "Dual Tesselation ?"
    default = false
  endparam
  
  param mode
    caption = "Mode"
    enum = "All the tiles" "Squares" "Dodecagons" \
           "Hexagons" "Dual I" "Dual II"
    default = 0
  endparam
  
   param magn
    caption = "Magnification"
    default = 1.0
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam  
  
  param center
    caption = "Center"
    default = (0,0)
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param orderx
    caption = "Spiral Order I"
    default = 3.0
  endparam
  
  param ordery
    caption = "Spiral Order II"
    default = 6.0
  endparam
  
  param slope
    caption = "Spiral Slope"
    default = .3
  endparam
  
  param stabs
    caption = "Stabilize Spiral ?"
    default = false
  endparam
}

SemiRegularTesselationVIII {
; By Samuel Monnier, 11.7.00
; Many improvements later...
; Spiral tesselation added : 5.8.00
transform:
  z = #pixel
  float r = cabs(z)
  float arg = atan2(z)
  float argc = 0
  float x = 0
  float y = 0
  float kx = 0
  float ky = 0
  float rcx = 0
  float rcy = 0
  float slopey = 0
  
  if @spiral
  
    if @slope == 0
  
      argc = round(arg*@orderx/(2*pi))/@orderx*2*pi
      x = (arg - argc)*@orderx/(2*pi)
 
      y = (log(r)-round(log(r)*@ordery)/@ordery)*@ordery
    
    else
  
      slopey = -1/@slope
  
      kx = round((log(r)-arg*@slope)/(@slope*2*pi)*@orderx)/@orderx
      rcx = @slope*(arg+2*pi*kx)
      x = (log(r) - rcx)*.159/@slope*@orderx
  
      ky = round((log(r)-arg*slopey)/(slopey*2*pi)*@ordery)/@ordery
      rcy = slopey*(arg+2*pi*ky)
      y = (log(r) - rcy)*.159/slopey*@ordery

    endif
  
    x = x*7*14
    y = y*3/2*sqrt(3)*14
  
  else
  
    x = real(z)
    y = imag(z)
    
  endif
    
  float yc = round((y-sqrt(3)/4)/(3/2*sqrt(3)))*3/2*sqrt(3)
  x = x + .5*round((y-sqrt(3)/4)/(3/2*sqrt(3)))
  float xc = round(x/7)*7
  float xx = x - xc
  float yy = y - yc
  zz = xx + flip(yy)
  zpix = 0
  
  int shapetype = 0
  
  if !@dual
  
  ztest = zz 
  ztest = ztest - sqrt(3)/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - 1 - sqrt(3)/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - 3 - sqrt(3)/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + 1 - sqrt(3)/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - .5 - 2*sqrt(3)/3*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + 1.5 - 2*sqrt(3)/3*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + 2.5 - 2*sqrt(3)/3*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + 3.5 - 2*sqrt(3)/3*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - 3.5 - 2*sqrt(3)/3*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - 1.5 + 2*sqrt(3)/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - 2.5 + 2*sqrt(3)/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + 1.5 + 2*sqrt(3)/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + 3.5 + 2*sqrt(3)/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - 3.5 + 2*sqrt(3)/6*1i
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - .5 - 2*sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + .5 - 2*sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + 1.5 - 2*sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + 3.5 - 2*sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - 3.5 - 2*sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - 3 - 5*sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - 1 - 5*sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + 2 - 5*sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + 3 - 5*sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + 1 + sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - 1 + sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - 2 + sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest - 3 + sqrt(3)/6*1i
  ztest = -ztest
  if imag(ztest) > -sqrt(3)/6 && sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest) && \
     -sqrt(3)*real(ztest) + 2*sqrt(3)/6 > imag(ztest)
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz 
  ztest = ztest + .5 - sqrt(3)*1i
  ztest = ztest*exp(1i*pi/6)  
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + sqrt(3)/2*1i
  ztest = ztest*exp(1i*pi/6)  
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest - 2 - sqrt(3)/2*1i
  ztest = ztest*exp(1i*pi/6)  
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz 
  ztest = ztest + 2.5 
  ztest = ztest*exp(1i*pi/6)  
  if abs(real(ztest)) < sqrt(3)/2 && abs(1/sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     abs(1/sqrt(3)*real(ztest) + imag(ztest)) < 1
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif


  else
    
  ztest = zz
  ztest = ztest - .5
  ztest = ztest*exp(1i*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz
  ztest = ztest + 2 - sqrt(3)/2*1i
  ztest = ztest*exp(1i*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz
  ztest = ztest - 2.5 - sqrt(3)*1i
  ztest = ztest*exp(1i*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz
  ztest = ztest - 3 + sqrt(3)/2*1i
  ztest = ztest*exp(1i*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(-1i*pi/6)
    endif
    zpix = ztest
  endif
  
  ztest = zz
  ztest = ztest + 1 - sqrt(3)/2*1i
  ztest = ztest*exp(-1i*5*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(1i*5*pi/6)
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz
  ztest = ztest + 3 + sqrt(3)/2*1i
  ztest = ztest*exp(-1i*5*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(1i*5*pi/6)
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz
  ztest = ztest + 3.5 - sqrt(3)*1i
  ztest = ztest*exp(-1i*5*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(1i*5*pi/6)
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz
  ztest = ztest - 3.5 - sqrt(3)*1i
  ztest = ztest*exp(-1i*5*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(1i*5*pi/6)
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz
  ztest = ztest - 1.5
  ztest = ztest*exp(-1i*5*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(1i*5*pi/6)
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz
  ztest = ztest + .5
  ztest = ztest*exp(-1i*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz
  ztest = ztest - 2 + sqrt(3)/2*1i
  ztest = ztest*exp(-1i*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz
  ztest = ztest - 1.5 - sqrt(3)*1i
  ztest = ztest*exp(-1i*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz
  ztest = ztest + 3 - sqrt(3)/2*1i
  ztest = ztest*exp(-1i*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(1i*pi/6)
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz
  ztest = ztest - sqrt(3)/2*1i
  ztest = ztest*exp(1i*5*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(-1i*5*pi/6)
    endif
    zpix = ztest
    shapetype = 3
  endif
  
  ztest = zz
  ztest = ztest + 2 + sqrt(3)/2*1i
  ztest = ztest*exp(1i*5*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(-1i*5*pi/6)
    endif
    zpix = ztest
    shapetype = 3
  endif
  
  ztest = zz
  ztest = ztest + 2.5 - sqrt(3)*1i
  ztest = ztest*exp(1i*5*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(-1i*5*pi/6)
    endif
    zpix = ztest
    shapetype = 3
  endif
  
  ztest = zz
  ztest = ztest - 2.5
  ztest = ztest*exp(1i*5*pi/6)
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = ztest*exp(-1i*5*pi/6)
    endif
    zpix = ztest
    shapetype = 3
  endif
  
  ztest = zz
  ztest = ztest - 1 + sqrt(3)/2*1i
  ztest = 1i*ztest
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = -1i*ztest
    endif
    zpix = ztest
    shapetype = 4
  endif
  
  ztest = zz
  ztest = ztest - .5 - sqrt(3)*1i
  ztest = 1i*ztest
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = -1i*ztest
    endif
    zpix = ztest
    shapetype = 4
  endif
  
  ztest = zz
  ztest = ztest + 1.5
  ztest = 1i*ztest
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = -1i*ztest
    endif
    zpix = ztest
    shapetype = 4
  endif
  
  ztest = zz
  ztest = ztest - 3 - sqrt(3)/2*1i
  ztest = 1i*ztest
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = -1i*ztest
    endif
    zpix = ztest
    shapetype = 4
  endif
  
  ztest = zz
  ztest = ztest - 1 - sqrt(3)/2*1i
  ztest = -1i*ztest
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = 1i*ztest
    endif
    zpix = ztest
    shapetype = 5
  endif
  
  ztest = zz
  ztest = ztest + 1 + sqrt(3)/2*1i
  ztest = -1i*ztest
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = 1i*ztest
    endif
    zpix = ztest
    shapetype = 5
  endif
  
  ztest = zz
  ztest = ztest + 1.5 - sqrt(3)*1i
  ztest = -1i*ztest
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = 1i*ztest
    endif
    zpix = ztest
    shapetype = 5
  endif
  
  ztest = zz
  ztest = ztest + 3.5
  ztest = -1i*ztest
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = 1i*ztest
    endif
    zpix = ztest
    shapetype = 5
  endif
  
  ztest = zz
  ztest = ztest - 3.5
  ztest = -1i*ztest
  if abs(sqrt(3)*real(ztest) + imag(ztest)) < 1 && \
     abs(sqrt(3)*real(ztest) - imag(ztest)) < 1 && \
     imag(ztest) < .5
    if @stab
      ztest = 1i*ztest
    endif
    zpix = ztest
    shapetype = 5
  endif
  
  endif
      
  zpix = zpix/@magn
  zpix = zpix*exp(1i*pi/180*@rot)
  zpix = zpix - @center
  
  if !@dual
  
  if @mode == 1
    if shapetype != 2
      #solid = true
    endif
  elseif @mode == 2
    if shapetype == 2
      #solid = true
    endif
  elseif @mode == 3
    if shapetype != 0
      #solid = true
    endif
  elseif @mode == 4
    if shapetype != 1
      #solid = true
    endif
  endif
  
  else
  
  if @mode == 5
    if shapetype != 0
      #solid = true
    endif
  elseif @mode == 6
    if shapetype != 1
      #solid = true
    endif
  elseif @mode == 7
    if shapetype != 2
      #solid = true
    endif
  elseif @mode == 8
    if shapetype != 3
      #solid = true
    endif
  elseif @mode == 9
    if shapetype != 4
      #solid = true
    endif
  elseif @mode == 10
    if shapetype != 5
      #solid = true
    endif
  endif
  
  endif
  
  if @stabs
    zpix = zpix*exp(-1i*arg)
  endif
  
  #pixel = zpix  
  
default:
  title = "Semi Regular Tesselation VIII"
  helpfile = "sam-help/srtess.htm"
  
  param spiral
    caption = "Spiral Tesselation ?"
    default = false
  endparam
  
  param dual
    caption = "Dual Tesselation ?"
    default = false
  endparam
  
  param mode
    caption = "Mode"
    enum = "All the tiles" "Hexagons" "Triangles" \
           "Triangles Up" "Triangles Down" "Dual I" \
           "Dual II" "Dual III" "Dual IV" "Dual V" "Dual VI"
    default = 0
  endparam
  
   param magn
    caption = "Magnification"
    default = 1.0
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam  
  
  param center
    caption = "Center"
    default = (0,0)
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param orderx
    caption = "Spiral Order I"
    default = .5
  endparam
  
  param ordery
    caption = "Spiral Order II"
    default = .2
  endparam
  
  param slope
    caption = "Spiral Slope"
    default = 0.0
  endparam
  
  param stabs
    caption = "Stabilize Spiral ?"
    default = false
  endparam
}

KDPenroseTiling {
; By Samuel Monnier, 20.8.00 -> 27.8.00
transform:
  float phi = (1+sqrt(5))/2
  z = #pixel
  z = z/24
  z = z + .617*1i
  nz = z
  zc = 0
  zcrm = 1
  float x = real(z)
  float y = imag(z)
  unrot = 1.0
  int shape = 0
  int i = 0
     
  while i < @niter
    i = i + 1
    
    if shape == 0
      
      ztest = z + phi*sin(pi/5) - phi*cos(pi/5)*1i
      ztest = ztest*exp(1i*3*pi/5)
      ztest = phi*ztest
      x = real(ztest)
      y = imag(ztest)
      if cotan(pi/5)*x + y > 0 && cotan(pi/5)*x - y < 0 && \
         tan(pi/10)*x - y > -phi && tan(pi/10)*x + y < phi
        nz = ztest
        shape = 0
        unrot = unrot*exp(-1i*3*pi/5)
        zc = zc - zcrm*(phi*sin(pi/5) - phi*cos(pi/5)*1i)
        zcrm = zcrm/phi* exp(-1i*3*pi/5)
      endif
      
      ztest = z - phi*sin(pi/5) - phi*cos(pi/5)*1i
      ztest = ztest*exp(-1i*3*pi/5)
      ztest = phi*ztest
      x = real(ztest)
      y = imag(ztest)
      if cotan(pi/5)*x + y > 0 && cotan(pi/5)*x - y < 0 && \
         tan(pi/10)*x - y > -phi && tan(pi/10)*x + y < phi
        nz = ztest
        shape = 0
        unrot = unrot*exp(1i*3*pi/5)
        zc = zc + zcrm*(phi*sin(pi/5) + phi*cos(pi/5)*1i)
        zcrm = zcrm/phi*exp(1i*3*pi/5)           
      endif
      
      ztest = z
      ztest = ztest*exp(1i*pi/5)
      ztest = phi*ztest
      x = real(ztest)
      y = imag(ztest)
      if cotan(pi/5)*x + y > 0 && cotan(pi/5)*x - y < 0 && \
         (-tan(pi/10)*x - y > -1 || tan(pi/10)*x - y > -1)
        nz = ztest
        shape = 1
        unrot = unrot*exp(-1i*pi/5)
        zcrm = zcrm/phi*exp(-1i*pi/5) 
      endif
      
      ztest = z
      ztest = ztest*exp(-1i*pi/5)
      ztest = phi*ztest
      x = real(ztest)
      y = imag(ztest)
      if cotan(pi/5)*x + y > 0 && cotan(pi/5)*x - y < 0 && \
         (-tan(pi/10)*x - y > -1 || tan(pi/10)*x - y > -1)
        nz = ztest
        shape = 1
        unrot = unrot*exp(1i*pi/5)
        zcrm = zcrm/phi*exp(1i*pi/5) 
      endif
      
    elseif shape == 1
      
      ztest = z
      ztest = phi*ztest
      x = real(ztest)
      y = imag(ztest)
      if cotan(pi/5)*x + y > 0 && cotan(pi/5)*x - y < 0 && \
         tan(pi/10)*x - y > -phi && tan(pi/10)*x + y < phi
        nz = ztest
        shape = 0
        zcrm = zcrm/phi 
      endif
      
      ztest = z
      ztest = z - phi*sin(pi/5) - phi*cos(pi/5)*1i
      ztest = ztest*exp(-1i*4*pi/5)
      ztest = phi*ztest
      x = real(ztest)
      y = imag(ztest)
      if cotan(pi/5)*x + y > 0 && cotan(pi/5)*x - y < 0 && \
         (-tan(pi/10)*x - y > -1 || tan(pi/10)*x - y > -1)
        nz = ztest
        shape = 1
        unrot = unrot*exp(1i*4*pi/5)
        zc = zc + zcrm*(phi*sin(pi/5) + phi*cos(pi/5)*1i)
        zcrm = zcrm/phi*exp(1i*4*pi/5) 
      endif
      
      ztest = z
      ztest = z + phi*sin(pi/5) - phi*cos(pi/5)*1i
      ztest = ztest*exp(1i*4*pi/5)
      ztest = phi*ztest
      x = real(ztest)
      y = imag(ztest)
      if cotan(pi/5)*x + y > 0 && cotan(pi/5)*x - y < 0 && \
         (-tan(pi/10)*x - y > -1 || tan(pi/10)*x - y > -1)
        nz = ztest
        shape = 1
        unrot = unrot*exp(-1i*4*pi/5)
        zc = zc - zcrm*(phi*sin(pi/5) - phi*cos(pi/5)*1i)
        zcrm = zcrm/phi*exp(-1i*4*pi/5) 
      endif
      
      
    endif
      
    z = nz
      
  endwhile
  
  if shape == 0
    zc = (zc + zcrm*1i)*24 - .617*24*1i
  else
    zc = (zc + zcrm*1i*2/3)*24 - .617*24*1i
  endif    
  
  if @mode == 1
    if shape == 1
      #solid = true
    endif
  elseif @mode == 2
    if shape == 0
      #solid = true
    endif
  elseif @mode == 3
    if shape == 0
      z = z - 10
    else
      z = z + 10
    endif
  elseif @mode == 4
    z = zc
  endif
  
  zcm = zc - @zccenter
  zcm = zcm*exp(1i*pi/180*@zcrot)
  zcm = zcm/@zcsize
  
  if @mask == 1
    if !@invm
      if cabs(zcm) < 1
        #solid = true
      endif
    else
      if cabs(zcm) > 1
        #solid = true
      endif
    endif
  elseif @mask == 2
    if !@invm
      if cabs(real(zcm)) < 1 && cabs(imag(zcm)) < 1
        #solid = true
      endif
    else
      if cabs(real(zcm)) > 1 || cabs(imag(zcm)) > 1
        #solid = true
      endif
    endif
  elseif @mask == 3
    if !@invm
      if imag(zcm) > 0 
        #solid = true
      endif
    else
      if imag(zcm) < 0 
        #solid = true
      endif
    endif
  elseif @mask == 4
    zcm = -zcm*1i
    float arg = atan2(zcm)
    arg = round(arg/(2*pi)*5)*(2*pi)/5
    zcm = zcm*exp(-1i*arg)
    if !@invm
      if real(zcm) > 1
        #solid = true
      endif
    else
      if real(zcm) < 1
        #solid = true
      endif
    endif
  endif

  int mode = @mode
    
  if shape == 0 && mode != 4
    z = z - 1i
  elseif mode != 4
    z = z - 1/phi*1i
  endif
  
  if @stab
    z = z*unrot
  endif
  
  z = z/@magn
  z = z*exp(1i*pi/180*@rot)
  z = z - @center
  
  #pixel = z

  
default:
  title = "Kite & Dart Penrose Tiling"
  helpfile = "sam-help/penrose.htm"
  
  param mode
    caption = "Mode"
    default = 0
    enum = "All the tiles" "Kite" "Dart" "Kite & Dart Frame" "Mosaic"
  endparam
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param magn
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  
  param mask
    caption = "Mask"
    default = 0
    enum = "None" "Circle" "Square" "Half Plane" "Pentagon"
  endparam
  
  param invm
    caption = "Inverse Mask ?"
    default = false
  endparam
  
  param zccenter
    caption = "Mask Center"
    default = (0,0)
  endparam
  
  param zcrot
    caption = "Mask Rotation"
    default = 0.0
  endparam
  
  param zcsize
    caption = "Mask Size"
    default = 1.0
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param niter
    caption = "Number of Iterations"
    default = 10
  endparam
  

}

TFPenroseTiling {
; By Samuel Monnier, 19.8.00 -> 27.8.00
transform:
  float phi = (1+sqrt(5))/2
  z = #pixel + .7*1i
  z = z/15
  nz = z
  zc = 0
  zcrm = 1
  float x = real(z)
  float y = imag(z)
  unrot = 1
  int shape = 0
  int i = 0
     
  while i < @niter
    i = i + 1
    
    if shape == 0
      
      ztest = z + (1-phi)/2*1i
      ztest = -phi*ztest
      x = real(ztest)
      y = imag(ztest)
      if abs(x + tan(pi/5)*y) < sin(pi/5) && \
         abs(x - tan(pi/5)*y) < sin(pi/5)
        nz = ztest
        shape = 0
        unrot = -unrot
        zc = zc - zcrm*(1-phi)/2*1i
        zcrm = -zcrm/phi
      endif
      
      ztest = z + phi/2*1i
      ztest = ztest*exp(1i*4*pi/5)
      ztest = ztest + 1/2*1i
      ztest = phi*ztest
      x = real(ztest)
      y = imag(ztest)
      if abs(x + tan(pi/5)*y) < sin(pi/5) && \
         abs(x - tan(pi/5)*y) < sin(pi/5)
        nz = ztest
        shape = 0
        unrot = unrot*exp(-1i*4*pi/5)
        zc = zc - zcrm*(phi/2*1i+1/2*1i*exp(-1i*4*pi/5))
        zcrm = zcrm/phi*exp(-1i*4*pi/5)
      endif
      
      ztest = z + phi/2*1i
      ztest = ztest*exp(-1i*4*pi/5)
      ztest = ztest + 1/2*1i
      ztest = phi*ztest
      x = real(ztest)
      y = imag(ztest)
      if abs(x + tan(pi/5)*y) < sin(pi/5) && \
         abs(x - tan(pi/5)*y) < sin(pi/5)
        nz = ztest
        shape = 0
        unrot = unrot*exp(1i*4*pi/5)
        zc = zc - zcrm*(phi/2*1i+1/2*1i*exp(1i*4*pi/5))
        zcrm = zcrm/phi*exp(1i*4*pi/5)
      endif
      
      ztest = z + (phi/2-1/phi)*1i
      ztest = ztest*exp(1i*3*pi/10)
      ztest = phi*ztest
      ztest = ztest - (cos(pi/10))*1i
      x = real(ztest)
      y = imag(ztest)
      if abs(x + tan(pi/10)*y) < sin(pi/10) && \
         abs(x - tan(pi/10)*y) < sin(pi/10)
        nz = ztest
        shape = 1
        unrot = unrot*exp(-1i*3*pi/10)
        zc = zc - zcrm*(phi/2-1/phi-cos(pi/10)/phi*exp(-1i*3*pi/10))*1i
        zcrm = zcrm/phi*exp(-1i*3*pi/10)
      endif
      
      ztest = z + (phi/2-1/phi)*1i
      ztest = ztest*exp(-1i*3*pi/10)
      ztest = phi*ztest
      ztest = -ztest + (cos(pi/10))*1i
      x = real(ztest)
      y = imag(ztest)
      if abs(x + tan(pi/10)*y) < sin(pi/10) && \
         abs(x - tan(pi/10)*y) < sin(pi/10)
        nz = ztest
        shape = 1
        unrot = -unrot*exp(1i*3*pi/10)
        zc = zc - zcrm*(phi/2-1/phi-cos(pi/10)/phi*exp(1i*3*pi/10))*1i
        zcrm = -zcrm/phi*exp(1i*3*pi/10)
      endif
      
    elseif shape == 1
      
      ztest = z - sin(pi/10)
      ztest = ztest*exp(-1i*pi/10)
      ztest = phi*ztest
      ztest = -ztest + phi/2*1i
      x = real(ztest)
      y = imag(ztest)
      if abs(x + tan(pi/5)*y) < sin(pi/5) && \
         abs(x - tan(pi/5)*y) < sin(pi/5)
        nz = ztest
        shape = 0
        unrot = -unrot*exp(1i*pi/10)
        zc = zc + zcrm*(sin(pi/10)+1/2*1i*exp(1i*pi/10))
        zcrm = -zcrm/phi*exp(1i*pi/10)
      endif
      
      ztest = z - sin(pi/10)
      ztest = ztest*exp(1i*pi/10)
      ztest = phi*ztest
      ztest = ztest + phi/2*1i
      x = real(ztest)
      y = imag(ztest)
      if abs(x + tan(pi/5)*y) < sin(pi/5) && \
         abs(x - tan(pi/5)*y) < sin(pi/5)
        nz = ztest
        shape = 0
        unrot = unrot*exp(-1i*pi/10)
        zc = zc + zcrm*(sin(pi/10)-1/2*1i*exp(-1i*pi/10))
        zcrm = zcrm/phi*exp(-1i*pi/10)
      endif
      
      ztest = z - sin(pi/10)
      ztest = ztest*exp(1i*6*pi/10)
      ztest = phi*ztest
      ztest = ztest + cos(pi/10)*1i
      x = real(ztest)
      y = imag(ztest)
      if abs(x + tan(pi/10)*y) < sin(pi/10) && \
         abs(x - tan(pi/10)*y) < sin(pi/10)
        nz = ztest
        shape = 1
        unrot = unrot*exp(-1i*6*pi/10)
        zc = zc + zcrm*(sin(pi/10)-cos(pi/10)*1i/phi*exp(-1i*6*pi/10))
        zcrm = zcrm/phi*exp(-1i*6*pi/10)
      endif
      
      ztest = z - sin(pi/10)
      ztest = ztest*exp(-1i*6*pi/10)
      ztest = phi*ztest
      ztest = ztest - cos(pi/10)*1i
      x = real(ztest)
      y = imag(ztest)
      if abs(x + tan(pi/10)*y) < sin(pi/10) && \
         abs(x - tan(pi/10)*y) < sin(pi/10)
        nz = ztest
        shape = 1
        unrot = unrot*exp(1i*6*pi/10)
        zc = zc + zcrm*(sin(pi/10)+cos(pi/10)*1i/phi*exp(1i*6*pi/10))
        zcrm = zcrm/phi*exp(1i*6*pi/10) 
      endif
        
    endif
        
    z = nz  
        
  endwhile    

  
  if @mode == 1
    if shape == 0
      #solid = true
    endif
  elseif @mode == 2
    if shape == 1
      #solid = true
    endif
  elseif @mode == 3
    if shape == 0
      z = z - 10
    else
      z = z + 10
    endif
  elseif @mode == 4
    z = zc*15 - .7*1i
  elseif @mode == 5
    if shape == 0
      cr = 2*(123456789/(zc+124) - round(123456789/(zc+124)))
      if real(cr) > 0
        z = z - 10
      else
        z = z - 10*1i
      endif
    else
      z = z + 10
    endif  
  endif
  
  zcm = zc - (@zccenter+.7*1i)/15
  zcm = zcm*exp(1i*pi/180*@zcrot)
  zcm = zcm/@zcsize*10
  
  if @mask == 1
    if !@invm
      if cabs(zcm) < 1
        #solid = true
      endif
    else
      if cabs(zcm) > 1
        #solid = true
      endif
    endif
  elseif @mask == 2
    if !@invm
      if cabs(real(zcm)) < 1 && cabs(imag(zcm)) < 1
        #solid = true
      endif
    else
      if cabs(real(zcm)) > 1 || cabs(imag(zcm)) > 1
        #solid = true
      endif
    endif
  elseif @mask == 3
    if !@invm
      if imag(zcm) > 0 
        #solid = true
      endif
    else
      if imag(zcm) < 0 
        #solid = true
      endif
    endif
  elseif @mask == 4
    zcm = -zcm*1i
    float arg = atan2(zcm)
    arg = round(arg/(2*pi)*5)*(2*pi)/5
    zcm = zcm*exp(-1i*arg)
    if !@invm
      if real(zcm) > 1
        #solid = true
      endif
    else
      if real(zcm) < 1
        #solid = true
      endif
    endif
  endif
  
  if @stab
    z = z*unrot
  endif
  
  z = z/@magn
  z = z*exp(1i*pi/180*@rot)
  z = z - @center
    
  #pixel = z
  
default:
  title = "Thin & Fat Penrose Tiling"
  helpfile = "sam-help/penrose.htm"
  
  param mode
    caption = "Mode"
    default = 0
    enum = "All the tiles" "Thin" "Fat" "Thin & Fat Frame" "Mosaic" "Truchet"
  endparam
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param magn
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  
  param mask
    caption = "Mask"
    default = 0
    enum = "None" "Circle" "Square" "Half Plane" "Pentagon"
  endparam
  
  param invm
    caption = "Inverse Mask ?"
    default = false
  endparam
  
  param zccenter
    caption = "Mask Center"
    default = (0,0)
  endparam
  
  param zcrot
    caption = "Mask Rotation"
    default = 0.0
  endparam
  
  param zcsize
    caption = "Mask Size"
    default = 1.0
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param niter
    caption = "Number of Iterations"
    default = 10
  endparam
  

}

AperiodicTilingI {
; By Samuel Monnier, 8.2000
transform:
  z = #pixel/128 - .5
  ztest = 0
  nz = 0
  zc = 0
  zcrm = 1
  unrot = 1
  int i = 0
  int shape = 0
  float x = real(z)
  float y = imag(z)
  bool c = false
  
  while i < @niter
    i = i + 1
    
    if shape == 0
    
      if @tiling == 0
      
        ztest = z
        ztest = ztest + 1 + sqrt(3)/4*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < sqrt(3)/2 && sqrt(3)*x - y > -3*sqrt(3)/2 && -sqrt(3)*x - y > -3*sqrt(3)/2
          nz = ztest
          zc = zc - zcrm*(1 + sqrt(3)/4*1i)
          zcrm = zcrm/2
          shape = 0
        endif
      
        ztest = z
        ztest = ztest - 1 + sqrt(3)/4*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < sqrt(3)/2 && sqrt(3)*x - y > -3*sqrt(3)/2 && -sqrt(3)*x - y > -3*sqrt(3)/2
          nz = ztest
          zc = zc + zcrm*(1 - sqrt(3)/4*1i)
          zcrm = zcrm/2
          shape = 0
        endif
        
        ztest = z
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(sqrt(3)*x + y) < sqrt(3) && abs(sqrt(3)*x - y) < sqrt(3)
          nz = ztest
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest + .75 - sqrt(3)/4*1i
        ztest = ztest*exp(1i*4*pi/3)
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(sqrt(3)*x + y) < sqrt(3) && abs(sqrt(3)*x - y) < sqrt(3)
          nz = ztest
          unrot = unrot*exp(-1i*4*pi/3)
          zc = zc - zcrm*(.75 - sqrt(3)/4*1i)
          zcrm = zcrm/2*exp(-1i*4*pi/3)
          shape = 1
        endif
      
        ztest = z
        ztest = ztest - .75 - sqrt(3)/4*1i
        ztest = ztest*exp(-1i*4*pi/3)
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(sqrt(3)*x + y) < sqrt(3) && abs(sqrt(3)*x - y) < sqrt(3)
          nz = ztest
          unrot = unrot*exp(1i*4*pi/3)
          zc = zc + zcrm*(.75 + sqrt(3)/4*1i)
          zcrm = zcrm/2*exp(1i*4*pi/3)
          shape = 1
        endif
      
      else
      
        ztest = z
        ztest = ztest + 1 + sqrt(3)/4*1i
        ztest = 2*ztest
        if @tiling == 3 || @tiling == 4
          ztest = -conj(ztest)
        endif
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < sqrt(3)/2 && sqrt(3)*x - y > -3*sqrt(3)/2 && -sqrt(3)*x - y > -3*sqrt(3)/2
          nz = ztest
          zc = zc - zcrm*(1 + sqrt(3)/4*1i)
          zcrm = zcrm/2
          if @tiling == 3 || @tiling == 4
            unrot = -conj(unrot)
            c = !c
            zcrm = -conj(zcrm)
            zc = conj(zc)
          endif
          shape = 0
        endif
        
        ztest = z
        ztest = ztest + .5 - sqrt(3)/4*1i
        ztest = 2*ztest
        if @tiling == 2  || @tiling == 4
          ztest = -conj(ztest)
        endif
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < sqrt(3)/2 && sqrt(3)*x - y > -3*sqrt(3)/2 && -sqrt(3)*x - y > -3*sqrt(3)/2
          nz = ztest
          zc = zc - zcrm*(.5 - sqrt(3)/4*1i)
          zcrm = zcrm/2
          if @tiling == 2  || @tiling == 4
            unrot = -conj(unrot)
            c = !c
            zcrm = -conj(zcrm)
            zc = conj(zc)
          endif
          shape = 0
        endif
        
        ztest = z
        ztest = ztest - .75 - sqrt(3)/4*1i
        ztest = ztest*exp(-1i*pi/3)
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(sqrt(3)*x + y) < sqrt(3) && abs(sqrt(3)*x - y) < sqrt(3)
          nz = ztest
          unrot = unrot*exp(1i*pi/3)
          zc = zc + zcrm*(.75 + sqrt(3)/4*1i)
          zcrm = zcrm/2*exp(1i*pi/3)
          shape = 1
        endif
        
        ztest = z
        ztest = ztest - 1.25 + sqrt(3)/4*1i
        ztest = ztest*exp(-1i*4*pi/3)
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(sqrt(3)*x + y) < sqrt(3) && abs(sqrt(3)*x - y) < sqrt(3)
          nz = ztest
          unrot = unrot*exp(1i*4*pi/3)
          zc = zc + zcrm*(1.25 - sqrt(3)/4*1i)
          zcrm = zcrm/2*exp(1i*4*pi/3)
          shape = 1
        endif
        
        ztest = z
        ztest = ztest - .25 + sqrt(3)/4*1i
        ztest = ztest*exp(-1i*pi/3)
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(sqrt(3)*x + y) < sqrt(3) && abs(sqrt(3)*x - y) < sqrt(3)
          nz = ztest
          unrot = unrot*exp(1i*pi/3)
          zc = zc + zcrm*(.25 - sqrt(3)/4*1i)
          zcrm = zcrm/2*exp(1i*pi/3)
          shape = 1
        endif
        
      endif
      
    elseif shape == 1
    
      ztest = z
      ztest = ztest*exp(-1i*2*pi/3)
      ztest = ztest - .5 + sqrt(3)/4*1i
      ztest = 2*ztest
      x = real(ztest)
      y = imag(ztest)
      if abs(y) < sqrt(3)/2 && sqrt(3)*x - y > -3*sqrt(3)/2 && -sqrt(3)*x - y > -3*sqrt(3)/2
        nz = ztest
        unrot = unrot*exp(1i*2*pi/3)
        zcrm = zcrm*exp(1i*2*pi/3)
        zc = zc + zcrm*(.5 - sqrt(3)/4*1i)
        zcrm = zcrm/2
        shape = 0
      endif
      
      ztest = z
      ztest = ztest*exp(-1i*pi/3)
      ztest = ztest + .5 + sqrt(3)/4*1i
      ztest = 2*ztest
      x = real(ztest)
      y = imag(ztest)
      if abs(y) < sqrt(3)/2 && sqrt(3)*x - y > -3*sqrt(3)/2 && -sqrt(3)*x - y > -3*sqrt(3)/2
        nz = ztest
        unrot = unrot*exp(1i*pi/3)
        zcrm = zcrm*exp(1i*pi/3)
        zc = zc - zcrm*(.5 + sqrt(3)/4*1i)
        zcrm = zcrm/2
        shape = 0
      endif
      
      ztest = z
      ztest = ztest + .5
      if @tilingd == 1
        ztest = -ztest
      endif
      ztest = 2*ztest
      x = real(ztest)
      y = imag(ztest)
      if abs(sqrt(3)*x + y) < sqrt(3) && abs(sqrt(3)*x - y) < sqrt(3)
        nz = ztest
        zc = zc - zcrm*.5
        zcrm = zcrm/2
        if @tilingd == 1
          unrot = -unrot
          zcrm = -zcrm
        endif
        shape = 1
      endif
      
    endif
    
  z = nz
  
  endwhile
  
  zc = (zc+.5)*128
  
  if c
    zc = conj(zc)
  endif

  if @mode == 1
    if shape == 1
      #solid = true
    endif
  elseif @mode == 2
    if shape == 0
      #solid = true
    endif
  elseif @mode == 3
    if shape == 0
      z = z - 10
    else
      z = z + 10
    endif
  elseif @mode == 4
    z = zc
  endif
  
  zcm = zc - @zccenter
  zcm = zcm*exp(1i*pi/180*@zcrot)
  zcm = zcm/@zcsize
  
  if @mask == 1
    if !@invm
      if cabs(zcm) < 1
        #solid = true
      endif
    else
      if cabs(zcm) > 1
        #solid = true
      endif
    endif
  elseif @mask == 2
    if !@invm
      if cabs(real(zcm)) < 1 && cabs(imag(zcm)) < 1
        #solid = true
      endif
    else
      if cabs(real(zcm)) > 1 || cabs(imag(zcm)) > 1
        #solid = true
      endif
    endif
  elseif @mask == 3
    if !@invm
      if imag(zcm) > 0 
        #solid = true
      endif
    else
      if imag(zcm) < 0 
        #solid = true
      endif
    endif
  elseif @mask == 4
    zcm = -zcm*1i
    float arg = atan2(zcm)
    arg = round(arg/(2*pi)*6)*(2*pi)/6
    zcm = zcm*exp(-1i*arg)
    if !@invm
      if real(zcm) > 1
        #solid = true
      endif
    else
      if real(zcm) < 1
        #solid = true
      endif
    endif
  endif
  
  if @stab
    z = z*unrot
    if c
      z = conj(z)
    endif
  endif
  
  z = z - @center
  z = z/@magn
  z = z*exp(1i*pi/180*@rot)

  
  #pixel = z
  
default:
  title = "Aperiodic Tiling I"
  helpfile = "sam-help/aperiodic.htm"
  
  param tiling
    caption = "Trapezoid Deflation"
    default = 0
    enum = "I" "II" "III" "IV" "V"
  endparam
  
  param tilingd
    caption = "Rhombus Deflation"
    default = 0
    enum = "I" "II"
  endparam
  
  param mode
    caption = "Mode"
    default = 0
    enum = "All the tiles" "Trapezoids" "Rhombus" "Frame" "Mosaic"
  endparam
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param magn
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  
  param mask
    caption = "Mask"
    default = 0
    enum = "None" "Circle" "Square" "Half Plane" "Hexagon"
  endparam
  
  param invm
    caption = "Inverse Mask ?"
    default = false
  endparam
  
  param zccenter
    caption = "Mask Center"
    default = (0,0)
  endparam
  
  param zcrot
    caption = "Mask Rotation"
    default = 0.0
  endparam
  
  param zcsize
    caption = "Mask Size"
    default = 1.0
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param niter
    caption = "Number of Iterations"
    default = 10
  endparam
}

LogarithmicSpiralTiling {
; By Samuel Monnier, 29.7.00 -> 30.7.00
transform:
  z = #pixel
  float r = cabs(z)
  float arg = atan2(z)
  float argc = 0
  float x = 0
  float y = 0
  float kx = 0
  float ky = 0
  float rcx = 0
  float rcy = 0
  float slopey = 0
  
  if @slope == 0
  
    argc = round(arg*@orderx/(2*pi))/@orderx*2*pi
    x = (arg - argc)*@orderx/(2*pi)
 
    y = (log(r)-round(log(r)*@ordery)/@ordery)*@ordery
    
  else
  
  
    slopey = -1/@slope
  
    kx = round((log(r)-arg*@slope)/(@slope*2*pi)*@orderx)/@orderx
    rcx = @slope*(arg+2*pi*kx)
    x = (log(r) - rcx)*.159/@slope*@orderx
  
    ky = round((log(r)-arg*slopey)/(slopey*2*pi)*@ordery)/@ordery
    rcy = slopey*(arg+2*pi*ky)
    y = (log(r) - rcy)*.159/slopey*@ordery

  endif
  
  if @use == 0
    z = x + 1i*y
  elseif @use == 1
    z = 2*x + 1i*2*y
  elseif @use == 2
    z = 6.28*x + 1i*6.28*y
  elseif @use == 3
    z = 18.66*x + 1i*18.66*y
  elseif @use == 4
    z = @cw*x + 1i*@ch*y
  endif  
  
  if @stab
    z = z*exp(-1i*arg)
  endif
  
  z = z*@magn*exp(1i*pi/180*@rot) - @center
  
  #pixel = z
  
default:
  title = "Logarithmic Spiral Tiling"
  helpfile = "sam-help/logspirt.htm"
  
  param use
    caption = "Use..."
    default = 0
    enum = "...alone" "...with (4,4) Tiling" "...with mt-Martin" \
           "...with mt-Vine" "Custom"
  endparam
  
  param orderx
    caption = "Order I"
    default = 6.0
  endparam
  
  param ordery
    caption = "Order II"
    default = 12.0
  endparam
  
  param slope
    caption = "Spiral Slope"
    default = .5
  endparam
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot 
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param magn
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  
  param cw
    caption = "Custom Width"
    default = 1.0
  endparam
  
  param ch
    caption = "Custom Height"
    default = 1.0
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
}

PolygonalScissor {
; By Samuel Monnier
transform:
  z = -(#pixel-@c)*1i*exp(1i*pi/180*@rot)/@size
  arg = atan2(z)
  arg = -round(arg/(2*pi)*@order)/@order*(2*pi)
  z = z*exp(1i*arg)
  if @inout == 0
    if real(z) - 1 < 0
      #solid = true
    endif
  else
    if real(z) - 1 > 0
      #solid = true
    endif
  endif
default:
  title = "Polygonal Scissor"
  
  param order
    caption = "Polygon Order"
    default = 5
  endparam
  
  param inout
    caption = "Solid Region"
    default = 0
    enum = "Inside" "Outside"
  endparam  
  
  param c
    caption = "Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  
  param size
    caption = "Size"
    default = 1.0
  endparam
  
  
}

AperiodicTilingII {
; By Samuel Monnier, 22.10.00
transform:
  z = #pixel/32 - (.5,.5)
  ztest = 0
  zstore = 0
  zc = (-.5,-.5)
  zcrm = .5
  int i = 0
  int strot = 0
  int col = 0
   
  while i < @niter
    i = i + 1
      
    ztest = 2*z
    ztest = ztest + (1,1)
    if (abs(real(ztest)) < 1 && abs(imag(ztest)) < 1) \
       && (real(ztest) < 0 || imag(ztest) < 0)
      zstore = ztest
      zc = zc + zcrm*@mzt1
      zcrm = zcrm/2
      if i == @niter
        col = col + 2
      endif
    endif
  
    ztest = 2*z
    if (abs(real(ztest)) < 1 && abs(imag(ztest)) < 1) \
       && (real(ztest) < 0 || imag(ztest) < 0)
      zstore = ztest
      zc = zc + zcrm*@mzt2
      zcrm = zcrm/2
    endif
  
    ztest = 2*z
    ztest = ztest + (1,-1)
    ztest = 1i*ztest
    if (abs(real(ztest)) < 1 && abs(imag(ztest)) < 1) \
       && (real(ztest) < 0 || imag(ztest) < 0)
      zstore = ztest
      zc = zc + zcrm*@mzt3
      zcrm = -zcrm/2*1i
      strot = strot + 1
      if i == @niter
        col = col + 1
      else
        col = col + 2
      endif
    endif
  
    ztest = 2*z
    ztest = ztest + (-1,1)
    ztest = -1i*ztest
    if (abs(real(ztest)) < 1 && abs(imag(ztest)) < 1) \
       && (real(ztest) < 0 || imag(ztest) < 0)
      zstore = ztest
      strot = strot - 1
      zc = zc + zcrm*flip(@mzt3)
      zcrm = zcrm/2*1i      
      if i == @niter
        col = col + 1
      else
        col = col + 2
      endif
    endif
  
    z = zstore
  
  endwhile
  
  zc = (zc+(.5,.5))*32  
    
  if @tile == 1
    if col - floor(col/3)*3 != 0
      #solid = true
    endif
  elseif @tile == 2
    if col - floor(col/3)*3 != 1
      #solid = true
    endif
  elseif @tile == 3
    if col - floor(col/3)*3 != 2
      #solid = true
    endif
  elseif @tile == 4
    z = zc
  endif
  
  zcm = zc - @zccenter
  zcm = zcm*exp(1i*pi/180*@zcrot)
  zcm = zcm/@zcsize
  
  if @mask == 1
    if !@invm
      if cabs(zcm) < 1
        #solid = true
      endif
    else
      if cabs(zcm) > 1
        #solid = true
      endif
    endif
  elseif @mask == 2
    if !@invm
      if cabs(real(zcm)) < 1 && cabs(imag(zcm)) < 1
        #solid = true
      endif
    else
      if cabs(real(zcm)) > 1 || cabs(imag(zcm)) > 1
        #solid = true
      endif
    endif
  elseif @mask == 3
    if !@invm
      if imag(zcm) > 0 
        #solid = true
      endif
    else
      if imag(zcm) < 0 
        #solid = true
      endif
    endif
  elseif @mask == 4
    zcm = -zcm*1i
    float arg = atan2(zcm)
    arg = round(arg/(2*pi)*6)*(2*pi)/6
    zcm = zcm*exp(-1i*arg)
    if !@invm
      if real(zcm) > 1
        #solid = true
      endif
    else
      if real(zcm) < 1
        #solid = true
      endif
    endif
  endif
     
  if @stab
    z = z*exp(-1i*strot*pi/2)
  endif
  
  z = z - @center
  z = z/@magn
  z = z*exp(1i*pi/180*@rot)
  
  
  #pixel = z
  
default:
  title = "Aperiodic Tiling II"
  helpfile = "sam-help/aperiodic.htm"
  helptopic = "APII"
  
  param tile
    caption = "Mode"
    default = 0
    enum = "All the tiles" "Tiles I" "Tiles II" "Tiles III" "Mosaic"
  endparam
  
  param niter
    caption = "Number of Iterations"
    default = 8
  endparam
  
  param magn
    caption = "Magnification"
    default = 1.0
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam  
  
  param center
    caption = "Center"
    default = (0,0)
  endparam
  
    param mask
    caption = "Mask"
    default = 0
    enum = "None" "Circle" "Square" "Half Plane" "Hexagon"
  endparam
  
  param invm
    caption = "Inverse Mask ?"
    default = false
  endparam
  
  param zccenter
    caption = "Mask Center"
    default = (0,0)
  endparam
  
  param zcrot
    caption = "Mask Rotation"
    default = 0.0
  endparam
  
  param zcsize
    caption = "Mask Size"
    default = 1.0
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param mzt1
    caption = "Mosaic Tweak 1"
    default = (-.5,-.5)
  endparam
  
  param mzt2
    caption = "Mosaic Tweak 2"
    default = (.5,.5)
  endparam
  
  param mzt3
    caption = "Mosaic Tweak 3"
    default = (-.5,2.5)
  endparam
}

PolygonSpiral {
; By Samuel Monnier, 10.2.01
; Improved, 14.2.01. Thanks to Andreas for the suggestions. 
transform:
  z = 1i*#pixel
  if @outsol == 2
    nz = 0
  else
    nz = z
  endif
  int i = 0
  int j = 0
  float r = @rw/@rh 
  float arg = 0  
  float magn = (sin(pi-pi*(@order-2)/@order-pi/180*@alpha)+sin(pi/180*@alpha))/sin(pi*(@order-2)/@order)*@mtw
  if @outsol == 1
    ztest = real(z)/sqrt(r)+1i*imag(z)*sqrt(r)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*@order)/@order*(2*pi)
    ztest = ztest*exp(1i*arg)
    if real(ztest) > 1
      #solid = true
    endif 
  endif
  while i < @niter
    i = i + 1
    ztest = real(z)*sqrt(r)+1i*imag(z)/sqrt(r)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*@order)/@order*(2*pi)
    ztest = ztest*exp(1i*arg)
    if real(ztest) < 1
      nz = z
    elseif j == 0
      j = i
    else
      i = @niter
    endif
    z = z*exp(1i*pi/180*@alpha)*magn
  endwhile
  
  if @mode == 0
    #pixel = 1i*(nz-@center)*exp(1i*pi/180*@rot)/@mag   
  elseif @mode == 1
    #pixel = (j%@ncol)/@ncol
  elseif @mode == 2
    #pixel = 1i*nz*exp(1i*pi/180*@rot)/@mag-@center
  endif

default:
  title = "Polygon Spiral"
  helpfile = "sam-help/polyspir.htm"
  
  param mode 
    caption = "Mode"
    default = 0
    enum = "Mapping" "Color" "Mapping (corrected)"
  endparam
  
  param order
    caption = "Order"
    default = 3
  endparam
  
  param alpha
    caption = "Angle Step"
    default = 30.0
  endparam
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot 
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param mag
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  
  param rw
    caption = "Width Ratio"
    default = 1.0
  endparam
  
  param rh
    caption = "Heigh Ratio"
    default = 1.0
  endparam
  
  param mtw
    caption = "Magnification Tweak"
    default = 1.0
  endparam
  
  param ncol
    caption = "Color Number"
    default = 3
  endparam 
   
  param niter
    caption = "Iteration Number"
    default = 20
  endparam
  
  param outsol
    caption = "Outside"
    default = 0
    enum = "Standard" "Solid" "Old"
  endparam
}

SemiRegularTesselationII {
; By Samuel Monnier, 8.6.00
; Many improvements later...
; Spiral tesselation added : 5.8.00
transform:
  z = #pixel
  zpix = 0
  ztest = 0
  float r = cabs(z)
  float arg = atan2(z)
  float argc = 0
  float x = 0
  float y = 0
  float kx = 0
  float ky = 0
  float rcx = 0
  float rcy = 0
  float slopey = 0
  
  if @spiral
  
    if @slope == 0
  
      argc = round(arg*@orderx/(2*pi))/@orderx*2*pi
      x = (arg - argc)*@orderx/(2*pi)
 
      y = (log(r)-round(log(r)*@ordery)/@ordery)*@ordery
    
    else
  
      slopey = -1/@slope
  
      kx = round((log(r)-arg*@slope)/(@slope*2*pi)*@orderx)/@orderx
      rcx = @slope*(arg+2*pi*kx)
      x = (log(r) - rcx)*.159/@slope*@orderx
  
      ky = round((log(r)-arg*slopey)/(slopey*2*pi)*@ordery)/@ordery
      rcy = slopey*(arg+2*pi*ky)
      y = (log(r) - rcy)*.159/slopey*@ordery

    endif
  
    x = x*(1+sqrt(2))
    y = y*(1+sqrt(2))
  
  else
  
    x = real(z)
    y = imag(z)
    
  endif
  
  float xc = round(x/(1+sqrt(2)))*(1+sqrt(2))
  float yc = round(y/(1+sqrt(2)))*(1+sqrt(2))
  float xx = x - xc
  float yy = y - yc
  zz = xx + flip(yy)
  
  int shapetype = 0
  
  if !@dual
  
  ztest = zz 
  ztest = ztest + (1+sqrt(2))/2 + (1+sqrt(2))/2*1i
  ztest = ztest*exp(1i*pi/4)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(-1i*pi/4)
    endif
    shapetype = 1
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(2))/2 + (1+sqrt(2))/2*1i
  ztest = ztest*exp(1i*pi/4)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(-1i*pi/4)
    endif
    shapetype = 1
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest + (1+sqrt(2))/2 - (1+sqrt(2))/2*1i
  ztest = ztest*exp(1i*pi/4)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(-1i*pi/4)
    endif
    shapetype = 1
    zpix = ztest
  endif
  
  ztest = zz 
  ztest = ztest - (1+sqrt(2))/2 - (1+sqrt(2))/2*1i
  ztest = ztest*exp(1i*pi/4)
  if abs(real(ztest)) <= .5 && abs(imag(ztest)) <= .5
    if @stab
      ztest = ztest*exp(-1i*pi/4)
    endif
    shapetype = 1
    zpix = ztest
  endif
  
  ztest = zz 
  if abs(real(ztest)) <= (1+sqrt(2))/2 && abs(imag(ztest)) <= (1+sqrt(2))/2 && \
     abs(real(ztest)+imag(ztest)) < 1+sqrt(2)/2 && \
     abs(real(ztest)-imag(ztest)) < 1+sqrt(2)/2
    zpix = ztest
  endif
  
  endif
  
  if @dual
    
  ztest = zz + (1+sqrt(2))/2 - .5*1i 
  if imag(ztest) > -.5 && real(ztest)-imag(ztest) > -sqrt(2)/2 \
     && real(ztest) + imag(ztest) < sqrt(2)/2
     zpix = ztest
  endif
  
  ztest = zz - (1+sqrt(2))/2 - .5*1i 
  if imag(ztest) > -.5 && real(ztest)-imag(ztest) > -sqrt(2)/2 \
     && real(ztest) + imag(ztest) < sqrt(2)/2
     zpix = ztest
  endif
  
  ztest = zz - .5 - (1+sqrt(2))/2*1i
  ztest = 1i*ztest 
  if imag(ztest) > -.5 && real(ztest)-imag(ztest) > -sqrt(2)/2 \
     && real(ztest) + imag(ztest) < sqrt(2)/2
    if @stab
      ztest = -1i*ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz - .5 + (1+sqrt(2))/2*1i
  ztest = 1i*ztest 
  if imag(ztest) > -.5 && real(ztest)-imag(ztest) > -sqrt(2)/2 \
     && real(ztest) + imag(ztest) < sqrt(2)/2
    if @stab
      ztest = -1i*ztest
    endif
    zpix = ztest
    shapetype = 1
  endif
  
  ztest = zz + .5 + (1+sqrt(2))/2*1i
  ztest = -1i*ztest 
  if imag(ztest) > -.5 && real(ztest)-imag(ztest) > -sqrt(2)/2 \
     && real(ztest) + imag(ztest) < sqrt(2)/2
    if @stab
      ztest = 1i*ztest
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz + .5 - (1+sqrt(2))/2*1i
  ztest = -1i*ztest 
  if imag(ztest) > -.5 && real(ztest)-imag(ztest) > -sqrt(2)/2 \
     && real(ztest) + imag(ztest) < sqrt(2)/2
    if @stab
      ztest = 1i*ztest
    endif
    zpix = ztest
    shapetype = 2
  endif
  
  ztest = zz + (1+sqrt(2))/2 + .5*1i
  ztest = -ztest 
  if imag(ztest) > -.5 && real(ztest)-imag(ztest) > -sqrt(2)/2 \
     && real(ztest) + imag(ztest) < sqrt(2)/2
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 3
  endif
    
  ztest = zz - (1+sqrt(2))/2 + .5*1i
  ztest = -ztest 
  if imag(ztest) > -.5 && real(ztest)-imag(ztest) > -sqrt(2)/2 \
     && real(ztest) + imag(ztest) < sqrt(2)/2
    if @stab
      ztest = -ztest
    endif
    zpix = ztest
    shapetype = 3
  endif  
       
  endif
          
  zpix = zpix/@magn
  zpix = zpix*exp(1i*pi/180*@rot)
  zpix = zpix - @center

  if !@dual
    if @mode == 1
      if shapetype == 0
        #solid = true
      endif
    elseif @mode == 2
      if shapetype == 1
        #solid = true
      endif
    endif
  else
    if @mode == 3
      if shapetype != 0
        #solid = true
      endif
    elseif @mode == 4
      if shapetype != 1
        #solid = true
      endif
    elseif @mode == 5
      if shapetype != 2
        #solid = true
      endif
    elseif @mode == 6
      if shapetype != 3
        #solid = true
      endif
    endif
  endif
  
  if @stabs
    zpix = zpix*exp(-1i*arg)
  endif
  
  #pixel = zpix  
  
default:
  title = "Semi Regular Tesselation II"
  helpfile = "sam-help/srtess.htm"
  
  param spiral
    caption = "Spiral Tesselation ?"
    default = false
  endparam
  
  param dual
    caption = "Dual Tesselation ?"
    default = false
  endparam
  
  param mode
    caption = "Mode"
    enum = "All the tiles" "Squares" "Octogons" \
           "Dual I" "Dual II" "Dual III" "Dual IV"
    default = 0
  endparam
  
   param magn
    caption = "Magnification"
    default = 1.0
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam  
  
  param center
    caption = "Center"
    default = (0,0)
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param orderx
    caption = "Spiral Order I"
    default = 8
  endparam
  
  param ordery
    caption = "Spiral Order II"
    default = 10.0
  endparam
  
  param slope
    caption = "Spiral Slope"
    default = .75
  endparam
  
  param stabs
    caption = "Stabilize Spiral ?"
    default = false
  endparam
}

PlatonicSolids{
; By Samuel Monnier, 3.5.01 -> 28.5.01
; Rotation and translation parts borrowed from
; Frederik Slijkerman's 3D Mapping.
transform:
  
  float tt = 0
  float u = 0
  float v = 0
  float ut = 0
  float vt = 0
  float x = 0
  float y = 0
  float z = 0
  float arg = 0
  
  ztest = 0
  sr = 1
  
  float a1 = 0
  float a2 = 0
  float a3 = 0
  float b1 = 0
  float b2 = 0
  float b3 = 0
  float c1 = 0
  float c2 = 0
  float c3 = 0
  float e1 = 0
  float e2 = 0
  float e3 = 0
  float n1 = 0
  float n2 = 0
  float n3 = 0
  float l1s = @l1
  float l2s = @l2
  float l3s = @l3
  float l1 = 0
  float l2 = 0
  float l3 = 0
  
  float l = 0
  float d = 0
  float mind = 1e20
  int i = 0
  int n = 0
  int colour = 0
  int colort = 0
  bool solid = true
  bool modetest = false
  bool sidetest = false
  bool fsidetest = false
  bool cmirror = false
  bool cmirrort = false
  crot = 1
  crott = 1
  
  float psi = 0
  float delta = 0
  float h = 0
  float k = 0
  float iy = 0
  float gamma = 0
  float alpha = 0
  float nor = 0
  
  if @shape == 0
    n = 5
  elseif @shape == 1
    n = 7
  elseif @shape == 2
    n = 9
  elseif @shape == 3
    n = 12
    psi = pi/5
    iy = 1/(2*tan(psi))
    k = 1/4+sqrt(1/16+1/2*(1/tan(psi)+1/sin(psi))*iy)
    h = sqrt(k^2-iy^2)
    alpha = acos(h/k)
  elseif @shape == 4
    n = 20
    psi = pi/5
    delta = acos(1/(sqrt(3)*tan(psi)))
    h = 1/(sqrt(3)*tan(delta))
    k = sqrt(h^2+1/12)
    gamma = acos(sqrt(3)/2*cos(delta)/cos(psi))  
    alpha = delta + gamma
    nor = sqrt(2*k^2-k+1/2)
  endif


  ; Construct a line from the current pixel on the screen through 3D space.
  ; The line is defined by (sx, sy, sz) + lambda * (dx, dy, dz) where
  ; lambda can be any real value > 0. So the line does not extend behind
  ; the screen.
  
  float sx = -@transx
  float sy = -@transy
  float sz = -@transz
  float dx = real(#pixel)
  float dy = imag(#pixel)
  float dz = 4
  
  ; Convert angles from degrees to radians.
  float angx = (@rotx * #pi) / 180
  float angy = (@roty * #pi) / 180
  float angz = (@rotz * #pi) / 180
  
  ; Rotate the line according to the (rotx, roty, rotz) angle.

    ; Apply rotation around Z axis
  tt = cos(angz) * sy - sin(angz) * sx
  sx = cos(angz) * sx + sin(angz) * sy
  sy = tt  
  tt = cos(angz) * dy - sin(angz) * dx
  dx = cos(angz) * dx + sin(angz) * dy
  dy = tt
  tt = cos(angz) * l2s - sin(angz) * l1s
  l1s = cos(angz) * l1s + sin(angz) * l2s
  l2s = tt
  
  ; Apply rotation around Y axis
  tt = cos(angy) * sx - sin(angy) * sz
  sz = cos(angy) * sz + sin(angy) * sx
  sx = tt
  tt = cos(angy) * dx - sin(angy) * dz
  dz = cos(angy) * dz + sin(angy) * dx
  dx = tt
  tt = cos(angy) * l1s - sin(angy) * l3s
  l3s = cos(angy) * l3s + sin(angy) * l1s
  l1s = tt
  
  ; Apply rotation around X axis
  tt = cos(angx) * sz - sin(angx) * sy
  sy = cos(angx) * sy + sin(angx) * sz
  sz = tt
  tt = cos(angx) * dz - sin(angx) * dy
  dy = cos(angx) * dy + sin(angx) * dz
  dz = tt
  tt = cos(angx) * l3s - sin(angx) * l2s
  l2s = cos(angx) * l2s + sin(angx) * l3s
  l3s = tt
      
      
      
  i = 0    
  while i < n
    i = i + 1
    if @shape == 0
      if i == 1
        a1 = 0
        a2 = 1
        a3 = 0
        b1 = sqrt(2/3)
        b2 = 0
        b3 = 1/(sqrt(3))
        c1 = 1/(6*sqrt(2))
        c2 = 0
        c3 = -1/6
        colort = 0
      elseif i == 2
        a1 = 0
        a2 = -1
        a3 = 0
        b1 = sqrt(2/3)
        b2 = 0
        b3 = -1/(sqrt(3))
        c1 = 1/(6*sqrt(2))
        c2 = 0
        c3 = 1/6
        colort = 1
      elseif i == 3
        a1 = 0
        a2 = 0
        a3 = 1
        b1 = -sqrt(2/3)
        b2 = 1/(sqrt(3))
        b3 = 0
        c1 = -1/(6*sqrt(2))
        c2 = -1/6
        c3 = 0
        colort = 2
      elseif i == 4
        a1 = 0
        a2 = 0
        a3 = -1
        b1 = -sqrt(2/3)
        b2 = -1/(sqrt(3))
        b3 = 0
        c1 = -1/(6*sqrt(2))
        c2 = 1/6
        c3 = 0
        colort = 5
      endif
    elseif @shape == 1
      if i == 1
        a1 = 0
        a2 = 0
        a3 = -1
        b1 = -1
        b2 = 0
        b3 = 0
        c1 = 0
        c2 = 1/2
        c3 = 0
        colort = 0
      elseif i == 2
        a1 = 0
        a2 = 0
        a3 = 1
        b1 = -1
        b2 = 0
        b3 = 0 
        c1 = 0
        c2 = -1/2
        c3 = 0
        colort = 0
      elseif i == 3
        a1 = 0
        a2 = 1
        a3 = 0
        b1 = -1
        b2 = 0
        b3 = 0
        c1 = 0
        c2 = 0
        c3 = 1/2
        colort = 1
      elseif i == 4
        a1 = 0
        a2 = -1
        a3 = 0
        b1 = -1
        b2 = 0
        b3 = 0
        c1 = 0
        c2 = 0
        c3 = -1/2
        colort = 1
      elseif i == 5
        a1 = 0
        a2 = -1
        a3 = 0
        b1 = 0
        b2 = 0
        b3 = -1
        c1 = 1/2
        c2 = 0
        c3 = 0
        colort = 2
      elseif i == 6
        a1 = 0
        a2 = 1
        a3 = 0
        b1 = 0
        b2 = 0
        b3 = -1
        c1 = -1/2
        c2 = 0
        c3 = 0
        colort = 2
      endif
    
    elseif @shape == 2
      if i == 1
        a1 = 0
        a2 = 1
        a3 = 0
        b1 = -1/sqrt(3)
        b2 = 0
        b3 = sqrt(2)/sqrt(3)
        c1 = 1/3
        c2 = 0
        c3 = 1/(3*sqrt(2))
        colort = 0
      elseif i == 2
        a1 = 0
        a2 = -1
        a3 = 0
        b1 = 1/sqrt(3)
        b2 = 0
        b3 = sqrt(2)/sqrt(3)
        c1 = -1/3
        c2 = 0
        c3 = 1/(3*sqrt(2))
        colort = 0
      elseif i == 3
        a1 = -1
        a2 = 0
        a3 = 0
        b1 = 0
        b2 = -1/sqrt(3)
        b3 = sqrt(2)/sqrt(3)
        c1 = 0
        c2 = 1/3
        c3 = 1/(3*sqrt(2))
        colort = 1
      elseif i == 4
        a1 = 1
        a2 = 0
        a3 = 0
        b1 = 0
        b2 = 1/sqrt(3)
        b3 = sqrt(2)/sqrt(3)
        c1 = 0
        c2 = -1/3
        c3 = 1/(3*sqrt(2))
        colort = 1
      elseif i == 5
        a1 = 0
        a2 = -1
        a3 = 0
        b1 = -1/sqrt(3)
        b2 = 0
        b3 = -sqrt(2)/sqrt(3)
        c1 = 1/3
        c2 = 0
        c3 = -1/(3*sqrt(2))
        colort = 1
      elseif i == 6
        a1 = 0
        a2 = 1
        a3 = 0
        b1 = 1/sqrt(3)
        b2 = 0
        b3 = -sqrt(2)/sqrt(3)
        c1 = -1/3
        c2 = 0
        c3 = -1/(3*sqrt(2))
        colort = 1
      elseif i == 7
        a1 = 1
        a2 = 0
        a3 = 0
        b1 = 0
        b2 = -1/sqrt(3)
        b3 = -sqrt(2)/sqrt(3)
        c1 = 0
        c2 = 1/3
        c3 = -1/(3*sqrt(2))
        colort = 0
      elseif i == 8
        a1 = -1
        a2 = 0
        a3 = 0
        b1 = 0
        b2 = 1/sqrt(3)
        b3 = -sqrt(2)/sqrt(3)
        c1 = 0
        c2 = -1/3
        c3 = -1/(3*sqrt(2))
        colort = 0
      endif
      
    elseif @shape == 3
      if i == 1
        a1 = 0
        a2 = 1
        a3 = 0
        b1 = -sin(alpha)
        b2 = 0
        b3 = cos(alpha)
        c1 = k - iy*sin(alpha)
        c2 = 0
        c3 = iy*cos(alpha)
        colort = 0
        cmirrort = true
      elseif i == 2
        a1 = 0
        a2 = -1
        a3 = 0
        b1 = -sin(alpha)
        b2 = 0
        b3 = -cos(alpha)
        c1 = k - iy*sin(alpha)
        c2 = 0
        c3 = -iy*cos(alpha)
        colort = 1
        crott = -1
      elseif i == 3
        a1 = 0
        a2 = 1
        a3 = 0
        b1 = -sin(alpha)
        b2 = 0
        b3 = cos(alpha)
        c1 = -k + iy*sin(alpha)
        c2 = 0
        c3 = -iy*cos(alpha)
        colort = 0
        sr = -1
      elseif i == 4
        a1 = 0
        a2 = -1
        a3 = 0
        b1 = -sin(alpha)
        b2 = 0
        b3 = -cos(alpha)
        c1 = -k + iy*sin(alpha)
        c2 = 0
        c3 = iy*cos(alpha)
        colort = 1
        sr = -1
        cmirrort = true
        crott = -1
      elseif i == 5
        a1 = 1
        a2 = 0
        a3 = 0
        b1 = 0
        b2 = cos(alpha)
        b3 = -sin(alpha)
        c1 = 0
        c2 = iy*cos(alpha)
        c3 = k - iy*sin(alpha)
        colort = 2
        sr = 1
        cmirrort = true
      elseif i == 6
        a1 = -1
        a2 = 0
        a3 = 0
        b1 = 0
        b2 = -cos(alpha)
        b3 = -sin(alpha)
        c1 = 0
        c2 = -iy*cos(alpha)
        c3 = k - iy*sin(alpha)
        colort = 3
        sr = 1
        crott = -1
      elseif i == 7
        a1 = 1
        a2 = 0
        a3 = 0
        b1 = 0
        b2 = cos(alpha)
        b3 = -sin(alpha)
        c1 = 0
        c2 = -iy*cos(alpha)
        c3 = -k + iy*sin(alpha)
        colort = 2
        sr = -1
      elseif i == 8
        a1 = -1
        a2 = 0
        a3 = 0
        b1 = 0
        b2 = -cos(alpha)
        b3 = -sin(alpha)
        c1 = 0
        c2 = iy*cos(alpha)
        c3 = -k + iy*sin(alpha)
        colort = 3
        sr = -1
        cmirrort = true
        crott = -1
      elseif i == 9
        a1 = 0
        a2 = 0
        a3 = -1
        b1 = -cos(alpha)
        b2 = -sin(alpha)
        b3 = 0
        c1 = -iy*cos(alpha)
        c2 = k - iy*sin(alpha)
        c3 = 0
        colort = 4
        sr = 1
        crott = -1
      elseif i == 10
        a1 = 0
        a2 = 0
        a3 = 1
        b1 = cos(alpha)
        b2 = -sin(alpha)
        b3 = 0
        c1 = iy*cos(alpha)
        c2 = k - iy*sin(alpha)
        c3 = 0
        colort = 5
        sr = 1
        cmirrort = true
      elseif i == 11
        a1 = 0
        a2 = 0
        a3 = -1
        b1 = -cos(alpha)
        b2 = -sin(alpha)
        b3 = 0
        c1 = iy*cos(alpha)
        c2 = -k + iy*sin(alpha)
        c3 = 0
        colort = 4
        sr = -1
        cmirrort = true
        crott = -1
      elseif i == 12
        a1 = 0
        a2 = 0
        a3 = 1
        b1 = cos(alpha)
        b2 = -sin(alpha)
        b3 = 0
        c1 = -iy*cos(alpha)
        c2 = -k + iy*sin(alpha)
        c3 = 0
        colort = 5
        sr = -1
      endif
      
      
    elseif @shape == 4
      if i == 1
        a1 = 0
        a2 = 0
        a3 = -1
        b1 = sin(alpha)
        b2 = cos(alpha)
        b3 = 0
        c1 = -sqrt(3)/6*sin(alpha)
        c2 = k - sqrt(3)/6*cos(alpha)
        c3 = 0
        colort = 4
      elseif i == 2
        a1 = 0
        a2 = 0
        a3 = 1
        b1 = -sin(alpha)
        b2 = cos(alpha)
        b3 = 0
        c1 = sqrt(3)/6*sin(alpha)
        c2 = k - sqrt(3)/6*cos(alpha)
        c3 = 0
        colort = 3
      elseif i == 3
        a1 = 0
        a2 = 0
        a3 = -1
        b1 = sin(alpha)
        b2 = cos(alpha)
        b3 = 0
        c1 = sqrt(3)/6*sin(alpha)
        c2 = -k + sqrt(3)/6*cos(alpha)
        c3 = 0
        colort = 2
        cmirrort = true
        sr = -1
      elseif i == 4
        a1 = 0
        a2 = 0
        a3 = 1
        b1 = -sin(alpha)
        b2 = cos(alpha)
        b3 = 0
        c1 = -sqrt(3)/6*sin(alpha)
        c2 = -k + sqrt(3)/6*cos(alpha)
        c3 = 0
        colort = 1
        cmirrort = true
        sr = -1
      elseif i == 5
        a1 = 0
        a2 = -1
        a3 = 0
        b1 = -cos(alpha)
        b2 = 0
        b3 = sin(alpha)
        c1 = k - sqrt(3)/6*cos(alpha)
        c2 = 0
        c3 = sqrt(3)/6*sin(alpha)
        colort = 1
        crott = -1
        sr = -1
      elseif i == 6
        a1 = 0
        a2 = 1
        a3 = 0
        b1 = -cos(alpha)
        b2 = 0
        b3 = -sin(alpha)
        c1 = k - sqrt(3)/6*cos(alpha)
        c2 = 0
        c3 = -sqrt(3)/6*sin(alpha)
        colort = 4
        crott = -1
        sr = -1
      elseif i == 7
        a1 = 0
        a2 = -1
        a3 = 0
        b1 = cos(alpha)
        b2 = 0
        b3 = sin(alpha)
        c1 = -k + sqrt(3)/6*cos(alpha)
        c2 = 0
        c3 = sqrt(3)/6*sin(alpha)
        colort = 3
        cmirrort = true
        sr = -1
      elseif i == 8
        a1 = 0
        a2 = 1
        a3 = 0
        b1 = cos(alpha)
        b2 = 0
        b3 = -sin(alpha)
        c1 = -k + sqrt(3)/6*cos(alpha)
        c2 = 0
        c3 = -sqrt(3)/6*sin(alpha)
        colort = 2
        cmirrort = true
        sr = -1
      elseif i == 9
        a1 = -1
        a2 = 0
        a3 = 0
        b1 = 0
        b2 = sin(alpha)
        b3 = -cos(alpha)
        c1 = 0
        c2 = sqrt(3)/6*sin(alpha)
        c3 = k - sqrt(3)/6*cos(alpha)
        colort = 2
        crott = -1
        sr = -1
      elseif i == 10
        a1 = 1
        a2 = 0
        a3 = 0
        b1 = 0
        b2 = -sin(alpha)
        b3 = -cos(alpha)
        c1 = 0
        c2 = -sqrt(3)/6*sin(alpha)
        c3 = k - sqrt(3)/6*cos(alpha)
        colort = 4
        crott = -1
        sr = -1
      elseif i == 11
        a1 = -1
        a2 = 0
        a3 = 0
        b1 = 0
        b2 = sin(alpha)
        b3 = cos(alpha)
        c1 = 0
        c2 = sqrt(3)/6*sin(alpha)
        c3 = -k + sqrt(3)/6*cos(alpha)
        colort = 1
        cmirrort = true
        sr = -1
      elseif i == 12
        a1 = 1
        a2 = 0
        a3 = 0
        b1 = 0
        b2 = -sin(alpha)
        b3 = cos(alpha)
        c1 = 0
        c2 = -sqrt(3)/6*sin(alpha)
        c3 = -k + sqrt(3)/6*cos(alpha)
        colort = 3
        cmirrort = true
        sr = -1
      elseif i == 13
        a1 = (k+1/2)/(sqrt(3)*nor)
        a2 = (-2*k+1/2)/(sqrt(3)*nor)
        a3 = (k-1)/(sqrt(3)*nor)
        b1 = (k-1/2)/nor
        b2 = 1/(2*nor)
        b3 = -k/nor
        c1 = (k+1/2)/3
        c2 = (k+1/2)/3
        c3 = (k+1/2)/3
        colort = 0
        cmirrort = true
        crott = 1i
        sr = 1i
      elseif i == 14
        a1 = -(k+1/2)/(sqrt(3)*nor)
        a2 = (-2*k+1/2)/(sqrt(3)*nor)
        a3 = (k-1)/(sqrt(3)*nor)
        b1 = -(k-1/2)/nor
        b2 = 1/(2*nor)
        b3 = -k/nor
        c1 = -(k+1/2)/3
        c2 = (k+1/2)/3
        c3 = (k+1/2)/3
        colort = 1
        crott = 1i
        sr = 1i
      elseif i == 15
        a1 = (k+1/2)/(sqrt(3)*nor)
        a2 = -(-2*k+1/2)/(sqrt(3)*nor)
        a3 = (k-1)/(sqrt(3)*nor)
        b1 = (k-1/2)/nor
        b2 = -1/(2*nor)
        b3 = -k/nor
        c1 = (k+1/2)/3
        c2 = -(k+1/2)/3
        c3 = (k+1/2)/3
        colort = 3
        crott = 1i
        sr = 1i
      elseif i == 16
        a1 = -(k+1/2)/(sqrt(3)*nor)
        a2 = -(-2*k+1/2)/(sqrt(3)*nor)
        a3 = (k-1)/(sqrt(3)*nor)
        b1 = -(k-1/2)/nor
        b2 = -1/(2*nor)
        b3 = -k/nor
        c1 = -(k+1/2)/3
        c2 = -(k+1/2)/3
        c3 = (k+1/2)/3
        colort = 0
        cmirrort = true
        crott = 1i
        sr = 1i
      elseif i == 17
        a1 = (k+1/2)/(sqrt(3)*nor)
        a2 = (-2*k+1/2)/(sqrt(3)*nor)
        a3 = -(k-1)/(sqrt(3)*nor)
        b1 = (k-1/2)/nor
        b2 = 1/(2*nor)
        b3 = k/nor
        c1 = (k+1/2)/3
        c2 = (k+1/2)/3
        c3 = -(k+1/2)/3
        colort = 2
        crott = 1i
        sr = 1i
      elseif i == 18
        a1 = -(k+1/2)/(sqrt(3)*nor)
        a2 = (-2*k+1/2)/(sqrt(3)*nor)
        a3 = -(k-1)/(sqrt(3)*nor)
        b1 = -(k-1/2)/nor
        b2 = 1/(2*nor)
        b3 = k/nor
        c1 = -(k+1/2)/3
        c2 = (k+1/2)/3
        c3 = -(k+1/2)/3
        colort = 0
        cmirrort = true
        crott = 1i
        sr = 1i
      elseif i == 19
        a1 = (k+1/2)/(sqrt(3)*nor)
        a2 = -(-2*k+1/2)/(sqrt(3)*nor)
        a3 = -(k-1)/(sqrt(3)*nor)
        b1 = (k-1/2)/nor
        b2 = -1/(2*nor)
        b3 = k/nor
        c1 = (k+1/2)/3
        c2 = -(k+1/2)/3
        c3 = -(k+1/2)/3
        colort = 0
        cmirrort = true
        crott = 1i
        sr = 1i
      elseif i == 20
        a1 = -(k+1/2)/(sqrt(3)*nor)
        a2 = -(-2*k+1/2)/(sqrt(3)*nor)
        a3 = -(k-1)/(sqrt(3)*nor)
        b1 = -(k-1/2)/nor
        b2 = -1/(2*nor)
        b3 = k/nor
        c1 = -(k+1/2)/3
        c2 = -(k+1/2)/3
        c3 = -(k+1/2)/3
        colort = 4
        crott = 1i
        sr = 1i
      endif
      
      
    endif
    
    n1 = a2*b3-a3*b2
    n2 = a3*b1-a1*b3
    n3 = a1*b2-a2*b1 
  
    ut = ((sx-c1)*(b2*dz-b3*dy) + (sy-c2)*(b3*dx-b1*dz) + (sz-c3)*(b1*dy-b2*dx))/(n1*dx + n2*dy + n3*dz)   
    vt = -((sx-c1)*(a2*dz-a3*dy) + (sy-c2)*(a3*dx-a1*dz) + (sz-c3)*(a1*dy-a2*dx))/(n1*dx + n2*dy + n3*dz)
    
    if @shape == 0 || @shape == 2 || @shape == 4
       if @shape == 0 || @shape == 4
         ztest = -1i*(ut + 1i*vt)*sr
       elseif @shape == 2
         ztest = 1i*(ut + 1i*vt)
       endif
       arg = atan2(ztest)
       arg = -round(arg/(2*pi)*3)/3*(2*pi)
       ztest = ztest*exp(1i*arg)
       if real(ztest) < sqrt(3)/6
         sidetest = true
       endif
       if real(ztest) < sqrt(3)/6-@fwidth
         fsidetest = true
       endif
    elseif @shape == 1
      if abs(ut) < 1/2 && abs(vt) < 1/2
        sidetest = true
      endif
      if abs(ut) < 1/2-@fwidth && abs(vt) < 1/2-@fwidth
        fsidetest = true
      endif
    elseif @shape == 3
       ztest = (ut + 1i*vt)*sr
       ztest = ztest*1i
       arg = atan2(ztest)
       arg = -round(arg/(2*pi)*5)/5*(2*pi)
       ztest = ztest*exp(1i*arg)
       if real(ztest) < iy
         sidetest = true
       endif
       if real(ztest) < iy-@fwidth
         fsidetest = true
       endif
    endif
    
    
    if @mode == 0
      if sidetest
        modetest = true
      endif
    elseif @mode == 1
      if sidetest && !fsidetest
        modetest = true
      endif
    elseif @mode == 2
      if fsidetest
        modetest = true
      endif
    elseif @mode == 3
      if sidetest && (colort == 0 || colort == 2 || colort == 4)
        modetest = true
      endif
      if sidetest && !fsidetest && (colort == 1 || colort == 3 || colort == 5)
        modetest = true
      endif
    elseif @mode == 4
      if sidetest && (colort == 1 || colort == 3 || colort == 5)
        modetest = true
      endif
      if sidetest && !fsidetest && (colort == 0 || colort == 2 || colort == 4)
        modetest = true
      endif
    elseif @mode == 5
      if sidetest && (colort == 0 || colort == 1 || colort == 2 || colort == 3)
        modetest = true
      endif
      if sidetest && !fsidetest && (colort == 4 || colort == 5)
        modetest = true
      endif
    elseif @mode == 6
      if sidetest && (colort == 4 || colort == 5)
        modetest = true
      endif
      if sidetest && !fsidetest && (colort == 0 || colort == 1 || colort == 2 || colort == 3)
        modetest = true
      endif
    endif
    
    if modetest
    
      x = a1*ut + b1*vt + c1
      y = a2*ut + b2*vt + c2
      z = a3*ut + b3*vt + c3
    
      e1 = x-sx
      e2 = y-sy
      e3 = z-sz
    
      d = sqrt((e1)^2 + (e2)^2 + (e3)^2)
      if d < mind && (dx*e1 + dy*e2 + dz*e3) > 0
        solid = false
        mind = d
        colour = colort
        if @mode2 == 1
          l1 = (x-l1s)
          l2 = (y-l2s)
          l3 = (z-l3s)
          l = sqrt(l1^2+l2^2+l3^2)
          l1 = l1/l
          l2 = l2/l
          l3 = l3/l
          u = 20*(n1*l1 + n2*l2 + n3*l3)/l^2
          v = 0
        elseif @mode2 == 2
          u = d
          v = 0
        else
          u = ut
          v = vt
          cmirror = cmirrort
          crot = crott
        endif
      endif
   
    endif
    
    modetest = false
    sidetest = false
    fsidetest = false
    
    cmirrort = false
    crott = 1
    
  endwhile
  
  if @mode2 == 3 && colour != 0
    #solid = true
  endif
  if @mode2 == 4 && colour != 1
    #solid = true
  endif
  if @mode2 == 5 && colour != 2
    #solid = true
  endif
  if @mode2 == 6 && colour != 3
    #solid = true
  endif
  if @mode2 == 7 && colour != 4
    #solid = true
  endif
  if @mode2 == 8 && colour != 5
    #solid = true
  endif
  
  if solid
    #solid = true
  endif
  nz = u + 1i*v
  if cmirror
    nz = conj(nz)
  endif
  nz = nz*crot
  #pixel = nz*exp(1i*pi/180*@rot)/@magn - @center 
default:
  title = "Platonic Solids"
  helpfile = "sam-help/platonicsolids.htm"
  
  param shape
    caption = "Polyhedron"
    default = 0
    enum = "Tetrahedron" "Cube (Hexahedron)" "Octahedron" \
           "Dodecahedron" "Icosahedron"
  endparam
  
  param mode
    caption = "Side Type"
    default = 0
    enum = "Solid" "Frame" "Unframe" "Mixt I" "Mixt II" \
    "Mixt III" "Mixt IV"
  endparam
  
  param mode2
    caption = "Mode"
    default = 0
    enum = "Mapping" "Lightning" "Ghost" "Sides A" "Sides B" "Sides C" \
           "Sides D" "Sides E" "Sides F" 
  endparam
  
  param rotx
    caption = "X rotation"
    default = 0.0
  endparam
  
  param roty
    caption = "Y rotation"
    default = 0.0
  endparam
  
  param rotz
    caption = "Z rotation"
    default = 0.0
  endparam
  
  param transx
    caption = "X Translation"
    default = 0.0
  endparam
  
  param transy
    caption = "Y Translation"
    default = 0.0
  endparam
  
  param transz
    caption = "Z Translation"
    default = 5.0
  endparam
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param magn
    caption = "Mapping Magnification"
    default = 1.0
  endparam 
  
  param fwidth
    caption = "Frame Width"
    default = 0.02
  endparam
  
  param l1
    caption = "Light Source (x)"
    default = 0.0
  endparam
  
  param l2
    caption = "Light Source (y)"
    default = 0.0
  endparam
  
  param l3
    caption = "Light Source (z)"
    default = 3.0
  endparam
  
}

AperiodicTilingIII {
; By Samuel Monnier 7.01
transform:
  z = #pixel/128
  ztest = 0
  nz = 0
  zc = 0
  zcrm = 1
  unrot = 1
  int i = 0
  int shape = 0
  if @tiling0 == 4
    shape = 2
  endif
  float x = 0
  float y = 0
  bool c = false
  
  while i < @niter
    i = i + 1

    if shape == 0
    
      if @tiling0 == 0
      
        ztest = z
        ztest = ztest + 1
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2
          nz = ztest
          zc = zc - zcrm
          zcrm = zcrm/2
          shape = 0
        endif
        
        ztest = z
        ztest = ztest - 1
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2
          nz = ztest
          zc = zc + zcrm
          zcrm = -zcrm/2
          shape = 0
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest + 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc - zcrm*1i
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest - 1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*1i
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest - 1 - 1.5*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*(1,1.5)
          zcrm = zcrm/2
          shape = 2
        endif
        
        ztest = z
        ztest = ztest + 1 + 1.5*1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*(-1,-1.5)
          zcrm = -zcrm/2
          shape = 2
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest  - 1.5*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 1 && abs(x - y) < 1
          nz = ztest
          zc = zc + zcrm*1.5*1i
          zcrm = zcrm/2
          shape = 3
        endif
        
        ztest = z
        ztest = ztest  + 1.5*1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 1 && abs(x - y) < 1
          nz = ztest
          zc = zc - zcrm*1.5*1i
          zcrm = -zcrm/2
          shape = 3
          unrot = -unrot
        endif
        
      elseif @tiling0 == 1
      
        ztest = z
        ztest = ztest + 1 + 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2
          nz = ztest
          zc = zc + zcrm*(-1,-1)
          zcrm = zcrm/2
          shape = 0
        endif
        
        ztest = z
        ztest = ztest - 1 - 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2
          nz = ztest
          zc = zc + zcrm*(1,1)
          zcrm = zcrm/2
          shape = 0
        endif
        
        ztest = z
        ztest = ztest + 2
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc - zcrm*2
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest - 2
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*2
          zcrm = zcrm/2
          shape = 1
        endif
      
        ztest = z
        ztest = ztest - 1 + .5*1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*(1,-.5)
          zcrm = -zcrm/2
          shape = 2
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest + 1 - .5*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*(-1,.5)
          zcrm = zcrm/2
          shape = 2
        endif
        
        ztest = z
        ztest = ztest  + 1.5*1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 1 && abs(x - y) < 1
          nz = ztest
          zc = zc - zcrm*1.5*1i
          zcrm = -zcrm/2
          shape = 3
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest  - 1.5*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 1 && abs(x - y) < 1
          nz = ztest
          zc = zc + zcrm*1.5*1i
          zcrm = zcrm/2
          shape = 3
        endif
        
      elseif @tiling0 == 2
      
        ztest = z
        ztest = ztest + 1 + 1i
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2
          nz = ztest
          zc = zc + zcrm*(-1,-1)
          zcrm = -1i*zcrm/2
          shape = 0
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = ztest - 1 - 1i
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2
          nz = ztest
          zc = zc + zcrm*(1,1)
          zcrm = -1i*zcrm/2
          shape = 0
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = ztest + 1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc - zcrm*1i
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest - 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*1i
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest - 2 - 2i
        ztest = -1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(2,2)
          zcrm = 1i*zcrm/2
          shape = 1
          unrot = 1i*unrot
        endif
        
        ztest = z
        ztest = ztest + 2 + 2i
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(-2,-2)
          zcrm = -1i*zcrm/2
          shape = 1
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = -1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zcrm = 1i*zcrm/2
          shape = 1
          unrot = 1i*unrot
        endif
        
        ztest = z
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zcrm = -1i*zcrm/2
          shape = 1
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = ztest - 1 + .5*1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*(1,-.5)
          zcrm = -zcrm/2
          shape = 2
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest + 1 - .5*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*(-1,.5)
          zcrm = zcrm/2
          shape = 2
        endif

        
      elseif @tiling0 == 3
      
        ztest = z
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2
          nz = ztest
          zcrm = -1i*zcrm/2
          shape = 0
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = ztest + 1.5*1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc - zcrm*1.5*1i
          zcrm = -zcrm/2
          shape = 2
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest - 1.5*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*1.5*1i
          zcrm = zcrm/2
          shape = 2
        endif
        
        ztest = z
        ztest = ztest - 1.5 - 1i
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*(1.5,1)
          zcrm = -1i*zcrm/2
          shape = 2
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = ztest + 1.5 + 1i
        ztest = -1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*(-1.5,-1)
          zcrm = 1i*zcrm/2
          shape = 2
          unrot = 1i*unrot
        endif
        
        ztest = z
        ztest = ztest - 2 - 2i
        ztest = -1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(2,2)
          zcrm = 1i*zcrm/2
          shape = 1
          unrot = 1i*unrot
        endif
        
        ztest = z
        ztest = ztest + 2 + 2i
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(-2,-2)
          zcrm = -1i*zcrm/2
          shape = 1
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = ztest - 1 - 1i
        ztest = -1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(1,1)
          zcrm = 1i*zcrm/2
          shape = 1
          unrot = 1i*unrot
        endif
        
        ztest = z
        ztest = ztest + 1 + 1i
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(-1,-1)
          zcrm = -1i*zcrm/2
          shape = 1
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = ztest - 1
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest + 1
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc - zcrm
          zcrm = zcrm/2
          shape = 1
        endif
        
        
      endif
      
    elseif shape == 1

      ztest = z
      ztest = ztest - 1i
      ztest = 2*ztest
      x = real(ztest)
      y = imag(ztest)
      if x < 0 && y > 0 && x - y > -2
        nz = ztest
        zc = zc + zcrm*1i
        zcrm = zcrm/2
        shape = 1
      endif
        
      ztest = z
      ztest = ztest + 1 - 1/2*1i
      ztest = 2*ztest
      x = real(ztest)
      y = imag(ztest)
      if x < 2 && abs(y) < 1 && x - y > -1
        nz = ztest
        zc = zc + zcrm*(-1,.5)
        zcrm = zcrm/2
        shape = 2
      endif
      
    elseif shape == 2
    
      if @tiling2 == 0
      
        ztest = z
        ztest = ztest - 1
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2
          nz = ztest
          zc = zc + zcrm 
          zcrm = -1i*zcrm/2
          shape = 0
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = ztest + 1i
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc - zcrm*1i
          zcrm = -1i*zcrm/2
          shape = 1
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = ztest - 2 - 1i 
        ztest = -1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + (2,1)*zcrm
          zcrm = 1i*zcrm/2
          shape = 1
          unrot = 1i*unrot
        endif
        
        ztest = z
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest + 1 + .5*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*(-1,-.5)
          zcrm = zcrm/2
          shape = 2
        endif
        
      elseif @tiling2 == 1
        
        ztest = z
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2
          nz = ztest
          zcrm = zcrm/2
          shape = 0
        endif
        
        ztest = z
        ztest = ztest + 1 + 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(-1,-1)
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest - 1 + 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(1,-1)
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest - 2 - 1i
        ztest = -1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(2,1)
          zcrm = 1i*zcrm/2
          shape = 1
          unrot = 1i*unrot
        endif
        
        ztest = z
        ztest = ztest - 1.5
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*1.5
          zcrm = -1i*zcrm/2
          shape = 2
          unrot = -1i*unrot
        endif
        
      
      elseif @tiling2 == 2
        
        ztest = z
        ztest = ztest - 1
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2
          nz = ztest
          zc = zc + zcrm
          zcrm = zcrm/2
          shape = 0
        endif
        
        ztest = z
        ztest = ztest - 2 + 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(2,1)
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest + 1 + .5*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*(-1,-.5)
          zcrm = zcrm/2
          shape = 2
        endif
        
        ztest = z
        ztest = ztest  - .5*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 1 && abs(x - y) < 1
          nz = ztest
          zc = zc + zcrm*.5*1i
          zcrm = zcrm/2
          shape = 3
        endif
      
      endif
      
    elseif shape == 3
      
      if @tiling3 == 0
      
        ztest = z
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2
          nz = ztest
          zcrm = zcrm/2
          shape = 0
        endif
        
        ztest = z
        ztest = ztest + 1 + 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(-1,-1)
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest - 1 - 1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(1,1)
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif
        
      elseif @tiling3 == 1
      
        ztest = z
        ztest = ztest + 1 + .5*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*(-1,-.5)
          zcrm = zcrm/2
          shape = 2
        endif
        
        ztest = z
        ztest = ztest - 1 - .5*1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 2 && abs(y) < 1 && x - y > -1
          nz = ztest
          zc = zc + zcrm*(1,.5)
          zcrm = -zcrm/2
          shape = 2
          unrot = -unrot
        endif
        
        ztest = z
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif

      endif
      
    endif
    
  z = nz
  
  endwhile
  
  if shape == 1
    z = z + 2/3 - 2/3*1i
    zc = zc - zcrm*(2/3 - 2/3*1i)
  elseif shape == 2
    z = z - 2/3
    zc = zc + zcrm*2/3 
  endif 
  
  zc = zc*128
  
  if c
    zc = conj(zc)
  endif

  if @mode == 1
    if shape != 0
      #solid = true
    endif
  elseif @mode == 2
    if shape != 1
      #solid = true
    endif
  elseif @mode == 3
    if shape != 2
      #solid = true
    endif
  elseif @mode == 4
    if shape != 3
      #solid = true
    endif
  elseif @mode == 5
    if shape == 0
      z = z - 10
    elseif shape == 1
      z = z - 10i
    elseif shape == 2
      z = z + 10
    elseif shape == 3
      z = z + 10i
    endif
  elseif @mode == 6
    z = zc
  endif
  
  zcm = zc - @zccenter
  zcm = zcm*exp(1i*pi/180*@zcrot)
  zcm = zcm/@zcsize
  
  if @mask == 1
    if !@invm
      if cabs(zcm) < 1
        #solid = true
      endif
    else
      if cabs(zcm) > 1
        #solid = true
      endif
    endif
  elseif @mask == 2
    if !@invm
      if cabs(real(zcm)) < 1 && cabs(imag(zcm)) < 1
        #solid = true
      endif
    else
      if cabs(real(zcm)) > 1 || cabs(imag(zcm)) > 1
        #solid = true
      endif
    endif
  elseif @mask == 3
    if !@invm
      if imag(zcm) > 0 
        #solid = true
      endif
    else
      if imag(zcm) < 0 
        #solid = true
      endif
    endif
  elseif @mask == 4
    zcm = -zcm*1i
    float arg = atan2(zcm)
    arg = round(arg/(2*pi)*6)*(2*pi)/6
    zcm = zcm*exp(-1i*arg)
    if !@invm
      if real(zcm) < 1
        #solid = true
      endif
    else
      if real(zcm) > 1
        #solid = true
      endif
    endif
  endif
  
  if @stab
    z = z*unrot
  endif
  
  if @mode != 5    
    z = z*exp(1i*pi/180*@rot)/@magn
    z = z - @center
  endif
  
  #pixel = z
  
default:
  title = "Aperiodic Tiling III"
    helpfile = "sam-help/aperiodic.htm"
  
  param tiling0
    caption = "Hexagon Deflation"
    default = 0
    enum = "I" "II" "III" "IV" "No Deflation"
  endparam
  
  param tiling2
    caption = "Trapezoid Deflation"
    default = 0
    enum = "I" "II" "III" "No Deflation"
  endparam
  
  param tiling3
    caption = "Parallelogram Deflation"
    default = 0
    enum = "I" "II" "No Deflation"
  endparam
  
  param mode
    caption = "Mode"
    default = 0
    enum = "All the tiles" "Hexagons" "Triangles" "Trapezoids" "Parallelograms" "Frame" "Mosaic"
  endparam
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param magn
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  
  param mask
    caption = "Mask"
    default = 0
    enum = "None" "Circle" "Square" "Half Plane" "Hexagon"
  endparam
  
  param invm
    caption = "Inverse Mask ?"
    default = false
  endparam
  
  param zccenter
    caption = "Mask Center"
    default = (0,0)
  endparam
  
  param zcrot
    caption = "Mask Rotation"
    default = 0.0
  endparam
  
  param zcsize
    caption = "Mask Size"
    default = 1.0
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param niter
    caption = "Number of Iterations"
    default = 10
  endparam
}

AperiodicTilingIV {
; By Samuel Monnier 7.01
transform:
  z = #pixel/128 + (1,1)
  ztest = 0
  nz = 0
  zc = 0
  zcrm = 1
  unrot = 1
  int i = 0
  int shape = 0
  if @tiling0 == 4
    shape = 2
  endif
  float x = 0
  float y = 0
  
  while i < @niter
    i = i + 1

    if shape == 0
    
      if @tiling0 == 0
      
        ztest = z
        ztest = ztest - 1 - 1i
        ztest = ztest*1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2 && (x > 0 || y > 0)
          nz = ztest
          zc = zc + zcrm*(1,1)
          zcrm = -1i*zcrm/2
          shape = 0
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = ztest + 1
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc - zcrm
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest - 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*1i
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest - 1
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest + 1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc - zcrm*1i
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest - 2 - 2i
        ztest = -1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(2,2)
          zcrm = 1i*zcrm/2
          shape = 1
          unrot = 1i*unrot
        endif
        
        ztest = z
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zcrm = -1i*zcrm/2
          shape = 1
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = ztest + .5 - .5i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(x) < 1 && abs(y) < 1
          nz = ztest
          zc = zc + zcrm*(-.5,.5)
          zcrm = zcrm/2
          shape = 2
        endif
        
        ztest = z
        ztest = ztest - .5 + .5i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(x) < 1 && abs(y) < 1
          nz = ztest
          zc = zc + zcrm*(.5,-.5)
          zcrm = zcrm/2
          shape = 2
        endif
        
        ztest = z
        ztest = ztest - .5 - 1.5i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(x) < 1 && abs(y) < 1
          nz = ztest
          zc = zc + zcrm*(.5,1.5)
          zcrm = zcrm/2
          shape = 2
        endif
        
        
        
      elseif @tiling0 == 1
      
        ztest = z
        ztest = ztest - 1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2 && (x > 0 || y > 0)
          nz = ztest
          zc = zc + zcrm*1i
          zcrm = -zcrm/2
          shape = 0
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest - 1
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2 && (x > 0 || y > 0)
          nz = ztest
          zc = zc + zcrm
          zcrm = -zcrm/2
          shape = 0
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest + 1
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc - zcrm
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest + 1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc - zcrm*1i
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest - 2 - 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(2,1)
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest - 1 - 2i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(1,2)
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif 
        
        ztest = z
        ztest = ztest - .5 - 1.5i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(x) < 1 && abs(y) < 1
          nz = ztest
          zc = zc + zcrm*(.5,1.5)
          zcrm = zcrm/2
          shape = 2
        endif
        
        ztest = z
        ztest = ztest - 1.5 - .5i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(x) < 1 && abs(y) < 1
          nz = ztest
          zc = zc + zcrm*(1.5,.5)
          zcrm = zcrm/2
          shape = 2
        endif    
      
      elseif @tiling0 == 2
      
        ztest = z
        ztest = ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2 && (x > 0 || y > 0)
          nz = ztest
          zcrm = zcrm/2
          shape = 0
        endif
        
        ztest = z
        ztest = ztest + 1
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc - zcrm
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest + 1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc - zcrm*1i
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest - 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*1i
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest - 1
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest - 1 + 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(1,-1)
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest + 1 - 1i
        ztest = -ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*(-1,1)
          zcrm = -zcrm/2
          shape = 1
          unrot = -unrot
        endif
        
        ztest = z
        ztest = ztest - .5 - 1.5i
        ztest = -1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(x) < 1 && abs(y) < 1
          nz = ztest
          zc = zc + zcrm*(.5,1.5)
          zcrm = 1i*zcrm/2
          shape = 2
          unrot = 1i*unrot
        endif
        
        ztest = z
        ztest = ztest - 1.5 - .5i
        ztest = 1i*ztest
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(x) < 1 && abs(y) < 1
          nz = ztest
          zc = zc + zcrm*(1.5,.5)
          zcrm = -1i*zcrm/2
          shape = 2
          unrot = -1i*unrot
        endif
        
        ztest = z
        ztest = ztest - 1.5 - 1.5i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(x) < 1 && abs(y) < 1
          nz = ztest
          zc = zc + zcrm*(1.5,1.5)
          zcrm = zcrm/2
          shape = 2
        endif

      endif
      
    elseif shape == 1

        ztest = z
        ztest = ztest + 1
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc - zcrm
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest - 1i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if x < 0 && y > 0 && x - y > -2
          nz = ztest
          zc = zc + zcrm*1i
          zcrm = zcrm/2
          shape = 1
        endif
        
        ztest = z
        ztest = ztest + .5 - .5i
        ztest = 2*ztest
        x = real(ztest)
        y = imag(ztest)
        if abs(x) < 1 && abs(y) < 1
          nz = ztest
          zc = zc + zcrm*(-.5,.5)
          zcrm = zcrm/2
          shape = 2
        endif
      
    elseif shape == 2
    
      if @tiling2 == 1
        z = z*1i
        zcrm = -1i*zcrm
        unrot = -1i*unrot
      elseif @tiling2 == 2
        z = -z
        zcrm = -zcrm
        unrot = -unrot
      elseif @tiling2 == 3
        z = -1i*z
        zcrm = 1i*zcrm
        unrot = 1i*unrot
      endif
      
      ztest = z
      ztest = 2*ztest
      x = real(ztest)
      y = imag(ztest)
      if abs(y) < 2 && abs(x) < 2 && abs(x-y) < 2 && (x > 0 || y > 0)
        nz = ztest
        zcrm = zcrm/2
        shape = 0
      endif
        
      ztest = z
      ztest = ztest - 1 + 1i
      ztest = 2*ztest
      x = real(ztest)
      y = imag(ztest)
      if x < 0 && y > 0 && x - y > -2
        nz = ztest
        zc = zc + zcrm*(1,-1i)
        zcrm = zcrm/2
        shape = 1
      endif
      
      ztest = z
      ztest = ztest + 1 - 1i
      ztest = -ztest
      ztest = 2*ztest
      x = real(ztest)
      y = imag(ztest)
      if x < 0 && y > 0 && x - y > -2
        nz = ztest
        zc = zc + zcrm*(-1,1i)
        zcrm = -zcrm/2
        shape = 1
        unrot = -unrot
      endif
       
      ztest = z
      ztest = ztest + .5 + .5i
      ztest = 2*ztest
      x = real(ztest)
      y = imag(ztest)
      if abs(x) < 1 && abs(y) < 1
        nz = ztest
        zc = zc + zcrm*(-.5,-.5)
        zcrm = zcrm/2
        shape = 2
      endif

      if @tiling2 == 4
        nz = z
        shape = 2
      endif
      
    endif
    
  z = nz
  
  endwhile
  
  if shape == 0
    z = z - 1/2*(1,1)
    zc = zc + zcrm*1/2*(1,1)
  elseif shape == 1
    z = z + 2/3 - 2/3*1i
    zc = zc - zcrm*(2/3 - 2/3*1i) 
  endif 
  
  zc = (zc - (1,1))*128

  if @mode == 1
    if shape != 0
      #solid = true
    endif
  elseif @mode == 2
    if shape != 1
      #solid = true
    endif
  elseif @mode == 3
    if shape != 2
      #solid = true
    endif
  elseif @mode == 4
    if shape == 0
      z = z - 10
    elseif shape == 1
      z = z - 10i
    elseif shape == 2
      z = z + 10
    elseif shape == 3
      z = z + 10i
    endif
  elseif @mode == 5
    z = zc
  endif
  
  zcm = zc - @zccenter
  zcm = zcm*exp(1i*pi/180*@zcrot)
  zcm = zcm/@zcsize
  
  if @mask == 1
    if !@invm
      if cabs(zcm) < 1
        #solid = true
      endif
    else
      if cabs(zcm) > 1
        #solid = true
      endif
    endif
  elseif @mask == 2
    if !@invm
      if cabs(real(zcm)) < 1 && cabs(imag(zcm)) < 1
        #solid = true
      endif
    else
      if cabs(real(zcm)) > 1 || cabs(imag(zcm)) > 1
        #solid = true
      endif
    endif
  elseif @mask == 3
    if !@invm
      if imag(zcm) > 0 
        #solid = true
      endif
    else
      if imag(zcm) < 0 
        #solid = true
      endif
    endif
  elseif @mask == 4
    zcm = -zcm*1i
    float arg = atan2(zcm)
    arg = round(arg/(2*pi)*6)*(2*pi)/6
    zcm = zcm*exp(-1i*arg)
    if !@invm
      if real(zcm) < 1
        #solid = true
      endif
    else
      if real(zcm) > 1
        #solid = true
      endif
    endif
  endif
  
  if @stab
    z = z*unrot
  endif
  
  if @mode != 5    
    z = z*exp(1i*pi/180*@rot)/@magn
    z = z - @center
  endif
  
  #pixel = z
  
default:
  title = "Aperiodic Tiling IV"
  helpfile = "sam-help/aperiodic.htm"
  
  param tiling0
    caption = "Arrow Deflation"
    default = 0
    enum = "I" "II" "III" "No Deflation"
  endparam
  
  param tiling2
    caption = "Square Deflation"
    default = 0
    enum = "I" "II" "III" "IV" "No Deflation"
  endparam
  
  param mode
    caption = "Mode"
    default = 0
    enum = "All the tiles" "Arrows" "Triangles" "Squares" "Frame" "Mosaic"
  endparam
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param magn
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  
  param mask
    caption = "Mask"
    default = 0
    enum = "None" "Circle" "Square" "Half Plane" "Hexagon"
  endparam
  
  param invm
    caption = "Inverse Mask ?"
    default = false
  endparam
  
  param zccenter
    caption = "Mask Center"
    default = (0,0)
  endparam
  
  param zcrot
    caption = "Mask Rotation"
    default = 0.0
  endparam
  
  param zcsize
    caption = "Mask Size"
    default = 1.0
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
  
  param niter
    caption = "Number of Iterations"
    default = 10
  endparam
}

PolygonalRings {
; By Samuel Monnier, 31.07.01 - 5.08.01
transform:
  ; Initialization
  z = #pixel
  zc = 0
  zz = 0
  ztest = 0
  bool bail = false
  bool bail0 = false
  bool bail1 = false
  bool bail2 = false
  bool bail3 = false
  bool bail4 = false
  bool bail5 = false
  bool bail6 = false
  bool bail7 = false
  bool bail8 = false
  bool bail9 = false
  bool bail10 = false
  bool bail11 = false
  bool nbail0 = false
  bool nbail1 = false
  bool nbail2 = false
  bool nbail3 = false
  bool nbail4 = false
  bool nbail5 = false
  bool nbail6 = false
  bool nbail7 = false
  bool nbail8 = false
  bool nbail9 = false
  bool nbail10 = false
  bool nbail11 = false
  int ttest = 1
  int rnum = 0
  float x = 0
  float y = 0
  
  ; Triangles
  if @rings == 0
  
    ; Establish the periodicity of the pattern. The whole plane is
    ; reduced to the (-1,1)x(-sqrt(3),sqrt(3)) rectangle.
    zc = round(real(z)/2)*2 + round(imag(z)/(2*sqrt(3)))*2*sqrt(3)*1i
    zz = z - zc
    
    x = real(zz)
    y = imag(zz)
    
    ; Masking
    
    ; Circle
    if @mask == 1
      
      ; Checks if the center of the first triangle is out of the
      ; mask. If so, nbail0 is true
      if cabs(zc-@mkcenter-4*sqrt(3)/6*1i) > @mksize
        nbail0 = true
      endif
      ; idem for the second triangle...
      if cabs(zc-@mkcenter+8*sqrt(3)/6*1i) > @mksize
        nbail1 = true
      endif
      if cabs(zc-@mkcenter-1+2*sqrt(3)/6*1i) > @mksize
        nbail2 = true
      endif
      if cabs(zc-@mkcenter+1+2*sqrt(3)/6*1i) > @mksize
        nbail3 = true
      endif
      if cabs(zc-@mkcenter-8*sqrt(3)/6*1i) > @mksize
        nbail4 = true
      endif
      if cabs(zc-@mkcenter+4*sqrt(3)/6*1i) > @mksize
        nbail5 = true
      endif
      if cabs(zc-@mkcenter-1-2*sqrt(3)/6*1i) > @mksize
        nbail6 = true
      endif
      if cabs(zc-@mkcenter+1-2*sqrt(3)/6*1i) > @mksize
        nbail7 = true
      endif
      if cabs(zc-@mkcenter-2-4*sqrt(3)/6*1i) > @mksize
        nbail8 = true
      endif
      if cabs(zc-@mkcenter+2-4*sqrt(3)/6*1i) > @mksize
        nbail9 = true
      endif
      if cabs(zc-@mkcenter+2+4*sqrt(3)/6*1i) > @mksize
        nbail10 = true
      endif
      if cabs(zc-@mkcenter-2+4*sqrt(3)/6*1i) > @mksize
        nbail11 = true
      endif
    
    ; Do the same for polygons  
    elseif @mask == 2
    
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-4*sqrt(3)/6*1i)
      ; Code that bails a polygon
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail0 = true
      endif
      ; End of the polygon bailing code
      
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+8*sqrt(3)/6*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail1 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-1+2*sqrt(3)/6*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail2 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+1+2*sqrt(3)/6*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail3 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-8*sqrt(3)/6*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail4 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+4*sqrt(3)/6*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail5 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-1-2*sqrt(3)/6*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail6 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+1-2*sqrt(3)/6*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail7 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-2-4*sqrt(3)/6*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail8 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+2-4*sqrt(3)/6*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail9 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+2+4*sqrt(3)/6*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail10 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-2+4*sqrt(3)/6*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail11 = true
      endif
      
    endif
    
    ; Bail out the first triangle    
    ztest = -1i*exp(1i*pi/180*@rrot)*(zz+4*sqrt(3)/6*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*3)/3*(2*pi)
    ztest = ztest*exp(1i*arg)
    ; We check if z is between the triangles of size
    ; @r/1.5-@w/2 and @r/1.5+@w/2, ie if z is in the 
    ; triangle-shaped ring of size @r/1.5 and of width
    ; @w. If the center of the triangle is out of the
    ; mask, nothing is done (cf nbail0).
    if abs(real(ztest)-@r/1.5) < @w/2 && !nbail0
      bail0 = true ; This says the point belongs to the first ring.
      bail = true  ; This says the point has been bailed once.
      ttest = -ttest ; This is used for the tiling mode.
    endif
    
    ; Idem for the second triangle
    ztest = -1i*exp(1i*pi/180*@rrot)*(zz-8*sqrt(3)/6*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*3)/3*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r/1.5) < @w/2 && !nbail1
      bail1 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = -1i*exp(1i*pi/180*@rrot)*(zz+1-2*sqrt(3)/6*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*3)/3*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r/1.5) < @w/2 && !nbail2
      bail2 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = -1i*exp(1i*pi/180*@rrot)*(zz-1-2*sqrt(3)/6*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*3)/3*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r/1.5) < @w/2 && !nbail3
      bail3 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz+8*sqrt(3)/6*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*3)/3*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r/1.5) < @w/2 && !nbail4
      bail4 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-4*sqrt(3)/6*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*3)/3*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r/1.5) < @w/2 && !nbail5
      bail5 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz+1+2*sqrt(3)/6*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*3)/3*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r/1.5) < @w/2 && !nbail6
      bail6 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-1+2*sqrt(3)/6*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*3)/3*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r/1.5) < @w/2 && !nbail7
      bail7 = true
      bail = true
      ttest = -ttest
    endif
   
    ztest = -1i*exp(1i*pi/180*@rrot)*(zz+2+4*sqrt(3)/6*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*3)/3*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r/1.5) < @w/2 && !nbail8
      bail8 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = -1i*exp(1i*pi/180*@rrot)*(zz-2+4*sqrt(3)/6*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*3)/3*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r/1.5) < @w/2 && !nbail9
      bail9 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-2-4*sqrt(3)/6*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*3)/3*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r/1.5) < @w/2 && !nbail10
      bail10 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz+2-4*sqrt(3)/6*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*3)/3*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r/1.5) < @w/2 && !nbail11
      bail11 = true
      bail = true
      ttest = -ttest
    endif
    
    ; Code to determine which ring will look above the other one. messy.
    if @mode == 0
      if bail0
        rnum = 0
      elseif bail1
        rnum = 1
      elseif bail2
        rnum = 2
      elseif bail3
        rnum = 3
      elseif bail4
        rnum = 4
      elseif bail5
        rnum = 5
      elseif bail6
        rnum = 6
      elseif bail7
        rnum = 7
      elseif bail8
        rnum = 8
      elseif bail9
        rnum = 9
      elseif bail10
        rnum = 10
      elseif bail11
        rnum = 11
      endif
      
      if (bail0 || bail8 || bail9) && bail4
        if x > 0
          if bail0
            rnum = 0
          elseif bail8
            rnum = 8
          else
            rnum = 9
          endif
        else
          rnum = 4
        endif
      elseif bail1 && (bail5 || bail10 || bail11)
        if x > 0
          rnum = 1
        else
          if bail5
            rnum = 5
          elseif bail10
            rnum = 10
          else
            rnum = 11
          endif
        endif
      elseif bail2 && (bail5 || bail11)
        if imag((zz-4*sqrt(3)/6*1i)/(1+2*sqrt(3)/6*1i)) > 0
          rnum = 2
        else
          rnum = 5
        endif
        if bail11
          rnum = 11
        endif
      elseif bail3 && (bail5 || bail10)
        if imag((zz-4*sqrt(3)/6*1i)/(-1+2*sqrt(3)/6*1i)) > 0
          rnum = 3
        else
          rnum = 5
        endif
        if bail10
          rnum = 3
        endif
      elseif bail3 && bail7
        rnum = 7
      elseif bail2 && bail6
        rnum = 2
      elseif bail6 && (bail0 || bail8)
        if imag((zz+4*sqrt(3)/6*1i)/(-1+2*sqrt(3)/6*1i)) > 0
          rnum = 0
        else
          rnum = 6
        endif
        if bail8
          rnum = 6
        endif
      elseif bail7 && (bail0 || bail9)
        if imag((zz+4*sqrt(3)/6*1i)/(1+2*sqrt(3)/6*1i)) > 0
          rnum = 0
        else
          rnum = 7
        endif
        if bail9
          rnum = 9
        endif
      endif        
  
      ; Depending to which ring z belong (rnum), 
      ; its coordinate are modified so that the 
      ; origine is mapped on the center of the ring.
      if rnum == 0
        zz = zz + 4*sqrt(3)/6*1i
      elseif rnum == 1
        zz = zz - 8*sqrt(3)/6*1i
      elseif rnum == 2
        zz = zz + 1 - 2*sqrt(3)/6*1i
      elseif rnum == 3
        zz = zz - 1 - 2*sqrt(3)/6*1i
      elseif rnum == 4
        if @stab
          zz = (zz + 8*sqrt(3)/6*1i)
        else
          zz = -(zz + 8*sqrt(3)/6*1i)
        endif
      elseif rnum == 5
        if @stab
          zz = (zz - 4*sqrt(3)/6*1i)
        else
          zz = -(zz - 4*sqrt(3)/6*1i)
        endif
      elseif rnum == 6
        if @stab
          zz = (zz + 1 + 2*sqrt(3)/6*1i)
        else
          zz = -(zz + 1 + 2*sqrt(3)/6*1i)
        endif
      elseif rnum == 7
        if @stab
          zz = (zz - 1 + 2*sqrt(3)/6*1i)
        else
          zz = -(zz - 1 + 2*sqrt(3)/6*1i)
        endif
      elseif rnum == 8
        zz = zz + 2 + 4*sqrt(3)/6*1i
      elseif rnum == 9
        zz = zz - 2 + 4*sqrt(3)/6*1i
      elseif rnum == 10
        if @stab
          zz = (zz - 2 - 4*sqrt(3)/6*1i)
        else
          zz = -(zz - 2 - 4*sqrt(3)/6*1i)
        endif
      elseif rnum == 11
        if @stab
          zz = (zz + 2 - 4*sqrt(3)/6*1i)
        else
          zz = -(zz + 2 - 4*sqrt(3)/6*1i)
        endif
      endif
      
      zz = zz*exp(1i*pi/180*@rrot)
      
      ; If the point hasn't been bailed, 
      ; it is assigned solid color
      if !bail
        #solid = true
      endif
    
    endif
    
  elseif @rings == 1 || @rings == 2
    
    zc = round(z/2)*2
    zz = z - zc
    
    x = real(zz)
    y = imag(zz)
    
    if @mask == 1
    
      if cabs(zc-@mkcenter) > @mksize
        nbail0 = true
      endif
      if cabs(zc-@mkcenter+1+1i) > @mksize
        nbail1 = true
      endif
      if cabs(zc-@mkcenter+1-1i) > @mksize
        nbail2 = true
      endif
      if cabs(zc-@mkcenter-1+1i) > @mksize
        nbail3 = true
      endif
      if cabs(zc-@mkcenter-1-1i) > @mksize
        nbail4 = true
      endif
      if cabs(zc-@mkcenter+2i) > @mksize
        nbail5 = true
      endif
      if cabs(zc-@mkcenter+2) > @mksize
        nbail6 = true
      endif
      if cabs(zc-@mkcenter-2i) > @mksize
        nbail7 = true
      endif
      if cabs(zc-@mkcenter-2) > @mksize
        nbail8 = true
      endif
      
    elseif @mask == 2
    
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail0 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+1+1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail1 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+1-1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail2 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-1+1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail3 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-1-1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail4 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+2i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail5 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+2)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail6 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-2i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail7 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-2)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail8 = true
      endif
      
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*zz
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*4)/4*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r) < @w/2 && !nbail0
      bail0 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-1-1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*4)/4*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r) < @w/2 && !nbail1
      bail1 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-1+1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*4)/4*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r) < @w/2 && !nbail2
      bail2 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz+1-1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*4)/4*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r) < @w/2 && !nbail3
      bail3 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz+1+1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*4)/4*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r) < @w/2 && !nbail4
      bail4 = true
      bail = true
      ttest = -ttest  
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-2i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*4)/4*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r) < @w/2 && !nbail5
      bail5 = true
      bail = true
      ttest = -ttest  
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-2)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*4)/4*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r) < @w/2 && !nbail6
      bail6 = true
      bail = true
      ttest = -ttest  
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz+2i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*4)/4*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r) < @w/2 && !nbail7
      bail7 = true
      bail = true
      ttest = -ttest  
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz+2)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*4)/4*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r) < @w/2 && !nbail8
      bail8 = true
      bail = true
      ttest = -ttest  
    endif
    
    if @mode == 0
      if bail0
        rnum = 0
      elseif bail1
        rnum = 1
      elseif bail2
        rnum = 2
      elseif bail3
        rnum = 3
      elseif bail4
        rnum = 4
      elseif bail5
        rnum = 5
      elseif bail6
        rnum = 6
      elseif bail7
        rnum = 7
      elseif bail8
        rnum = 8
      endif
      
      if @mode == 0 && @rings == 1
        if (bail0 || bail5) && bail1
          if x > y
            rnum = 0
          else
            rnum = 1
          endif
          if bail5
            rnum = 5
          endif
        elseif (bail0 || bail6) && bail2
          if x > -y
            rnum = 2
          else
            rnum = 0
          endif
          if bail6
            rnum = 6
          endif
        elseif (bail0 || bail8) && bail3
          if x > -y
            rnum = 0
          else
            rnum = 3
          endif
          if bail8
            rnum = 8
          endif
        elseif (bail0 || bail7) && bail4
          if x > y
            rnum = 4
          else
            rnum = 0
          endif
          if bail7
            rnum = 7
          endif
        endif
      elseif @mode == 0 && @rings == 2
        if (bail0 || bail6) && bail1
          if x > y
            rnum = 0
          else
            rnum = 1
          endif
          if bail6
            rnum = 6
          endif
        elseif (bail0 || bail6) && bail2
          if x > -y
            rnum = 0
          else
            rnum = 2
          endif
          if bail6
            rnum = 6
          endif
        elseif (bail0 || bail8) && bail3
          if x > -y
            rnum = 3
          else
            rnum = 0
          endif
          if bail8
            rnum = 8
          endif
            
        elseif (bail0 || bail8) && bail4
          if x > y
            rnum = 4
          else
            rnum = 0
          endif
          if bail8
            rnum = 8
          endif
        endif
      endif
        
      if rnum == 1
        zz = zz - (1,1)
      elseif rnum == 2
        zz = zz - (1,-1)
      elseif rnum == 3
        zz = zz - (-1,1)
      elseif rnum == 4
        zz = zz - (-1,-1)
      elseif rnum == 5
        zz = zz - 2i
      elseif rnum == 6
        zz = zz - 2
      elseif rnum == 7
        zz = zz + 2i
      elseif rnum == 8
        zz = zz + 2
      endif
      
      zz = zz*exp(1i*pi/180*@rrot)
      
      if !bail
        #solid = true
      endif  
        
    endif
    
  elseif @rings == 3 
    
    zc = round(real(z)/3)*3 + round(imag(z)/sqrt(3))*sqrt(3)*1i
    zz = z - zc
    
    x = real(zz)
    y = imag(zz)
    
    if @mask == 1
    
      if cabs(zc-@mkcenter) > @mksize
        nbail0 = true
      endif
      if cabs(zc-@mkcenter-1.5+sqrt(3)/2*1i) > @mksize
        nbail1 = true
      endif
      if cabs(zc-@mkcenter+1.5+sqrt(3)/2*1i) > @mksize
        nbail2 = true
      endif
      if cabs(zc-@mkcenter+1.5-sqrt(3)/2*1i) > @mksize
        nbail3 = true
      endif
      if cabs(zc-@mkcenter-1.5-sqrt(3)/2*1i) > @mksize
        nbail4 = true
      endif
      if cabs(zc-@mkcenter+sqrt(3)*1i) > @mksize
        nbail5 = true
      endif
      if cabs(zc-@mkcenter-sqrt(3)*1i) > @mksize
        nbail6 = true
      endif
      
    elseif @mask == 2
    
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail0 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-1.5+sqrt(3)/2*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail1 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+1.5+sqrt(3)/2*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail2 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+1.5-sqrt(3)/2*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail3 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-1.5-sqrt(3)/2*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail4 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter+sqrt(3)*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail5 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-sqrt(3)*1i)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail6 = true
      endif
      
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*zz
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*6)/6*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r*1.75) < @w/2 && !nbail0
      bail0 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz+1.5-sqrt(3)/2*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*6)/6*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r*1.75) < @w/2 && !nbail1
      bail1 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-1.5-sqrt(3)/2*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*6)/6*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r*1.75) < @w/2 && !nbail2
      bail2 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-1.5+sqrt(3)/2*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*6)/6*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r*1.75) < @w/2 && !nbail3
      bail3 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz+1.5+sqrt(3)/2*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*6)/6*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r*1.75) < @w/2 && !nbail4
      bail4 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-sqrt(3)*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*6)/6*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r*1.75) < @w/2 && !nbail5
      bail5 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz+sqrt(3)*1i)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*6)/6*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r*1.75) < @w/2 && !nbail6
      bail6 = true
      bail = true
      ttest = -ttest
    endif
    
    if @mode == 0
      if bail0
        rnum = 0
      elseif bail1
        rnum = 1
      elseif bail2
        rnum = 2
      elseif bail3
        rnum = 3
      elseif bail4
        rnum = 4
      elseif bail5
        rnum = 5
      elseif bail6
        rnum = 6
      endif
      
      if bail0 && bail5
        if x > 0
          rnum = 0
        else
          rnum = 5
        endif
      elseif bail0 && bail6
        if x > 0
          rnum = 6
        else
          rnum = 0
        endif
      elseif bail6 && bail4
        rnum = 6
      elseif bail5 && bail2
        rnum = 5
      elseif bail1 && bail0
        if imag(zz/(1.5-sqrt(3)/2*1i)) > 0
          rnum = 0
        else
          rnum = 1
        endif
      elseif bail1 && bail4
        rnum = 4
      elseif bail3 && bail0
        if imag(zz/(1.5-sqrt(3)/2*1i)) > 0
          rnum = 3
        else
          rnum = 0
        endif
      endif
   
      if rnum == 1
        zz = zz + 1.5 - sqrt(3)/2*1i
      elseif rnum == 2
        zz = zz - 1.5 - sqrt(3)/2*1i
      elseif rnum == 3
        zz = zz - 1.5 + sqrt(3)/2*1i
      elseif rnum == 4
        zz = zz + 1.5 + sqrt(3)/2*1i
      elseif rnum == 5
        zz = zz - sqrt(3)*1i
      elseif rnum == 6
        zz = zz + sqrt(3)*1i
      endif
      
      zz = zz*exp(1i*pi/180*@rrot)
      
      if !bail
        #solid = true
      endif
    
    endif
  
  elseif @rings == 4
    
    zc = round(z/(1+sqrt(2)))*(1+sqrt(2))
    zz = z - zc
    
    x = real(zz)
    y = imag(zz)
    
    if @mask == 1
    
      if cabs(zc-@mkcenter-(-1,-1)*(1+sqrt(2))/2) > @mksize
        nbail0 = true
      endif
      if cabs(zc-@mkcenter-(-1,1)*(1+sqrt(2))/2) > @mksize
        nbail1 = true
      endif
      if cabs(zc-@mkcenter-(1,-1)*(1+sqrt(2))/2) > @mksize
        nbail2 = true
      endif
      if cabs(zc-@mkcenter-(1,1)*(1+sqrt(2))/2) > @mksize
        nbail3 = true
      endif
      
    elseif @mask == 2
    
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-(-1,-1)*(1+sqrt(2))/2)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail0 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-(-1,1)*(1+sqrt(2))/2)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail1 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-(1,-1)*(1+sqrt(2))/2)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail2 = true
      endif
      ztest = 1i*exp(1i*pi/180*@mkrot)*(zc-@mkcenter-(1,1)*(1+sqrt(2))/2)
      arg = atan2(ztest)
      arg = -round(arg/(2*pi)*@mkord)/@mkord*(2*pi)
      ztest = ztest*exp(1i*arg)
      if real(ztest) > @mksize
        nbail3 = true
      endif
      
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-(1,1)*(1+sqrt(2))/2)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*8)/8*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r*3.2) < @w/2 && !nbail0
      bail0 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-(1,-1)*(1+sqrt(2))/2)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*8)/8*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r*3.2) < @w/2 && !nbail1
      bail1 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-(-1,1)*(1+sqrt(2))/2)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*8)/8*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r*3.2) < @w/2 && !nbail2
      bail2 = true
      bail = true
      ttest = -ttest
    endif
    
    ztest = 1i*exp(1i*pi/180*@rrot)*(zz-(-1,-1)*(1+sqrt(2))/2)
    arg = atan2(ztest)
    arg = -round(arg/(2*pi)*8)/8*(2*pi)
    ztest = ztest*exp(1i*arg)
    if abs(real(ztest)-@r*3.2) < @w/2 && !nbail3
      bail3 = true
      bail = true
      ttest = -ttest
    endif
    
    if @mode == 0
      if bail0
        rnum = 0
      elseif bail1
        rnum = 1
      elseif bail2
        rnum = 2
      elseif bail3
        rnum = 3
      endif
      
      if bail0 && bail1
        rnum = 1
      elseif bail0 && bail3
        if x > 0
          rnum = 3
        endif
      elseif bail3 && bail1
        rnum = 3
      elseif bail1 && bail2
        if x < 0
          rnum = 2
        endif
      endif
   
      if rnum == 0
        zz = zz - (1,1)*(1+sqrt(2))/2
      elseif rnum == 1
        zz = zz - (1,-1)*(1+sqrt(2))/2
      elseif rnum == 2
        zz = zz - (-1,1)*(1+sqrt(2))/2
      elseif rnum == 3
        zz = zz - (-1,-1)*(1+sqrt(2))/2
      endif
      
      zz = zz*exp(1i*pi/180*@rrot)
      
      if !bail
        #solid = true
      endif
    
    endif

  endif
  
  if @mode == 0
    z = zz
  elseif @mode == 1
    if !bail
      #solid = true
    endif
  elseif @mode == 2
    if bail
      #solid = true
    endif
  elseif @mode == 3
    if ttest == 1
      #solid = true
    endif
  elseif @mode == 4
    if ttest == -1
      #solid = true
    endif
  endif
  
  z = z*exp(1i*pi/180*@rot)/@magn
  z = z - @center
  
  #pixel = z
  
default:
  title = "Polygonal Rings"
  helpfile = "sam-help/polyrings.htm"
  
  param rings
    caption = "Ring Type"
    default = 0
    enum = "Triangle" "Square I" "Square II" "Hexagon" "Octogon"
  endparam
  
  param mode 
    caption = "Mode"
    default = 0
    enum = "Intricated" "Mask" "Inverse Mask" "Tiling In" "Tiling Out"
  endparam
  
  param r
    caption = "Ring Size"
    default = .6
  endparam
  
  param w
    caption = "Ring Width"
    default = .05
  endparam
  
  param rrot
    caption = "Ring Rotation"
    default = 0.0
  endparam
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param magn
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  
  param mask
    caption = "Mask"
    default = 0  
    enum = "None" "Circle" "Polygon"
  endparam
  
  param mkord
    caption = "Mask Polygon Order"
    default = 4
  endparam
  
  param mkcenter
    caption = "Mask Center"
    default = (0,0)
  endparam
  
  param mkrot
    caption = "Mask Rotation"
    default = 0.0
  endparam
  
  param mksize
    caption = "Mask Size"
    default = 2.0
  endparam
  
  param stab
    caption = "Stabilize ?"
    default = false
  endparam
}

SliceScissor {
; By Samuel Monnier, 6.08.01
transform:
  z = #pixel - @center
  z = z*exp(1i*pi/180*@rot)
  ztest = z
  bool bail = false
  
  float arg = atan2(ztest)+pi
  arg = round(arg/(2*pi)*@order)
  
  if arg%@corder == @vpart
    bail = true
  endif
    
  if !bail
    #solid = true
  endif
    
default:
  title = "Slice Scissor"
  helpfile = "sam-help/varioustrans.htm"
  helptopic = "slicesciss"
  
  param order
    caption = "Scissor Order"
    default = 12
  endparam
  
  param corder
    caption = "Coloring Order"
    default = 2
  endparam
  
  param vpart
    caption = "Visible Group"
    default = 0
  endparam
  
  param center
    caption = "Scissor Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Scissor Rotation"
    default = 0.0
  endparam  
  
}

Ying-YangScissor {
; By Samuel Monnier, 8.8.01
transform:
  z = (#pixel-@center)*exp(1i*pi/180*@rot)/@size
  bool bail0 = false
  bool bail1 = false
  bool bail2 = false
  bool bail3 = false
  if cabs(z) < 1
    bail0 = true
  endif
  if cabs(2*z-1i) >= 1 && imag(z) >= 0 && real(z) <= 0
    bail1 = true
  endif
  if (cabs(2*z+1i) < 1 || real(z) < 0) && imag(z) < 0
    bail1 = true
  endif
  if cabs(2*z-1i) < @csize
    bail2 = true
  endif
  if cabs(2*z+1i) < @csize
    bail3 = true
  endif  
  
  if @region == 0  
    if (!bail0 || !bail1) && !bail2 || bail3 
      #solid = true
    endif
  elseif @region == 1
    if (!bail0 || bail1) && !bail3 || bail2
      #solid = true
    endif
  elseif @region == 2
    if bail0
      #solid = true
    endif
  endif
  
default:
  title = "Ying-Yang Scissor"
  
  param region
    caption = "Visible Region"
    default = 0
    enum = "Ying" "Yang" "Outside"
  endparam
  
  param csize
    caption = "Circles Size"
    default = .33333333
  endparam
  
  param center
    caption = "Center"
    default = (0,0)
  endparam
  
  param size
    caption = "Size"
    default = 1.0
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam  
}






StereographicToEquirectangular {
; By Samuel Monnier, 28.2.12
; 20120331: Chang y en -y dans la formule pour a
transform:
;   r = cabs(#pixel)
;   a = atan2(#pixel)/pi
;   x = 2*atan(1/r)/pi
;   y = a
;   #pixel = x + 1i*y
  z = #pixel
  float x = real(z)
  float y = imag(z)
  if abs(x) > 1 || abs(y) > .5
    #solid = true
  endif
  a = pi*(-y + .5)
  r = sin(a)/(1-cos(a))
  #pixel = r*exp(1i*pi*x)
  
default:
  title = "Stereographic to equirectangular"
}


EquirectangularToStereographic {
; By Samuel Monnier, 03.04.2015
; The equirectangular image should fit in the rectangle [-2,2] x [-1,1].
transform:
  r = cabs(#pixel)
  a = atan2(#pixel)/pi
  y = 4*atan(1/r)/pi - 1
  x = 2*a
  #pixel = x + 1i*y
;   z = #pixel
;   float x = real(z)
;   float y = imag(z)
;   if abs(x) > 1 || abs(y) > .5
;     #solid = true
;   endif
;   a = pi*(-y + .5)
;   r = sin(a)/(1-cos(a))
;   #pixel = r*exp(1i*pi*x)

default:
  title = "Equirectangular to Stereographic"
}


PlatonicSymmetries {
; By Samuel Monnier, 27.4.12
transform:
    z = #pixel
    if @type == "Tetrahedron"
      z = (z^4 - 2*sqrt(3)*1i*z^2 + 1)^3/(z^4 + 2*sqrt(3)*1i*z^2 + 1)^3
    elseif @type == "Cube"
      z = (z^8 + 14*z^4 + 1)^3/(108*z^4*(z^4-1)^4)
    elseif @type == "Dodecahedron"
      z = ((-1)*z^20 + 228*z^15 - 494*z^10 - 228*z^5 - 1)^3/(1728*z^5*(z^10+11*z^5-1)^5)
    endif
    #pixel = z

default:
  title = "Platonic Symmetries"
  
  param type
    caption = "Type"
    default = 0
    enum = "Tetrahedron" "Cube" "Dodecahedron"
  endparam
}



WeierstrassP-function {
; By Samuel Monnier, 28.2.12
transform:
  z = #pixel

  nz = 0
  
;  if @mode == "Simple"
    int i = -@gsize
    int j = -@gsize
    while i < @gsize
      j = -@gsize
      while j < @gsize
        if i == 0 && j == 0
          nz = nz + 1/z^@pow
        else
          nz = nz + 1/(z + i*@w1 + j*@w2)^@pow - 1/(i*@w1 + j*@w2)^@pow
        endif
        j = j + 1
      endwhile
      i = i + 1
    endwhile
;  elseif @mode == "Correct cell deformation"
  
;  endif
  #pixel = (nz-@center)*exp(1i*pi/180*@rot)/@size
default:
  title = "Weierstrass P-function"
  param pow, caption = "Power", default = 2.0, endparam
  param gsize, caption = "Gird size", default = 8, endparam
  param w1, caption = "First basis vector", default = (1,0), endparam
  param w2, caption = "Second basis vector", default = (0,1), endparam
  param center, caption = "Center", default = (0,0), endparam
  param rot, caption = "Rotation", default = 0.0, endparam
  param size, caption = "Size", default = 1.0, endparam
}


StupidSine {
; By Samuel Monnier, 28.3.12
transform:
  z = #pixel

  nz = sin(real(z)*pi) + 1i*sin(imag(z)*pi)

  #pixel = (nz-@center)*exp(1i*pi/180*@rot)/@size
default:
  title = "Stupid Sine"
  param center, caption = "Center", default = (0,0), endparam
  param rot, caption = "Rotation", default = 0.0, endparam
  param size, caption = "Size", default = 1.0, endparam
}




StandardFunction {
; By Samuel Monnier, 24.3.12
transform:
  z = #pixel

  nz = @f(z)

  #pixel = (nz-@center)*exp(1i*pi/180*@rot)/@size
default:
  title = "Standard function"
  func f, caption = "Function", default = sin(), endfunc
  param center, caption = "Center", default = (0,0), endparam
  param rot, caption = "Rotation", default = 0.0, endparam
  param size, caption = "Size", default = 1.0, endparam
}









3d-mapping-Corr {
; Corrected 3d mapping formula, Samuel Monnier, 06.03.2012
; Corrected the artificial xy plane symmetry of the spherical mapping.
;
; General 3D perspective mapping. This transformations wraps a
; fractal on a 3D shape.
;
; The 3D transformations/formulas use the left-handed coordinate
; system, where X points to the right, Y points up, and Z points
; into the screen. To determine the direction of a rotation,
; hold your left hand such that your thumb points into the direction
; of the axis around which the rotation takes place, and then your
; curled fingers point into the direction of positive rotation.
;
; Rotation is performed first around the X axis, then around the
; Y axis, and finally around the Z axis. Scaling must be done using
; UF's zooming feature. Translation is performed after the rotation.
;
; The only shapes supported now are plane, sphere, and egg.
;
transform:
  float tt = 0
  float lambda = 0
  float u = 0
  float v = 0
  float x = 0
  float y = 0
  float z = 0

  ; Construct a line from the current pixel on the screen through 3D space.
  ; The line is defined by (sx, sy, sz) + lambda * (dx, dy, dz) where
  ; lambda can be any real value > 0. So the line does not extend behind
  ; the screen.

  float sx = -@transx
  float sy = -@transy
  float sz = -@transz
  float dx = real(#pixel)
  float dy = imag(#pixel)
  float dz = 4

  ; Convert angles from degrees to radians.
  float angx = (@rotx * #pi) / 180
  float angy = (@roty * #pi) / 180
  float angz = (@rotz * #pi) / 180

  ; Rotate the line according to the (rotx, roty, rotz) angle.

  ; Apply rotation around Z axis
  tt = cos(angz) * sy - sin(angz) * sx
  sx = cos(angz) * sx + sin(angz) * sy
  sy = tt
  tt = cos(angz) * dy - sin(angz) * dx
  dx = cos(angz) * dx + sin(angz) * dy
  dy = tt

  ; Apply rotation around Y axis
  tt = cos(angy) * sx - sin(angy) * sz
  sz = cos(angy) * sz + sin(angy) * sx
  sx = tt
  tt = cos(angy) * dx - sin(angy) * dz
  dz = cos(angy) * dz + sin(angy) * dx
  dx = tt

  ; Apply rotation around X axis
  tt = cos(angx) * sz - sin(angx) * sy
  sy = cos(angx) * sy + sin(angx) * sz
  sz = tt
  tt = cos(angx) * dz - sin(angx) * dy
  dy = cos(angx) * dy + sin(angx) * dz
  dz = tt

  ; Now compute the intersection of the line with the shape, and return
  ; the intersection point in #pixel (texture coordinates).
  ; This is the only shape-dependent part.

  if @shape == 0
    ; Plane shape.
    ;
    ; This equation must be solved:
    ; [ sx ]          [ dx ]   [ u ]
    ; [ sy ] + lambda [ dy ] = [ 0 ]
    ; [ sz ]          [ dz ]   [ v ]
    ; where (u,v) are the texture coordinates to return in #pixel.

    lambda = -sy / dy
    if lambda <= 0
      ; The line does not intersect the plane.
      #solid = true
    else
      ; Calculate intersection point.
      u = sx + lambda * dx
      v = sz + lambda * dz
    endif

  elseif @shape == 1
    ; Sphere shape (radius 0.5)
    ;
    ; This must be solved:
    ; [ sx ]          [ dx ]   [ x ]
    ; [ sy ] + lambda [ dy ] = [ y ]
    ; [ sz ]          [ dz ]   [ z ]
    ; and
    ; x^2 + y^2 + z^2 = radius^2

    float a = sqr(dx) + sqr(dy) + sqr(dz)
    float b = 2 * sx * dx + 2 * sy * dy + 2 * sz * dz
    float c = sqr(sx) + sqr(sy) + sqr(sz) - 0.25

    float d = sqr(b) - 4 * a * c

    if d < 0
      ; No roots exist.
      #solid = true
    else
      ; One or two roots: select smallest.
      if a > 0
        lambda = (-b - sqrt(d)) / (2 * a)
      else
        lambda = (-b + sqrt(d)) / (2 * a)
      endif

      if lambda <= 0
        ; Intersection point is behind the screen.
        #solid = true
      else
        x = sx + lambda * dx
        y = sy + lambda * dy
        z = sz + lambda * dz

        if z == 0
          if x > 0
            u = 2
          else
            u = -2
          endif
        else
          ;u = (4 / #pi) * atan(x / abs(z))
          u = (4 / #pi) * atan(x / z)
        endif

        v = (4 / #pi) * atan(y / sqrt(sqr(x) + sqr(z)))
      endif
    endif

  elseif @shape == 2
    ; Egg shape (radius 0.5..0.6667)
    ;
    ; This must be solved:
    ; [ sx ]          [ dx ]   [ x ]
    ; [ sy ] + lambda [ dy ] = [ y ]
    ; [ sz ]          [ dz ]   [ z ]
    ; and
    ; 1) x^2 + (6/7 * y)^2 + z^2 = radius^2
    ; or
    ; 2) x^2 + (24/35 * y)^2 + z^2 - radius^2
    ;
    ; If y > 0, equation 2 is the right one, otherwise equation 1.

    float x1 = 0
    float y1 = 0
    float z1 = 0
    float x2 = 0
    float y2 = 0
    float z2 = 0
    bool  solid = false
    bool  solid1 = false
    bool  solid2 = false

    ; First perform hit test for equation 1; store coordinates
    ; in (x1, y1, z1)

    sy = sy * 6/7
    dy = dy * 6/7

    float a = sqr(dx) + sqr(dy) + sqr(dz)
    float b = 2 * sx * dx + 2 * sy * dy + 2 * sz * dz
    float c = sqr(sx) + sqr(sy) + sqr(sz) - 0.25
    float d = sqr(b) - 4 * a * c

    if d < 0
      ; No roots exist.
      solid1 = true
    else
      ; One or two roots: select smallest.
      if a > 0
        lambda = (-b - sqrt(d)) / (2 * a)
      else
        lambda = (-b + sqrt(d)) / (2 * a)
      endif

      if lambda <= 0
        ; Intersection point is behind the screen.
        solid1 = true
      else
        x1 = sx + lambda * dx
        y1 = sy + lambda * dy
        z1 = sz + lambda * dz
      endif
    endif

    ; Now perform hit test for equation 2; store coordinates
    ; in (x2, y2, z2)

    sy = sy * 4/5
    dy = dy * 4/5

    float a = sqr(dx) + sqr(dy) + sqr(dz)
    float b = 2 * sx * dx + 2 * sy * dy + 2 * sz * dz
    float c = sqr(sx) + sqr(sy) + sqr(sz) - 0.25
    float d = sqr(b) - 4 * a * c

    if d < 0
      ; No roots exist.
      solid2 = true
    else
      ; One or two roots: select smallest.
      if a > 0
        lambda = (-b - sqrt(d)) / (2 * a)
      else
        lambda = (-b + sqrt(d)) / (2 * a)
      endif

      if lambda <= 0
        ; Intersection point is behind the screen.
        solid2 = true
      else
        x2 = sx + lambda * dx
        y2 = sy + lambda * dy
        z2 = sz + lambda * dz
      endif
    endif

    ; Now select proper coordinates (either set 1 or set 2)

    if solid1
      if y2 < 0
        solid = true
      else
        x = x2
        y = y2
        z = z2
        solid = solid2
      endif
    else
      if y2 > 0
        x = x2
        y = y2
        z = z2
      else
        x = x1
        y = y1
        z = z1
      endif
    endif

    #solid = solid

    if !solid
      if z == 0
        if x > 0
          u = 2
        else
          u = -2
        endif
      else
        u = (4 / #pi) * atan(x / abs(z))
      endif
      v = (4 / #pi) * atan(y / sqrt(sqr(x) + sqr(z)))
    endif
    
    elseif @shape == 3
    ; Sphere shape (radius 0.5)
    ;
    ; This must be solved:
    ; [ sx ]          [ dx ]   [ x ]
    ; [ sy ] + lambda [ dy ] = [ y ]
    ; [ sz ]          [ dz ]   [ z ]
    ; and
    ; x^2 + y^2 + z^2 = radius^2

    float a = sqr(dx) + sqr(dy) + sqr(dz)
    float b = 2 * sx * dx + 2 * sy * dy + 2 * sz * dz
    float c = sqr(sx) + sqr(sy) + sqr(sz) - 0.25

    float d = sqr(b) - 4 * a * c

    if d < 0
      ; No roots exist.
      #solid = true
    else
      ; One or two roots: select smallest.
      if a > 0
        lambda = (-b - sqrt(d)) / (2 * a)
      else
        lambda = (-b + sqrt(d)) / (2 * a)
      endif

      if lambda <= 0
        ; Intersection point is behind the screen.
        #solid = true
      else
        x = sx + lambda * dx
        y = sy + lambda * dy
        z = sz + lambda * dz

        if z == 0
          if x > 0
            u = .5
          else
            u = -.5
          endif
        elseif z < 0
          if x > 0
            u = 1 + 1/#pi*atan(x/z)
          else
            u = -1 + 1/#pi*atan(x/z)
          endif
        else
          if x > 0
            u = 1/#pi*atan(x/z)
          else
            u = 1/#pi*atan(x/z)
          endif
        endif

        v = (1 / #pi) * atan(y / sqrt(sqr(x) + sqr(z)))
      endif
    endif

  endif

  #pixel = u + flip(v)
  #pixel = @fraccenter + #pixel * exp(flip((@fracangle * #pi) / 180)) / @fracmagn

default:
  title = "3D Mapping Corrected"
  helpfile = "Uf*.chm"
  helptopic = "Html/transformations/standard/3dmapping.html"
  precision = round(log(@fracmagn) / log(10))

  param shape
    caption = "Shape"
    enum = "Plane" "Sphere" "Egg" "Sphere (Equirect)"
    hint = "The fractal is mapped onto this shape."
  endparam

  param rotx
    caption = "X Rotation"
    default = 0.0
    hint = "Rotation around the x-axis, in degrees. The x-axis points to \
            the right. To determine the direction in which the rotation will \
            take place, hold up your left hand with your thumb pointing to \
            the right. Your (curled) fingers now indicate the direction of \
            positive X rotation."
  endparam

  param roty
    caption = "Y Rotation"
    default = 0.0
    hint = "Rotation around the y-axis, in degrees. The y-axis points \
            upwards. To determine the direction in which the rotation will \
            take place, hold up your left hand with your thumb pointing \
            upwards. Your (curled) fingers now indicate the direction of \
            positive Y rotation."
  endparam

  param rotz
    caption = "Z Rotation"
    default = 0.0
    hint = "Rotation around the z-axis, in degrees. The z-axis points into \
            the screen. To determine the direction in which the rotation will \
            take place, hold up your left hand with your thumb pointing into \
            the screen. Your (curled) fingers now indicate the direction of \
            positive Z rotation."
  endparam

  param transx
    caption = "X Translation"
    default = 0.0
    hint = "Translation along the x-axis. The x-axis points to the right, \
            so increasing this value will move the fractal to the right, too."
  endparam

  param transy
    caption = "Y Translation"
    default = -0.5
    hint = "Translation along the y-axis. The y-axis points upwards, \
            so increasing this value will move the fractal upwards, too."
  endparam

  param transz
    caption = "Z Translation"
    default = 2.0
    hint = "Translation along the z-axis. The z-axis points into the screen, \
            so increasing this value will move the fractal away."
  endparam

  complex param fraccenter
    caption = "Fractal Center"
    default = #center
    hint = "Center of the fractal image. Use here what you would \
            normally enter in the Location tab."
  endparam

  float param fracmagn
    caption = "Fractal Magnification"
    default = #magn
$IFDEF VER40
    exponential = true
$ENDIF
    hint = "Magnification of the fractal image. Use here what you would \
            normally enter in the Location tab."
  endparam

  float param fracangle
    caption = "Fractal Rotation"
    default = #angle
    hint = "Rotation angle (in degrees) of the fractal image. Use here \
            what you would normally enter in the Location tab."
  endparam
}












StarScissor {
; By Samuel Monnier, 13.08.01
transform:
  z = #pixel
  z1 = 0
  z2 = 0
  z3 = 0
  t1 = 0
  t2 = 0
  float arg = 0
  bool bail = false
  int i = 0
  
  if @mode == 0 || @mode == 1
    z = -(z-@c)*1i*exp(1i*pi/180*@rot)/@size
    arg = atan2(z)
    arg = -round(arg/(2*pi)*@order)/@order*(2*pi)
    z = z*exp(1i*arg)
    z1 = @r*exp(1i*pi/@order)
    z2 = @r*exp(-1i*pi/@order)
    z3 = 1
    t1 = (z-z3)/(z1-z3)
    t2 = (z-z3)/(z2-z3)
    if imag(t1) > 0 && imag(t2) < 0 ;&& @inout == 0
      bail = true
    endif
    if @mode == 1 && real(z) < @r*cos(pi/@order)
      bail = false
    endif
  elseif @mode == 2 || @mode == 3
    z = -(z-@c)*1i*exp(1i*pi/180*@rot)/@size
    while i < @niter
      i = i + 1
      arg = atan2(z)
      arg = -round(arg/(2*pi)*@order)/@order*(2*pi)
      z0 = z*exp(1i*arg)
      z1 = @r*exp(1i*pi/@order)
      z2 = @r*exp(-1i*pi/@order)
      z3 = 1
      t1 = (z0-z3)/(z1-z3)
      t2 = (z0-z3)/(z2-z3)
      if imag(t1) > 0 && imag(t2) < 0
        bail = !bail
      endif
      if @mode == 3 && real(z0) < @r*cos(pi/@order)
        bail = !bail
      endif
      
      z = z*exp(1i*pi/@order)
      z = z/@r
      
    endwhile
      
  endif
  
  if (bail && @inout == 0) || (!bail && @inout == 1)
    #solid = true
  endif

default:
  title = "Star Scissor"
  helpfile = "sam-help/varioustrans.htm"
  helptopic = "starsciss"
  
  param mode
    caption = "Mode"
    default = 0
    enum = "Standard" "Polygon" "Ad Infinitum I" "Ad Infinitum II"
  endparam
  
  param order
    caption = "Star Order"
    default = 5
  endparam
  
  param r
    caption = "Aspect"
    default = .4
  endparam
  
  param inout
    caption = "Solid Region"
    default = 0
    enum = "Inside" "Outside"
  endparam  
  
  param c
    caption = "Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  
  param size
    caption = "Size"
    default = 1.0
  endparam
  
  param niter
    caption = "Iteration Number"
    default = 10
  endparam
}

String-Art {
; By Samuel Monnier, 25.8.01 - 5.10.01
; Inspired by Jos Leys' work.
transform:
  z = #pixel
  nz = 0
  bool bail = false
  float arg = atan2(z)
  float arg2 = 0
  float oarg = arg
  float r = cabs(z)
  float or = r
  float rtest = 0
  int i = 0
  int ist = 0
  
  while i < @niter
    i = i + 1
    arg = arg + @astep*pi/180
    arg2 = arg + @phi*pi/180
    r = r*@mstep
    if @shape == 0
      rtest = (@w1/(@w1+@w2)*cos(@order1*arg)+@w2/(@w1+@w2)*cos(@order2*arg+@phi*pi/180))*(@obound-@ibound)/2+(@obound+@ibound)/2
    elseif @shape == 1
      rtest = (@w1/(@w1+@w2)*(2*(cos(@order1*arg)/2+.5)^@power-1)+@w2/(@w1+@w2)*(2*(cos(@order2*arg2)/2+.5)^@power-1))*(@obound-@ibound)/2+(@obound+@ibound)/2
    elseif @shape == 2
      rtest = (@w1/(@w1+@w2)*(2*(2*abs(arg/(2*pi)*@order1-round(arg/(2*pi)*@order1)))^@power-1)+@w2/(@w1+@w2)*(2*(2*abs(arg2/(2*pi)*@order2-round(arg2/(2*pi)*@order2)))^@power-1))*(@obound-@ibound)/2+(@obound+@ibound)/2
    endif
    
    if abs(rtest-r) < @tresh 
      if @mode == 0 || @mode == 1 || ((@mode == 2 || @mode == 3) && (!bail || (bail && i%2-ist%2 == 0)))
        bail = true
        nz = z*exp(1i*(arg-oarg))*r/or
        ist = i
      endif
    endif
  endwhile
  
  if !bail
    #solid = true
  endif
  
  if @mode == 1 || @mode == 3
    nz = (ist%@ncol)/@ncol
  endif
  
  #pixel = nz
 
default:
  title = "String-Art"
  helpfile = "sam-help/stringart.htm"
  
  param mode
    caption = "Mode"
    default = 0
    enum = "Mapping" "Color" "Interlaced Mapping" "Interlaced Color"
  endparam
  
  param shape
    caption = "Folium Type"
    default = 0
    enum = "Old" "Cosinus" "Sawtooth"
  endparam
  
  param power
    caption = "Folium Power"
    default = 1.0
  endparam
  
  param astep
    caption = "Angle Step"
    default = 5.0
  endparam
  
  param mstep
    caption = "Magnification Step"
    default = 1.0
  endparam
  
  param order1
    caption = "Folium 1 Order"
    default = 5.0
  endparam
  
  param w1
    caption = "Folium 1 Weight"
    default = 1.0
  endparam
  
  param order2
    caption = "Folium 2 Order"
    default = 3.0
  endparam
  
  param w2
    caption = "Folium 2 Weight"
    default = 0.0
  endparam
  
  param phi
    caption = "Dephasage"
    default = 90.0
  endparam
  
  param obound
    caption = "Folium Outer Bound"
    default = 2.0
  endparam
  
  param ibound
    caption = "Folium Inner Bound"
    default = .4
  endparam
  
  param tresh
    caption = "Treshold"
    default = .05
  endparam  
  
  param niter
    caption = "Iteration Number"
    default = 10
  endparam
  
  param ncol
    caption = "Color Number"
    default = 3
  endparam

}

Voroni {
; By Samuel Monnier, 9.01
; Idea from Edward Perry.
transform:
  z = #pixel/@psize
  zc = round(z)
  zz = z - zc
  nz = 0
  nearp = 0
  float mind = 1e20
  float mind2 = 1e20
  float arg = 0
  
  zc1 = zc + (1,1)/2
  zc2 = zc + (1,-1)/2
  zc3 = zc + (-1,1)/2
  zc4 = zc + (-1,-1)/2
  
  float rp1a = ((real(zc1)-859)^5%198 - (imag(zc1)+987)^3%168)^2 %2 - 1
  float ip1a = ((real(zc1)-123)^5%187 - (imag(zc1)+876)^3%157)^2 %2 - 1
  float rp1b = ((real(zc1)-234)^5%176 - (imag(zc1)+765)^3%146)^2 %2 - 1
  float ip1b = ((real(zc1)-345)^5%165 - (imag(zc1)+654)^3%135)^2 %2 - 1
  float rp1c = ((real(zc1)-456)^5%154 - (imag(zc1)+543)^3%124)^2 %2 - 1
  float ip1c = ((real(zc1)-567)^5%143 - (imag(zc1)+432)^3%113)^2 %2 - 1
  float rp1d = ((real(zc1)-357)^5%243 - (imag(zc1)+354)^3%465)^2 %2 - 1
  float ip1d = ((real(zc1)-798)^5%687 - (imag(zc1)+576)^3%246)^2 %2 - 1
  float rp2a = ((real(zc2)-859)^5%198 - (imag(zc2)+987)^3%168)^2 %2 - 1
  float ip2a = ((real(zc2)-123)^5%187 - (imag(zc2)+876)^3%157)^2 %2 - 1
  float rp2b = ((real(zc2)-234)^5%176 - (imag(zc2)+765)^3%146)^2 %2 - 1
  float ip2b = ((real(zc2)-345)^5%165 - (imag(zc2)+654)^3%135)^2 %2 - 1
  float rp2c = ((real(zc2)-456)^5%154 - (imag(zc2)+543)^3%124)^2 %2 - 1
  float ip2c = ((real(zc2)-567)^5%143 - (imag(zc2)+432)^3%113)^2 %2 - 1
  float rp2d = ((real(zc2)-357)^5%243 - (imag(zc2)+354)^3%465)^2 %2 - 1
  float ip2d = ((real(zc2)-798)^5%687 - (imag(zc2)+576)^3%246)^2 %2 - 1
  float rp3a = ((real(zc3)-859)^5%198 - (imag(zc3)+987)^3%168)^2 %2 - 1
  float ip3a = ((real(zc3)-123)^5%187 - (imag(zc3)+876)^3%157)^2 %2 - 1
  float rp3b = ((real(zc3)-234)^5%176 - (imag(zc3)+765)^3%146)^2 %2 - 1
  float ip3b = ((real(zc3)-345)^5%165 - (imag(zc3)+654)^3%135)^2 %2 - 1
  float rp3c = ((real(zc3)-456)^5%154 - (imag(zc3)+543)^3%124)^2 %2 - 1
  float ip3c = ((real(zc3)-567)^5%143 - (imag(zc3)+432)^3%113)^2 %2 - 1
  float rp3d = ((real(zc3)-357)^5%243 - (imag(zc3)+354)^3%465)^2 %2 - 1
  float ip3d = ((real(zc3)-798)^5%687 - (imag(zc3)+576)^3%246)^2 %2 - 1
  float rp4a = ((real(zc4)-859)^5%198 - (imag(zc4)+987)^3%168)^2 %2 - 1
  float ip4a = ((real(zc4)-123)^5%187 - (imag(zc4)+876)^3%157)^2 %2 - 1
  float rp4b = ((real(zc4)-234)^5%176 - (imag(zc4)+765)^3%146)^2 %2 - 1
  float ip4b = ((real(zc4)-345)^5%165 - (imag(zc4)+654)^3%135)^2 %2 - 1
  float rp4c = ((real(zc4)-456)^5%154 - (imag(zc4)+543)^3%124)^2 %2 - 1
  float ip4c = ((real(zc4)-567)^5%143 - (imag(zc4)+432)^3%113)^2 %2 - 1
  float rp4d = ((real(zc4)-357)^5%243 - (imag(zc4)+354)^3%465)^2 %2 - 1
  float ip4d = ((real(zc4)-798)^5%687 - (imag(zc4)+576)^3%246)^2 %2 - 1
  
  if !@regtile
    p1a = (rp1a + 1i*ip1a + (1,1))/2
    p1b = (rp1b + 1i*ip1b + (1,1))/2
    p1c = (rp1c + 1i*ip1c + (1,1))/2
    p1d = (rp1d + 1i*ip1d + (1,1))/2
    p2a = (rp2a + 1i*ip2a + (1,-1))/2
    p2b = (rp2b + 1i*ip2b + (1,-1))/2
    p2c = (rp2c + 1i*ip2c + (1,-1))/2
    p2d = (rp2d + 1i*ip2d + (1,-1))/2
    p3a = (rp3a + 1i*ip3a + (-1,1))/2
    p3b = (rp3b + 1i*ip3b + (-1,1))/2
    p3c = (rp3c + 1i*ip3c + (-1,1))/2
    p3d = (rp3d + 1i*ip3d + (-1,1))/2
    p4a = (rp4a + 1i*ip4a + (-1,-1))/2
    p4b = (rp4b + 1i*ip4b + (-1,-1))/2
    p4c = (rp4c + 1i*ip4c + (-1,-1))/2
    p4d = (rp4d + 1i*ip4d + (-1,-1))/2
  else  
    p1a = (rp1a + 1i*ip1a)/real(@regpar) + (1,1)/2 + (1,1)/4
    p1b = (rp1b + 1i*ip1b)/real(@regpar) + (1,1)/2 + (1,-1)/4
    p1c = (rp1c + 1i*ip1c)/real(@regpar) + (1,1)/2 + (-1,1)/4
    p1d = (rp1d + 1i*ip1d)/real(@regpar) + (1,1)/2 + (-1,-1)/4
    p2a = (rp2a + 1i*ip2a)/real(@regpar) + (1,-1)/2 + (1,1)/4
    p2b = (rp2b + 1i*ip2b)/real(@regpar) + (1,-1)/2 + (1,-1)/4
    p2c = (rp2c + 1i*ip2c)/real(@regpar) + (1,-1)/2 + (-1,1)/4
    p2d = (rp2d + 1i*ip2d)/real(@regpar) + (1,-1)/2 + (-1,-1)/4
    p3a = (rp3a + 1i*ip3a)/real(@regpar) + (-1,1)/2 + (1,1)/4
    p3b = (rp3b + 1i*ip3b)/real(@regpar) + (-1,1)/2 + (1,-1)/4
    p3c = (rp3c + 1i*ip3c)/real(@regpar) + (-1,1)/2 + (-1,1)/4
    p3d = (rp3d + 1i*ip3d)/real(@regpar) + (-1,1)/2 + (-1,-1)/4
    p4a = (rp4a + 1i*ip4a)/real(@regpar) + (-1,-1)/2 + (1,1)/4
    p4b = (rp4b + 1i*ip4b)/real(@regpar) + (-1,-1)/2 + (1,-1)/4
    p4c = (rp4c + 1i*ip4c)/real(@regpar) + (-1,-1)/2 + (-1,1)/4
    p4d = (rp4d + 1i*ip4d)/real(@regpar) + (-1,-1)/2 + (-1,-1)/4
  endif
  
  if cabs(zz-p1a) < mind
    mind2 = mind
    mind = cabs(zz-p1a)
    nz = zz - p1a
    nearp = zc + p1a
  elseif cabs(zz-p1a) < mind2
    mind2 = cabs(zz-p1a)
  endif
  if cabs(zz-p1b) < mind
    mind2 = mind
    mind = cabs(zz-p1b)
    nz = zz - p1b
    nearp = zc + p1b
  elseif cabs(zz-p1b) < mind2
    mind2 = cabs(zz-p1b)
  endif
  if cabs(zz-p1c) < mind
    mind2 = mind
    mind = cabs(zz-p1c)
    nz = zz - p1c
    nearp = zc + p1c
  elseif cabs(zz-p1c) < mind2
    mind2 = cabs(zz-p1c)
  endif
  if cabs(zz-p1d) < mind
    mind2 = mind
    mind = cabs(zz-p1d)
    nz = zz - p1d
    nearp = zc + p1d
  elseif cabs(zz-p1d) < mind2
    mind2 = cabs(zz-p1d)
  endif
  
  if cabs(zz-p2a) < mind
    mind2 = mind
    mind = cabs(zz-p2a)
    nz = zz - p2a
    nearp = zc + p2a
  elseif cabs(zz-p2a) < mind2
    mind2 = cabs(zz-p2a)
  endif
  if cabs(zz-p2b) < mind
    mind2 = mind
    mind = cabs(zz-p2b)
    nz = zz - p2b
    nearp = zc + p2b
  elseif cabs(zz-p2b) < mind2
    mind2 = cabs(zz-p2b)
  endif
  if cabs(zz-p2c) < mind
    mind2 = mind
    mind = cabs(zz-p2c)
    nz = zz - p2c
    nearp = zc + p2c
  elseif cabs(zz-p2c) < mind2
    mind2 = cabs(zz-p2c)
  endif
  if cabs(zz-p2d) < mind
    mind2 = mind
    mind = cabs(zz-p2d)
    nz = zz - p2d
    nearp = zc + p2d
  elseif cabs(zz-p2d) < mind2
    mind2 = cabs(zz-p2d)
  endif
  
  if cabs(zz-p3a) < mind
    mind2 = mind
    mind = cabs(zz-p3a)
    nz = zz - p3a
    nearp = zc + p3a
  elseif cabs(zz-p3a) < mind2
    mind2 = cabs(zz-p3a)
  endif
  if cabs(zz-p3b) < mind
    mind2 = mind
    mind = cabs(zz-p3b)
    nz = zz - p3b
    nearp = zc + p3b
  elseif cabs(zz-p3b) < mind2
    mind2 = cabs(zz-p3b)
  endif
  if cabs(zz-p3c) < mind
    mind2 = mind
    mind = cabs(zz-p3c)
    nz = zz - p3c
    nearp = zc + p3c
  elseif cabs(zz-p3c) < mind2
    mind2 = cabs(zz-p3c)
  endif
  if cabs(zz-p3d) < mind
    mind2 = mind
    mind = cabs(zz-p3d)
    nz = zz - p3d
    nearp = zc + p3d
  elseif cabs(zz-p3d) < mind2
    mind2 = cabs(zz-p3d)
  endif
  
  if cabs(zz-p4a) < mind
    mind2 = mind
    mind = cabs(zz-p4a)
    nz = zz - p4a
    nearp = zc + p4a
  elseif cabs(zz-p4a) < mind2
    mind2 = cabs(zz-p4a)
  endif
  if cabs(zz-p4b) < mind
    mind2 = mind
    mind = cabs(zz-p4b)
    nz = zz - p4b
    nearp = zc + p4b
  elseif cabs(zz-p4b) < mind2
    mind2 = cabs(zz-p4b)
  endif
  if cabs(zz-p4c) < mind
    mind2 = mind
    mind = cabs(zz-p4c)
    nz = zz - p4c
    nearp = zc + p4c
  elseif cabs(zz-p4c) < mind2
    mind2 = cabs(zz-p4c)
  endif
  if cabs(zz-p4d) < mind
    mind2 = mind
    mind = cabs(zz-p4d)
    nz = zz - p4d
    nearp = zc + p4d
  elseif cabs(zz-p4d) < mind2
    mind2 = cabs(zz-p4d)
  endif
  
  nearp = nearp*@psize
  if @mode == 0
    #pixel = nz*exp(-1i*pi/180*@rot)/@magn - @center
  elseif @mode == 1
    #pixel = nearp*exp(-1i*pi/180*@rot)/@magn - @center   
  endif
  
  if @frame == 1
    if abs(mind-mind2) < @tresh/20
      #solid = true
    endif
  elseif @frame == 2
    if abs(mind-mind2) > @tresh/20
      #solid = true
    endif
  elseif @frame == 3
    if cabs(nz) > @tresh/4
      #solid = true
    endif
  elseif @frame == 4
    if cabs(nz) < @tresh/4
      #solid = true
    endif
  endif
  
  nearp = real(nearp)/sqrt(@mr) + 1i*imag(nearp)*sqrt(@mr)
  nearp = (nearp-@mcenter)*exp(1i*pi/180*@mrot)/@msize
  if @mask == 1
    if cabs(nearp) < 1 && @minv
      #solid = true
    endif
    if cabs(nearp) > 1 && !@minv
      #solid = true
    endif
  elseif @mask == 2
    arg = atan2(nearp)
    arg = -round(arg/(2*pi)*@morder)/@morder*(2*pi)
    nearp = nearp*exp(1i*arg)
    if real(nearp) < 1 && @minv
      #solid = true
    endif
    if real(nearp) > 1 && !@minv
      #solid = true
    endif
  endif
      
 
  
default:
  title = "Voroni"
  helpfile = "sam-help/voroni.htm"
  
  param mode
    caption = "Mode"
    default = 0
    enum = "Mapping" "Mosaic" 
  endparam
  
  param frame
    caption = "Framing"
    default = 0
    enum = "None" "Frame In" "Frame Out" "Cells In" "Cells Out"
  endparam
  
  param psize
    caption = "Pattern Size"
    default = .5
  endparam
  
  param tresh
    caption = "Frame Width"
    default = 1.0
  endparam
  
  param regtile
    caption = "Regularize Tiling ?"
    default = true
  endparam
  
  param regpar
    caption = "Regularizing Parameter"
    default = 4.0
    min = 3.0
  endparam
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param magn
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  
  param mask
    caption = "Mask"
    default = 0
    enum = "None" "Circle" "Polygon"
  endparam
  
  param minv
    caption = "Invert Mask ?"
    default = false
  endparam
  
  param morder
    caption = "Polygon Order"
    default = 4
  endparam
  
  param mcenter
    caption = "Mask Center"
    default = (0,0)
  endparam
  
  param mrot
    caption = "Mask Rotation"
    default = 0.0
  endparam
  
  param msize
    caption = "Mask Size"
    default = 1.0
  endparam
  
  param mr
    caption = "Mask Ratio Width/Heigh"
    default = 1.0
  endparam
}

Circle<->Square {
; By Samuel Monnier, 22.7.02
; Idea from Javier Lpez Pea
transform:
  z = (#pixel - @center)*exp(1i*pi/180*@rot)
  float fact = 0
  ; The argument of z
  float arg = atan2(z)
  ; Its modulus
  float r = cabs(z)
  ; The factor the modulus will have to be mutiplied by
  if @trans == 0
    ; A trick to build all the sides together
    float arg2 = round(arg/(2*pi)*@order)/@order*(2*pi)
    float arg3 = arg - arg2
    fact = 1/real((sqrt(1+tan(arg3)^2)))
  elseif @trans == 1
    fact = 1/real(1+sin(arg*@order)^2)
  endif
  ; r is multiplied
  if !@rev
    r = r*fact
  else
    r = r/fact
  endif
  ; z is computed with the new r
  nz = r*exp(1i*arg)*exp(-1i*pi/180*@rot) + @center
  #pixel = (1-@tstr/100)*#pixel + @tstr/100*nz
default:
  title = "Circle <-> Square"
  
  param trans
    caption = "Transformation"
    default = 0
    enum = "Circle -> Square" "Sine"
  endparam
  
  param tstr
    caption = "Trans. Strength (%)"
    default = 100.0
  endparam
  
  param rev
    caption = "Reverse Transform ?"
    default = false
  endparam
  
  param order
    caption = "Side number"
    default = 4.0
  endparam
  
  param center
    caption = "Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
}

alinghiScissor {
; By Samuel Monnier, 24.02.03, waiting for the fourth race...
; The logo is probably copyrighted. So it's wiser to use this 
; only for strictly personal purposes. Thanks !
transform:
  bool bail = false
  z = (#pixel-@center)*exp(1i*pi/180*@rot)/@size
  if @frame == 0 || @frame == 1
    if cabs(z) < 1 && cabs(z+(.3,.1)) > .88
      bail = true
    endif
    if (cabs(z) < 1 && cabs(z+(.3,.1)) < .9) && cabs(z+(.47,.11)) > .9 && cabs(z+(1.05,.4)) < 1.45 && imag(z) < 0
      bail = true
    endif
  else
    if abs(cabs(z) - 1) < @fw && cabs(z+(.3,.1)) > .88-@fw && (cabs(z+(.47,.11)) > .9-@fw || imag(z) > 0)
      bail = true
    endif
    if abs(cabs(z+(.3,.1)) - .88) < @fw && cabs(z) < 1+@fw && (cabs(z+(1.05,.4)) > 1.45 - @fw || imag(z) > 0)
      bail = true
    endif
    if (cabs(z) < 1+@fw && cabs(z+(.3,.1)) < .9-@fw) && abs(cabs(z+(.47,.11)) - .9) < @fw && cabs(z+(1.05,.4)) < 1.45 +@fw && imag(z) < 0
      bail = true
    endif
    if (cabs(z) < 1-@fw && cabs(z+(.3,.1)) < .9-@fw) && cabs(z+(.47,.11)) > .9-@fw && abs(cabs(z+(1.05,.4)) - 1.45) < @fw && imag(z) < 0
      bail = true
    endif
  endif
  if @frame == 0 || @frame == 2
    if cabs(z+(.38,.21)) < .7 && cabs(z+(.18,.26)) > .53
      bail = true
    endif
    if (cabs(z+(.38,.21)) > .7 && cabs(z+(.18,.26)) > .53) && cabs(z+(.37,0.05)) < .7 && cabs(z+(1.2,0)) > 1.3 && imag(z) > -.2
      bail = true
    endif
  else
    if abs(cabs(z+(.38,.21)) - .7) < @fw && cabs(z+(.18,.26)) > .53 - @fw && (cabs(z+(1.2,0)) < 1.3+@fw || imag(z) < -.4)
      bail = true
    endif
    if (cabs(z+(.38,.21)) < .7+@fw || imag(z) > -.4)&& abs(cabs(z+(.18,.26)) - .53) < @fw && (cabs(z+(.37,0.05)) < .7+@fw || imag(z) < -.4)
      bail = true
    endif
    if (cabs(z+(.38,.21)) > .7-@fw && cabs(z+(.18,.26)) > .53-@fw) && abs(cabs(z+(.37,0.05)) - .7) < @fw && cabs(z+(1.2,0)) > 1.3-@fw && imag(z) > -.4
      bail = true
    endif
    if (cabs(z+(.38,.21)) > .7-@fw && cabs(z+(.18,.26)) > .53-@fw) && cabs(z+(.37,0.05)) < .7+@fw && abs(cabs(z+(1.2,0)) - 1.3) < @fw && imag(z) > -.4
      bail = true
    endif
  endif
  if bail && @region == 0
    #solid = true
  endif
  if !bail && @region == 1
    #solid = true
  endif
default:
  title = "alinghi Scissor"
  
  param center
    caption = "Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Rotation"
    default = 0.0
  endparam
  
  param size
    caption = "Size"
    default = 1.0
  endparam
  
  param region
    caption = "Solid Region"
    enum = "Inside" "Outside"
    default = 0
  endparam
  
  param frame
    caption = "Frame"
    enum = "No Frame" "Frame Left" "Frame Right" "Frame Both"
    default = 0
  endparam
  
  param fw
    caption = "Frame Width"
    default = .01
  endparam
}

HyperbolicTilings {
; By Samuel Monnier, 13.2.02 - 19.2.02
transform:
  z = #pixel
  zt = 0
  nz = 0
  if cabs(z) > 1 && @mode != 1
    #solid = true
  endif
  float h = sqrt(cos(pi/@k)^2/(cos(pi/@k)^2-sin(pi/@n)^2))
  float r = sqrt(h^2-1)
  float arg = 0
  float arg2 = 0
  float ratio = 0
  int i = 0
  
  if @mode == 1
    i = @niter
  endif
  
  while i < @niter
    i = i + 1
    
    arg = atan2(z)
    arg = -round(arg/(2*pi)*@n)/@n*(2*pi)
    zt = z*exp(1i*arg)
    if cabs(zt-h) > r  
      if @sym == 0
        nz = abs(zt)
      elseif @sym == 1
        nz = zt
      elseif @sym == 2
        nz = z
      endif
      i = @niter
    else
      z = h+r^2/(zt-h)
    endif
  endwhile
  
  if @mode == 1
    ;nz = (#pixel-@center)*exp(1i*pi/180*@rot)*@magn
    nz = .4*#pixel + .2 + .1i
    arg = atan2(nz)
    if @sym == 0
      if arg < 0 || arg > pi/@n || cabs(nz-h) < r || cabs(nz) > 1
        if (real(#screenpixel) + imag(#screenpixel))%2 == 0
          #solid = true
        endif
      endif
    elseif @sym == 1
      if abs(arg) > pi/@n || cabs(nz-h) < r
        if (real(#screenpixel) + imag(#screenpixel))%2 == 0
          #solid = true
        endif
      endif
    elseif @sym == 2
      arg = -round(arg/(2*pi)*@n)/@n*(2*pi)
      zt = nz*exp(1i*arg) 
      if cabs(zt-h) < r
        if (real(#screenpixel) + imag(#screenpixel))%2 == 0
          #solid = true
        endif
      endif
    endif
  endif
  nz = nz*exp(-1i*pi/180*@rot)/@magn + @center
  
  if @corrmap
    arg = atan2(nz)
    arg = -round(arg/(2*pi)*@n)/@n*(2*pi)
    nz = nz*exp(1i*arg)
    arg2 = atan2(nz)
    ratio = (cos(arg2)*h-sqrt(r^2-h^2*sin(arg2)^2))*cos(arg2)    
    
    nz = nz/ratio*exp(-1i*(arg-pi/2))
  endif
  
  #pixel = nz
    
default:
  title = "Hyperbolic tilings"
  helpfile = "sam-help/hyperbolic.htm"
  
  param mode
    caption = "Mode"
    default = 0
    enum = "Mapping" "One Tile"
  endparam
  
  param n
    caption = "n"
    default = 3
  endparam
  
  param k
    caption = "k"
    default = 7
  endparam
  
  param sym
    caption = "Symetry"
    default = 2
    enum = "Mirror+Rotation" "Rotation only" "None"
  endparam
  
  param center
    caption = "Mapping Center"
    default = (0,0)
  endparam
  
  param rot
    caption = "Mapping Rotation"
    default = 0.0
  endparam
  
  param magn
    caption = "Mapping Magnification"
    default = 1.0
  endparam
  
  param corrmap
    caption = "Correct Mapping ?"
    default = false
  endparam
  
  param niter
    caption = "Iteration Number"
    default = 1000
  endparam
  
  
}

SquareTiling {
; By Samuel Monnier, 18.04.2014
transform:
  z = #pixel
  z = z - round(z/@a)*@a
  #pixel = z
default:
  title = "Square tiling"
  param a
    caption = "Square size"
    default = 1.0
  endparam
}

